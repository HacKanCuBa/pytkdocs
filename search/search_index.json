{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytkdocs \u00a4 Load Python objects documentation. Requirements \u00a4 pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Installation \u00a4 With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs Usage \u00a4 pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"my_module.my_class\" , \"members\" : true , \"filters\" : [ \"!^_[^_]\" ] } ] } Configuration \u00a4 The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only.","title":"Overview"},{"location":"#pytkdocs","text":"Load Python objects documentation.","title":"pytkdocs"},{"location":"#requirements","text":"pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs","title":"Installation"},{"location":"#usage","text":"pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"my_module.my_class\" , \"members\" : true , \"filters\" : [ \"!^_[^_]\" ] } ] }","title":"Usage"},{"location":"#configuration","text":"The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only.","title":"Configuration"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v0.4.0 - 2020-05-17 \u00a4 Compare with v0.3.0 Bug Fixes \u00a4 Never attempt to parse a null docstring ( aa92668 by Timoth\u00e9e Mazzucotelli). References: #37 Restore stdout before printing a traceback ( 20c21e9 by Timoth\u00e9e Mazzucotelli). References: #36 Discard import-time stdout ( 17f71af by Timoth\u00e9e Mazzucotelli). References: #24 Don't allow none for a property's docstring ( b5868f8 by Timoth\u00e9e Mazzucotelli). Fix relative path for native namespace packages ( a74dccf by Shyam Dwaraknath). References: #19 , #22 Code Refactoring \u00a4 Layout a docstring parser base ( d427bcc by Timoth\u00e9e Mazzucotelli). Features \u00a4 Add dataclass and pydantic support ( a172ad8 by Shyam Dwaraknath). References: #9 , #27 v0.3.0 - 2020-04-10 \u00a4 Compare with v0.2.1 Bug Fixes \u00a4 Fix parsing of *args and **kwargs ( b81c93e by adrienhenry). Related issues/PRs: #20 , #21 Features \u00a4 Support different indentations and complex markup in docstrings sections ( 2f53082 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #17 v0.2.1 - 2020-04-07 \u00a4 Compare with v0.2.0 Bug Fixes \u00a4 Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16 v0.2.0 - 2020-03-27 \u00a4 Compare with v0.1.2 Added \u00a4 Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ). Changed \u00a4 The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors , v0.1.2 - 2020-03-23 \u00a4 Compare with v0.1.1 Fixed \u00a4 Catch error when trying to get builtins module file path ( 48df6bc ). v0.1.1 - 2020-03-21 \u00a4 Compare with v0.1.0 Fixed \u00a4 Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ). v0.1.0 - 2020-03-20 \u00a4 Compare with first commit Added \u00a4 Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v040-2020-05-17","text":"Compare with v0.3.0","title":"v0.4.0 - 2020-05-17"},{"location":"changelog/#bug-fixes","text":"Never attempt to parse a null docstring ( aa92668 by Timoth\u00e9e Mazzucotelli). References: #37 Restore stdout before printing a traceback ( 20c21e9 by Timoth\u00e9e Mazzucotelli). References: #36 Discard import-time stdout ( 17f71af by Timoth\u00e9e Mazzucotelli). References: #24 Don't allow none for a property's docstring ( b5868f8 by Timoth\u00e9e Mazzucotelli). Fix relative path for native namespace packages ( a74dccf by Shyam Dwaraknath). References: #19 , #22","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Layout a docstring parser base ( d427bcc by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features","text":"Add dataclass and pydantic support ( a172ad8 by Shyam Dwaraknath). References: #9 , #27","title":"Features"},{"location":"changelog/#v030-2020-04-10","text":"Compare with v0.2.1","title":"v0.3.0 - 2020-04-10"},{"location":"changelog/#bug-fixes_1","text":"Fix parsing of *args and **kwargs ( b81c93e by adrienhenry). Related issues/PRs: #20 , #21","title":"Bug Fixes"},{"location":"changelog/#features_1","text":"Support different indentations and complex markup in docstrings sections ( 2f53082 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #17","title":"Features"},{"location":"changelog/#v021-2020-04-07","text":"Compare with v0.2.0","title":"v0.2.1 - 2020-04-07"},{"location":"changelog/#bug-fixes_2","text":"Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16","title":"Bug Fixes"},{"location":"changelog/#v020-2020-03-27","text":"Compare with v0.1.2","title":"v0.2.0 - 2020-03-27"},{"location":"changelog/#added","text":"Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ).","title":"Added"},{"location":"changelog/#changed","text":"The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors ,","title":"Changed"},{"location":"changelog/#v012-2020-03-23","text":"Compare with v0.1.1","title":"v0.1.2 - 2020-03-23"},{"location":"changelog/#fixed","text":"Catch error when trying to get builtins module file path ( 48df6bc ).","title":"Fixed"},{"location":"changelog/#v011-2020-03-21","text":"Compare with v0.1.0","title":"v0.1.1 - 2020-03-21"},{"location":"changelog/#fixed_1","text":"Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ).","title":"Fixed"},{"location":"changelog/#v010-2020-03-20","text":"Compare with first commit","title":"v0.1.0 - 2020-03-20"},{"location":"changelog/#added_1","text":"Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Added"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd pytkdocs make setup That's it! You now have the dependencies installed. You can run the application with poetry run pytkdocs [ARGS...] . Run make help to see all the available actions! Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd pytkdocs make setup That's it! You now have the dependencies installed. You can run the application with poetry run pytkdocs [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build pytkdocs . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 bandit | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | pydantic | pytest | pytest-cov | pytest-sugar | pytest-xdist | requests | toml Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | beautifulsoup4 | certifi | chardet | click | colorama | dataclasses | decorator | entrypoints | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build pytkdocs . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | pydantic | pytest | pytest-cov | pytest-sugar | pytest-xdist | requests | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | beautifulsoup4 | certifi | chardet | click | colorama | dataclasses | decorator | entrypoints | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Indirect dependencies"},{"location":"developers/test_suite/__init__/","text":"\u00a4 In this module we simply define some path constants. FIXTURES_DIR: Path \u00a4 The tests/fixtures directory path object. TESTS_DIR: Path \u00a4 The tests directory path object. TMP_DIR: Path \u00a4 The tests/tmp directory path object.","title":"__init__.py"},{"location":"developers/test_suite/__init__/#tests.__init__","text":"In this module we simply define some path constants.","title":"tests.__init__"},{"location":"developers/test_suite/__init__/#tests.__init__.FIXTURES_DIR","text":"The tests/fixtures directory path object.","title":"FIXTURES_DIR"},{"location":"developers/test_suite/__init__/#tests.__init__.TESTS_DIR","text":"The tests directory path object.","title":"TESTS_DIR"},{"location":"developers/test_suite/__init__/#tests.__init__.TMP_DIR","text":"The tests/tmp directory path object.","title":"TMP_DIR"},{"location":"developers/test_suite/conftest/","text":"\u00a4 Configuration for pytest. pytest_itemcollected ( item ) \u00a4 Make tests names more readable in the tests output. Source code in tests/conftest.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def pytest_itemcollected ( item ): \"\"\"Make tests names more readable in the tests output.\"\"\" item . _nodeid = ( item . _nodeid . replace ( \".py\" , \"\" ) . replace ( \"tests/\" , \"\" ) . replace ( \"test_\" , \"\" ) . replace ( \"_\" , \" \" ) . replace ( \"Test\" , \"\" ) . replace ( \"Class\" , \" class\" ) . lower () ) doc = item . obj . __doc__ . strip () if item . obj . __doc__ else \"\" if doc : item . _nodeid = item . _nodeid . split ( \"::\" )[ 0 ] + \"::\" + doc","title":"conftest.py"},{"location":"developers/test_suite/conftest/#tests.conftest","text":"Configuration for pytest.","title":"tests.conftest"},{"location":"developers/test_suite/conftest/#tests.conftest.pytest_itemcollected","text":"Make tests names more readable in the tests output. Source code in tests/conftest.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def pytest_itemcollected ( item ): \"\"\"Make tests names more readable in the tests output.\"\"\" item . _nodeid = ( item . _nodeid . replace ( \".py\" , \"\" ) . replace ( \"tests/\" , \"\" ) . replace ( \"test_\" , \"\" ) . replace ( \"_\" , \" \" ) . replace ( \"Test\" , \"\" ) . replace ( \"Class\" , \" class\" ) . lower () ) doc = item . obj . __doc__ . strip () if item . obj . __doc__ else \"\" if doc : item . _nodeid = item . _nodeid . split ( \"::\" )[ 0 ] + \"::\" + doc","title":"pytest_itemcollected()"},{"location":"developers/test_suite/test_cli/","text":"\u00a4 Tests for [the cli module][pytkdocs.cli]. test_discard_stdout ( monkeypatch , capsys ) \u00a4 Discard standard output at import time. Source code in tests/test_cli.py 49 50 51 52 53 54 55 56 def test_discard_stdout ( monkeypatch , capsys ): \"\"\"Discard standard output at import time.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"tests.fixtures.corrupt_output\"}]}' )) cli . main ([ \"--line-by-line\" ]) captured = capsys . readouterr () assert not captured . out . startswith ( \"*corruption intensifies*\" ) # assert no JSON parsing error json . loads ( captured . out ) test_exception_raised_while_discard_stdout ( monkeypatch , capsys ) \u00a4 Check that an error is still printed when an exception is raised and stdout is discarded. Source code in tests/test_cli.py 59 60 61 62 63 64 65 66 67 68 69 70 def test_exception_raised_while_discard_stdout ( monkeypatch , capsys ): \"\"\"Check that an error is still printed when an exception is raised and stdout is discarded.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs.cli\"}]}' )) # raise an exception during the process monkeypatch . setattr ( \"pytkdocs.cli.process_json\" , lambda _ : 1 / 0 ) # assert no exception cli . main ([ \"--line-by-line\" ]) # assert json error was written to stdout captured = capsys . readouterr () assert captured . out # assert no JSON parsing error json . loads ( captured . out ) test_load_complete_tree ( monkeypatch ) \u00a4 Load pytkdocs own documentation. Source code in tests/test_cli.py 43 44 45 46 def test_load_complete_tree ( monkeypatch ): \"\"\"Load `pytkdocs` own documentation.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs\"}]}' )) cli . main ([ \"--line-by-line\" ]) test_read_stdin_line_by_line ( monkeypatch ) \u00a4 Read standard input line by line. Source code in tests/test_cli.py 32 33 34 35 36 37 38 39 40 def test_read_stdin_line_by_line ( monkeypatch ): \"\"\"Read standard input line by line.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs.cli.main\"}]} \\n {\"objects\": [{\"path\": \"pytkdocs.cli.get_parser\"}]} \\n ' ), ) cli . main ([ \"--line-by-line\" ]) test_read_whole_stdin ( monkeypatch ) \u00a4 Read whole standard input. Source code in tests/test_cli.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def test_read_whole_stdin ( monkeypatch ): \"\"\"Read whole standard input.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( \"\"\" { \"objects\": [ { \"path\": \"pytkdocs.cli.main\" }, { \"path\": \"pytkdocs.cli.get_parser\" } ] } \"\"\" ), ) cli . main ()","title":"test_cli.py"},{"location":"developers/test_suite/test_cli/#tests.test_cli","text":"Tests for [the cli module][pytkdocs.cli].","title":"tests.test_cli"},{"location":"developers/test_suite/test_cli/#tests.test_cli.test_discard_stdout","text":"Discard standard output at import time. Source code in tests/test_cli.py 49 50 51 52 53 54 55 56 def test_discard_stdout ( monkeypatch , capsys ): \"\"\"Discard standard output at import time.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"tests.fixtures.corrupt_output\"}]}' )) cli . main ([ \"--line-by-line\" ]) captured = capsys . readouterr () assert not captured . out . startswith ( \"*corruption intensifies*\" ) # assert no JSON parsing error json . loads ( captured . out )","title":"test_discard_stdout()"},{"location":"developers/test_suite/test_cli/#tests.test_cli.test_exception_raised_while_discard_stdout","text":"Check that an error is still printed when an exception is raised and stdout is discarded. Source code in tests/test_cli.py 59 60 61 62 63 64 65 66 67 68 69 70 def test_exception_raised_while_discard_stdout ( monkeypatch , capsys ): \"\"\"Check that an error is still printed when an exception is raised and stdout is discarded.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs.cli\"}]}' )) # raise an exception during the process monkeypatch . setattr ( \"pytkdocs.cli.process_json\" , lambda _ : 1 / 0 ) # assert no exception cli . main ([ \"--line-by-line\" ]) # assert json error was written to stdout captured = capsys . readouterr () assert captured . out # assert no JSON parsing error json . loads ( captured . out )","title":"test_exception_raised_while_discard_stdout()"},{"location":"developers/test_suite/test_cli/#tests.test_cli.test_load_complete_tree","text":"Load pytkdocs own documentation. Source code in tests/test_cli.py 43 44 45 46 def test_load_complete_tree ( monkeypatch ): \"\"\"Load `pytkdocs` own documentation.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs\"}]}' )) cli . main ([ \"--line-by-line\" ])","title":"test_load_complete_tree()"},{"location":"developers/test_suite/test_cli/#tests.test_cli.test_read_stdin_line_by_line","text":"Read standard input line by line. Source code in tests/test_cli.py 32 33 34 35 36 37 38 39 40 def test_read_stdin_line_by_line ( monkeypatch ): \"\"\"Read standard input line by line.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( '{\"objects\": [{\"path\": \"pytkdocs.cli.main\"}]} \\n {\"objects\": [{\"path\": \"pytkdocs.cli.get_parser\"}]} \\n ' ), ) cli . main ([ \"--line-by-line\" ])","title":"test_read_stdin_line_by_line()"},{"location":"developers/test_suite/test_cli/#tests.test_cli.test_read_whole_stdin","text":"Read whole standard input. Source code in tests/test_cli.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def test_read_whole_stdin ( monkeypatch ): \"\"\"Read whole standard input.\"\"\" monkeypatch . setattr ( \"sys.stdin\" , io . StringIO ( \"\"\" { \"objects\": [ { \"path\": \"pytkdocs.cli.main\" }, { \"path\": \"pytkdocs.cli.get_parser\" } ] } \"\"\" ), ) cli . main ()","title":"test_read_whole_stdin()"},{"location":"developers/test_suite/test_loader/","text":"\u00a4 Tests for [the loader module][pytkdocs.loader]. test_can_find_class_attribute_real_path () \u00a4 Find real path of a class attribute. Source code in tests/test_loader.py 36 37 38 39 def test_can_find_class_attribute_real_path (): \"\"\"Find real path of a class attribute.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB.ATTRIBUTE\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB.ATTRIBUTE\" test_can_find_class_method_real_path () \u00a4 Find real path of a class method. Source code in tests/test_loader.py 30 31 32 33 def test_can_find_class_method_real_path (): \"\"\"Find real path of a class method.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB.method\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB.method\" test_can_find_class_real_path () \u00a4 Find real path of a class. Source code in tests/test_loader.py 24 25 26 27 def test_can_find_class_real_path (): \"\"\"Find real path of a class.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB\" test_cannot_find_module_attribute_real_path () \u00a4 Find real path of a module attribute. Source code in tests/test_loader.py 42 43 44 45 def test_cannot_find_module_attribute_real_path (): \"\"\"Find real path of a module attribute.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.ATTRIBUTE\" ) assert not leaf . dotted_path == \"tests.fixtures.real_path.module_b.ATTRIBUTE\" test_import_error () \u00a4 Raise error when getting tree for missing object. Source code in tests/test_loader.py 18 19 20 21 def test_import_error (): \"\"\"Raise error when getting tree for missing object.\"\"\" with pytest . raises ( ImportError ): get_object_tree ( \"eeeeeeeeeeeeeeeeeee\" ) test_import_no_path () \u00a4 Raise error when getting tree for empty object name. Source code in tests/test_loader.py 12 13 14 15 def test_import_no_path (): \"\"\"Raise error when getting tree for empty object name.\"\"\" with pytest . raises ( ValueError ): get_object_tree ( \"\" ) test_inheriting_enum_Enum () \u00a4 Handle enum.Enum classes. Source code in tests/test_loader.py 48 49 50 51 52 53 def test_inheriting_enum_Enum (): \"\"\"Handle `enum.Enum` classes.\"\"\" \"\"\"See details at [tests.fixtures.inheriting_enum_Enum][].\"\"\" loader = Loader () loader . get_object_documentation ( \"tests.fixtures.inheriting_enum_Enum\" ) assert not loader . errors test_inheriting_typing_NamedTuple () \u00a4 Handle typing.NamedTuple classes . See details at [tests.fixtures.inheriting_typing_NamedTuple][]. Source code in tests/test_loader.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def test_inheriting_typing_NamedTuple (): \"\"\" Handle `typing.NamedTuple classes`. See details at [tests.fixtures.inheriting_typing_NamedTuple][]. \"\"\" loader = Loader () loader . get_object_documentation ( \"tests.fixtures.inheriting_typing_NamedTuple\" ) if sys . version . startswith ( \"3.8\" ): assert len ( loader . errors ) == 1 else : # there are 4 class-attributes, 2 errors (source, signature) per attribute assert len ( loader . errors ) >= 8 for error in loader . errors [ - 8 :]: assert \"itemgetter\" in error for error in loader . errors [: - 8 ]: assert \"could not get source code\" in error test_loading_attribute () \u00a4 Select attribute. Source code in tests/test_loader.py 256 257 258 259 260 def test_loading_attribute (): \"\"\"Select attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute docstring.\" test_loading_class () \u00a4 Handle classes. Source code in tests/test_loader.py 119 120 121 122 123 def test_loading_class (): \"\"\"Handle classes.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass\" ) assert obj . docstring == \"The class docstring.\" test_loading_class_attribute () \u00a4 Select class attribute. Source code in tests/test_loader.py 175 176 177 178 179 def test_loading_class_attribute (): \"\"\"Select class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.1 docstring.\" test_loading_class_method () \u00a4 Select class method. Source code in tests/test_loader.py 198 199 200 201 202 def test_loading_class_method (): \"\"\"Select class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_method\" ) assert obj . docstring == \"The method1 docstring.\" test_loading_classmethod () \u00a4 Select class method. Source code in tests/test_loader.py 228 229 230 231 232 def test_loading_classmethod (): \"\"\"Select class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_class_method\" ) assert obj . docstring == \"The class method docstring.\" test_loading_dataclass () \u00a4 Handle dataclasses. Source code in tests/test_loader.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def test_loading_dataclass (): \"\"\"Handle dataclasses.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.dataclass.Person\" ) assert obj . docstring == \"Simple dataclass for a person's information\" assert len ( obj . attributes ) == 2 name_attr = next ( attr for attr in obj . attributes if attr . name == \"name\" ) assert name_attr . type == str age_attr = next ( attr for attr in obj . attributes if attr . name == \"age\" ) assert age_attr . type == int assert \"dataclass\" in obj . properties not_dataclass = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass\" ) assert \"dataclass\" not in not_dataclass . properties test_loading_deep_package () \u00a4 Handle deep nesting of packages. Source code in tests/test_loader.py 86 87 88 89 90 91 def test_loading_deep_package (): \"\"\"Handle deep nesting of packages.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.pkg1.pkg2.pkg3.pkg4.pkg5\" ) assert obj . docstring == \"Hello from the abyss.\" assert obj . path == \"tests.fixtures.pkg1.pkg2.pkg3.pkg4.pkg5\" test_loading_double_nested_class () \u00a4 Select double-nested class. Source code in tests/test_loader.py 166 167 168 169 170 171 172 def test_loading_double_nested_class (): \"\"\"Select double-nested class.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass\" ) assert obj . docstring == \"The double nested class docstring.\" test_loading_double_nested_class_attribute () \u00a4 Select double-nested-class attribute. Source code in tests/test_loader.py 189 190 191 192 193 194 195 def test_loading_double_nested_class_attribute (): \"\"\"Select double-nested-class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.3 docstring.\" test_loading_double_nested_class_method () \u00a4 Select double-nested class method. Source code in tests/test_loader.py 212 213 214 215 216 217 218 def test_loading_double_nested_class_method (): \"\"\"Select double-nested class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass.the_method\" ) assert obj . docstring == \"The method3 docstring.\" test_loading_explicit_members () \u00a4 Select members explicitly. Source code in tests/test_loader.py 263 264 265 266 267 268 def test_loading_explicit_members (): \"\"\"Select members explicitly.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = { \"TheClass\" }) assert len ( obj . children ) == 1 assert obj . children [ 0 ] . name == \"TheClass\" test_loading_function () \u00a4 Select function. Source code in tests/test_loader.py 249 250 251 252 253 def test_loading_function (): \"\"\"Select function.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.the_function\" ) assert obj . docstring == \"The function docstring.\" test_loading_members_set_at_import_time () \u00a4 Select dynamic members. Source code in tests/test_loader.py 307 308 309 310 311 312 313 314 def test_loading_members_set_at_import_time (): \"\"\"Select dynamic members.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.dynamic_members\" ) assert obj . functions assert len ( obj . classes ) == 1 class_ = obj . classes [ 0 ] assert class_ . methods test_loading_module () \u00a4 Handle single modules. Source code in tests/test_loader.py 112 113 114 115 116 def test_loading_module (): \"\"\"Handle single modules.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) assert obj . docstring == \"The module docstring.\" test_loading_namespace_package () \u00a4 Handle native namespace packages. Source code in tests/test_loader.py 101 102 103 104 105 106 107 108 109 def test_loading_namespace_package (): \"\"\"Handle native namespace packages.\"\"\" loader = Loader () old_paths = list ( sys . path ) sys . path . append ( str ( Path ( FIXTURES_DIR ) . resolve ())) obj = loader . get_object_documentation ( \"test_namespace.subspace\" ) assert obj . docstring == \"The subspace package docstring.\" assert obj . relative_file_path == \"subspace/__init__.py\" sys . path = old_paths test_loading_nested_class () \u00a4 Select nested class. Source code in tests/test_loader.py 159 160 161 162 163 def test_loading_nested_class (): \"\"\"Select nested class.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass\" ) assert obj . docstring == \"The nested class docstring.\" test_loading_nested_class_attribute () \u00a4 Select nested-class attribute. Source code in tests/test_loader.py 182 183 184 185 186 def test_loading_nested_class_attribute (): \"\"\"Select nested-class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.2 docstring.\" test_loading_nested_class_method () \u00a4 Select nested class method. Source code in tests/test_loader.py 205 206 207 208 209 def test_loading_nested_class_method (): \"\"\"Select nested class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.the_method\" ) assert obj . docstring == \"The method2 docstring.\" test_loading_no_members () \u00a4 Select no members. Source code in tests/test_loader.py 271 272 273 274 275 def test_loading_no_members (): \"\"\"Select no members.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = False ) assert not obj . children test_loading_package () \u00a4 Handle basic packages. Source code in tests/test_loader.py 94 95 96 97 98 def test_loading_package (): \"\"\"Handle basic packages.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package\" ) assert obj . docstring == \"The package docstring.\" test_loading_property () \u00a4 Select property. Source code in tests/test_loader.py 235 236 237 238 239 def test_loading_property (): \"\"\"Select property.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_property\" ) assert obj . docstring == \"The property docstring.\" test_loading_pydantic_model () \u00a4 Handle Pydantic models. Source code in tests/test_loader.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def test_loading_pydantic_model (): \"\"\"Handle Pydantic models.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.pydantic.Person\" ) assert obj . docstring == \"Simple Pydantic Model for a person's information\" assert \"pydantic\" in obj . properties assert len ( obj . attributes ) == 2 name_attr = next ( attr for attr in obj . attributes if attr . name == \"name\" ) assert name_attr . type == str assert name_attr . docstring == \"The person's name\" assert \"pydantic\" in name_attr . properties age_attr = next ( attr for attr in obj . attributes if attr . name == \"age\" ) assert age_attr . type == int assert age_attr . docstring == \"The person's age which must be at minimum 18\" assert \"pydantic\" in age_attr . properties test_loading_staticmethod () \u00a4 Select static method. Source code in tests/test_loader.py 221 222 223 224 225 def test_loading_staticmethod (): \"\"\"Select static method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_static_method\" ) assert obj . docstring == \"The static method docstring.\" test_loading_with_filters () \u00a4 Select with filters. Source code in tests/test_loader.py 278 279 280 281 282 283 def test_loading_with_filters (): \"\"\"Select with filters.\"\"\" loader = Loader ( filters = [ \"!^[A-Z_]+$\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) for child in obj . children : assert child . name != \"THE_ATTRIBUTE\" test_loading_with_filters_reselection () \u00a4 A filter can cancel a previous filter. Source code in tests/test_loader.py 286 287 288 289 290 291 def test_loading_with_filters_reselection (): \"\"\"A filter can cancel a previous filter.\"\"\" loader = Loader ( filters = [ \"![A-Z_]\" , \"[a-z]\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) assert obj . classes assert obj . classes [ 0 ] . name == \"TheClass\" test_loading_with_members_and_filters () \u00a4 Select members with filters. Source code in tests/test_loader.py 294 295 296 297 298 299 300 301 302 303 304 def test_loading_with_members_and_filters (): \"\"\"Select members with filters.\"\"\" loader = Loader ( filters = [ \"!THE\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = { \"THE_ATTRIBUTE\" , \"TheClass\" } ) assert obj . attributes assert obj . attributes [ 0 ] . name == \"THE_ATTRIBUTE\" assert obj . classes assert obj . classes [ 0 ] . name == \"TheClass\" assert not any ( a . name == \"THE_ATTRIBUTE\" for a in obj . classes [ 0 ] . attributes ) test_loading_writable_property () \u00a4 Select writable property. Source code in tests/test_loader.py 242 243 244 245 246 def test_loading_writable_property (): \"\"\"Select writable property.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_writable_property\" ) assert obj . docstring == \"The writable property getter docstring.\" test_nested_class () \u00a4 Handle nested classes. Source code in tests/test_loader.py 76 77 78 79 80 81 82 83 def test_nested_class (): \"\"\"Handle nested classes.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.nested_class\" ) assert obj . classes assert obj . classes [ 0 ] . docstring == \"Main docstring.\" assert obj . classes [ 0 ] . classes assert obj . classes [ 0 ] . classes [ 0 ] . docstring == \"Nested docstring.\"","title":"test_loader.py"},{"location":"developers/test_suite/test_loader/#tests.test_loader","text":"Tests for [the loader module][pytkdocs.loader].","title":"tests.test_loader"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_can_find_class_attribute_real_path","text":"Find real path of a class attribute. Source code in tests/test_loader.py 36 37 38 39 def test_can_find_class_attribute_real_path (): \"\"\"Find real path of a class attribute.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB.ATTRIBUTE\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB.ATTRIBUTE\"","title":"test_can_find_class_attribute_real_path()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_can_find_class_method_real_path","text":"Find real path of a class method. Source code in tests/test_loader.py 30 31 32 33 def test_can_find_class_method_real_path (): \"\"\"Find real path of a class method.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB.method\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB.method\"","title":"test_can_find_class_method_real_path()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_can_find_class_real_path","text":"Find real path of a class. Source code in tests/test_loader.py 24 25 26 27 def test_can_find_class_real_path (): \"\"\"Find real path of a class.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.DefinedInModuleB\" ) assert leaf . dotted_path == \"tests.fixtures.real_path.module_b.DefinedInModuleB\"","title":"test_can_find_class_real_path()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_cannot_find_module_attribute_real_path","text":"Find real path of a module attribute. Source code in tests/test_loader.py 42 43 44 45 def test_cannot_find_module_attribute_real_path (): \"\"\"Find real path of a module attribute.\"\"\" leaf = get_object_tree ( \"tests.fixtures.real_path.module_a.ATTRIBUTE\" ) assert not leaf . dotted_path == \"tests.fixtures.real_path.module_b.ATTRIBUTE\"","title":"test_cannot_find_module_attribute_real_path()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_import_error","text":"Raise error when getting tree for missing object. Source code in tests/test_loader.py 18 19 20 21 def test_import_error (): \"\"\"Raise error when getting tree for missing object.\"\"\" with pytest . raises ( ImportError ): get_object_tree ( \"eeeeeeeeeeeeeeeeeee\" )","title":"test_import_error()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_import_no_path","text":"Raise error when getting tree for empty object name. Source code in tests/test_loader.py 12 13 14 15 def test_import_no_path (): \"\"\"Raise error when getting tree for empty object name.\"\"\" with pytest . raises ( ValueError ): get_object_tree ( \"\" )","title":"test_import_no_path()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_inheriting_enum_Enum","text":"Handle enum.Enum classes. Source code in tests/test_loader.py 48 49 50 51 52 53 def test_inheriting_enum_Enum (): \"\"\"Handle `enum.Enum` classes.\"\"\" \"\"\"See details at [tests.fixtures.inheriting_enum_Enum][].\"\"\" loader = Loader () loader . get_object_documentation ( \"tests.fixtures.inheriting_enum_Enum\" ) assert not loader . errors","title":"test_inheriting_enum_Enum()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_inheriting_typing_NamedTuple","text":"Handle typing.NamedTuple classes . See details at [tests.fixtures.inheriting_typing_NamedTuple][]. Source code in tests/test_loader.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def test_inheriting_typing_NamedTuple (): \"\"\" Handle `typing.NamedTuple classes`. See details at [tests.fixtures.inheriting_typing_NamedTuple][]. \"\"\" loader = Loader () loader . get_object_documentation ( \"tests.fixtures.inheriting_typing_NamedTuple\" ) if sys . version . startswith ( \"3.8\" ): assert len ( loader . errors ) == 1 else : # there are 4 class-attributes, 2 errors (source, signature) per attribute assert len ( loader . errors ) >= 8 for error in loader . errors [ - 8 :]: assert \"itemgetter\" in error for error in loader . errors [: - 8 ]: assert \"could not get source code\" in error","title":"test_inheriting_typing_NamedTuple()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_attribute","text":"Select attribute. Source code in tests/test_loader.py 256 257 258 259 260 def test_loading_attribute (): \"\"\"Select attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute docstring.\"","title":"test_loading_attribute()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_class","text":"Handle classes. Source code in tests/test_loader.py 119 120 121 122 123 def test_loading_class (): \"\"\"Handle classes.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass\" ) assert obj . docstring == \"The class docstring.\"","title":"test_loading_class()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_class_attribute","text":"Select class attribute. Source code in tests/test_loader.py 175 176 177 178 179 def test_loading_class_attribute (): \"\"\"Select class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.1 docstring.\"","title":"test_loading_class_attribute()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_class_method","text":"Select class method. Source code in tests/test_loader.py 198 199 200 201 202 def test_loading_class_method (): \"\"\"Select class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_method\" ) assert obj . docstring == \"The method1 docstring.\"","title":"test_loading_class_method()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_classmethod","text":"Select class method. Source code in tests/test_loader.py 228 229 230 231 232 def test_loading_classmethod (): \"\"\"Select class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_class_method\" ) assert obj . docstring == \"The class method docstring.\"","title":"test_loading_classmethod()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_dataclass","text":"Handle dataclasses. Source code in tests/test_loader.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def test_loading_dataclass (): \"\"\"Handle dataclasses.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.dataclass.Person\" ) assert obj . docstring == \"Simple dataclass for a person's information\" assert len ( obj . attributes ) == 2 name_attr = next ( attr for attr in obj . attributes if attr . name == \"name\" ) assert name_attr . type == str age_attr = next ( attr for attr in obj . attributes if attr . name == \"age\" ) assert age_attr . type == int assert \"dataclass\" in obj . properties not_dataclass = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass\" ) assert \"dataclass\" not in not_dataclass . properties","title":"test_loading_dataclass()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_deep_package","text":"Handle deep nesting of packages. Source code in tests/test_loader.py 86 87 88 89 90 91 def test_loading_deep_package (): \"\"\"Handle deep nesting of packages.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.pkg1.pkg2.pkg3.pkg4.pkg5\" ) assert obj . docstring == \"Hello from the abyss.\" assert obj . path == \"tests.fixtures.pkg1.pkg2.pkg3.pkg4.pkg5\"","title":"test_loading_deep_package()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_double_nested_class","text":"Select double-nested class. Source code in tests/test_loader.py 166 167 168 169 170 171 172 def test_loading_double_nested_class (): \"\"\"Select double-nested class.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass\" ) assert obj . docstring == \"The double nested class docstring.\"","title":"test_loading_double_nested_class()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_double_nested_class_attribute","text":"Select double-nested-class attribute. Source code in tests/test_loader.py 189 190 191 192 193 194 195 def test_loading_double_nested_class_attribute (): \"\"\"Select double-nested-class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.3 docstring.\"","title":"test_loading_double_nested_class_attribute()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_double_nested_class_method","text":"Select double-nested class method. Source code in tests/test_loader.py 212 213 214 215 216 217 218 def test_loading_double_nested_class_method (): \"\"\"Select double-nested class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.TheDoubleNestedClass.the_method\" ) assert obj . docstring == \"The method3 docstring.\"","title":"test_loading_double_nested_class_method()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_explicit_members","text":"Select members explicitly. Source code in tests/test_loader.py 263 264 265 266 267 268 def test_loading_explicit_members (): \"\"\"Select members explicitly.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = { \"TheClass\" }) assert len ( obj . children ) == 1 assert obj . children [ 0 ] . name == \"TheClass\"","title":"test_loading_explicit_members()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_function","text":"Select function. Source code in tests/test_loader.py 249 250 251 252 253 def test_loading_function (): \"\"\"Select function.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.the_function\" ) assert obj . docstring == \"The function docstring.\"","title":"test_loading_function()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_members_set_at_import_time","text":"Select dynamic members. Source code in tests/test_loader.py 307 308 309 310 311 312 313 314 def test_loading_members_set_at_import_time (): \"\"\"Select dynamic members.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.dynamic_members\" ) assert obj . functions assert len ( obj . classes ) == 1 class_ = obj . classes [ 0 ] assert class_ . methods","title":"test_loading_members_set_at_import_time()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_module","text":"Handle single modules. Source code in tests/test_loader.py 112 113 114 115 116 def test_loading_module (): \"\"\"Handle single modules.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) assert obj . docstring == \"The module docstring.\"","title":"test_loading_module()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_namespace_package","text":"Handle native namespace packages. Source code in tests/test_loader.py 101 102 103 104 105 106 107 108 109 def test_loading_namespace_package (): \"\"\"Handle native namespace packages.\"\"\" loader = Loader () old_paths = list ( sys . path ) sys . path . append ( str ( Path ( FIXTURES_DIR ) . resolve ())) obj = loader . get_object_documentation ( \"test_namespace.subspace\" ) assert obj . docstring == \"The subspace package docstring.\" assert obj . relative_file_path == \"subspace/__init__.py\" sys . path = old_paths","title":"test_loading_namespace_package()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_nested_class","text":"Select nested class. Source code in tests/test_loader.py 159 160 161 162 163 def test_loading_nested_class (): \"\"\"Select nested class.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass\" ) assert obj . docstring == \"The nested class docstring.\"","title":"test_loading_nested_class()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_nested_class_attribute","text":"Select nested-class attribute. Source code in tests/test_loader.py 182 183 184 185 186 def test_loading_nested_class_attribute (): \"\"\"Select nested-class attribute.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.THE_ATTRIBUTE\" ) assert obj . docstring == \"The attribute 0.2 docstring.\"","title":"test_loading_nested_class_attribute()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_nested_class_method","text":"Select nested class method. Source code in tests/test_loader.py 205 206 207 208 209 def test_loading_nested_class_method (): \"\"\"Select nested class method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.TheNestedClass.the_method\" ) assert obj . docstring == \"The method2 docstring.\"","title":"test_loading_nested_class_method()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_no_members","text":"Select no members. Source code in tests/test_loader.py 271 272 273 274 275 def test_loading_no_members (): \"\"\"Select no members.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = False ) assert not obj . children","title":"test_loading_no_members()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_package","text":"Handle basic packages. Source code in tests/test_loader.py 94 95 96 97 98 def test_loading_package (): \"\"\"Handle basic packages.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package\" ) assert obj . docstring == \"The package docstring.\"","title":"test_loading_package()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_property","text":"Select property. Source code in tests/test_loader.py 235 236 237 238 239 def test_loading_property (): \"\"\"Select property.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_property\" ) assert obj . docstring == \"The property docstring.\"","title":"test_loading_property()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_pydantic_model","text":"Handle Pydantic models. Source code in tests/test_loader.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def test_loading_pydantic_model (): \"\"\"Handle Pydantic models.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.pydantic.Person\" ) assert obj . docstring == \"Simple Pydantic Model for a person's information\" assert \"pydantic\" in obj . properties assert len ( obj . attributes ) == 2 name_attr = next ( attr for attr in obj . attributes if attr . name == \"name\" ) assert name_attr . type == str assert name_attr . docstring == \"The person's name\" assert \"pydantic\" in name_attr . properties age_attr = next ( attr for attr in obj . attributes if attr . name == \"age\" ) assert age_attr . type == int assert age_attr . docstring == \"The person's age which must be at minimum 18\" assert \"pydantic\" in age_attr . properties","title":"test_loading_pydantic_model()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_staticmethod","text":"Select static method. Source code in tests/test_loader.py 221 222 223 224 225 def test_loading_staticmethod (): \"\"\"Select static method.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_static_method\" ) assert obj . docstring == \"The static method docstring.\"","title":"test_loading_staticmethod()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_with_filters","text":"Select with filters. Source code in tests/test_loader.py 278 279 280 281 282 283 def test_loading_with_filters (): \"\"\"Select with filters.\"\"\" loader = Loader ( filters = [ \"!^[A-Z_]+$\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) for child in obj . children : assert child . name != \"THE_ATTRIBUTE\"","title":"test_loading_with_filters()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_with_filters_reselection","text":"A filter can cancel a previous filter. Source code in tests/test_loader.py 286 287 288 289 290 291 def test_loading_with_filters_reselection (): \"\"\"A filter can cancel a previous filter.\"\"\" loader = Loader ( filters = [ \"![A-Z_]\" , \"[a-z]\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" ) assert obj . classes assert obj . classes [ 0 ] . name == \"TheClass\"","title":"test_loading_with_filters_reselection()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_with_members_and_filters","text":"Select members with filters. Source code in tests/test_loader.py 294 295 296 297 298 299 300 301 302 303 304 def test_loading_with_members_and_filters (): \"\"\"Select members with filters.\"\"\" loader = Loader ( filters = [ \"!THE\" ]) obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module\" , members = { \"THE_ATTRIBUTE\" , \"TheClass\" } ) assert obj . attributes assert obj . attributes [ 0 ] . name == \"THE_ATTRIBUTE\" assert obj . classes assert obj . classes [ 0 ] . name == \"TheClass\" assert not any ( a . name == \"THE_ATTRIBUTE\" for a in obj . classes [ 0 ] . attributes )","title":"test_loading_with_members_and_filters()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_loading_writable_property","text":"Select writable property. Source code in tests/test_loader.py 242 243 244 245 246 def test_loading_writable_property (): \"\"\"Select writable property.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.the_package.the_module.TheClass.the_writable_property\" ) assert obj . docstring == \"The writable property getter docstring.\"","title":"test_loading_writable_property()"},{"location":"developers/test_suite/test_loader/#tests.test_loader.test_nested_class","text":"Handle nested classes. Source code in tests/test_loader.py 76 77 78 79 80 81 82 83 def test_nested_class (): \"\"\"Handle nested classes.\"\"\" loader = Loader () obj = loader . get_object_documentation ( \"tests.fixtures.nested_class\" ) assert obj . classes assert obj . classes [ 0 ] . docstring == \"Main docstring.\" assert obj . classes [ 0 ] . classes assert obj . classes [ 0 ] . classes [ 0 ] . docstring == \"Nested docstring.\"","title":"test_nested_class()"},{"location":"developers/test_suite/test_objects/","text":"\u00a4 Tests for [the objects module][pytkdocs.objects]. test_add_child () \u00a4 Add a child. Source code in tests/test_objects.py 34 35 36 37 38 39 40 def test_add_child (): \"\"\"Add a child.\"\"\" parent = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) child = Attribute ( name = \"my_attribute\" , path = \"my.dotted.path.my_attribute\" , file_path = \"/my/absolute/path.py\" ) parent . add_child ( child ) assert parent . children [ 0 ] is child assert parent . attributes [ 0 ] is child test_add_children () \u00a4 Add multiple children at once. Source code in tests/test_objects.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def test_add_children (): \"\"\"Add multiple children at once.\"\"\" root = Object ( name = \"o\" , path = \"o\" , file_path = \"o.py\" ) class_ = Class ( name = \"c\" , path = \"o.c\" , file_path = \"o.py\" ) attribute = Attribute ( name = \"a\" , path = \"o.c.a\" , file_path = \"o.py\" ) class_ . add_child ( attribute ) root . add_children ( [ # class has wrong path Class ( name = \"w\" , path = \"wrong.path.w\" , file_path = \"/wrong/path/w.py\" ), # class OK class_ , # not a direct child, attribute , # function OK Function ( name = \"f\" , path = \"o.f\" , file_path = \"o.py\" ), # not a direct child, not even a child of known child Method ( name = \"missing_node\" , path = \"o.mn.missing_node\" , file_path = \"o.py\" ), ] ) assert len ( root . children ) == 2 assert root . classes and root . classes [ 0 ] is class_ assert root . functions and root . functions [ 0 ] . name == \"f\" test_creating_attribute () \u00a4 Create an Attribute. Source code in tests/test_objects.py 29 30 31 def test_creating_attribute (): \"\"\"Create an Attribute.\"\"\" assert Attribute ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) test_creating_class () \u00a4 Create a Class. Source code in tests/test_objects.py 14 15 16 def test_creating_class (): \"\"\"Create a Class.\"\"\" assert Class ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) test_creating_function () \u00a4 Create a Function. Source code in tests/test_objects.py 24 25 26 def test_creating_function (): \"\"\"Create a Function.\"\"\" assert Function ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) test_creating_method () \u00a4 Create a Method. Source code in tests/test_objects.py 19 20 21 def test_creating_method (): \"\"\"Create a Method.\"\"\" assert Method ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) test_creating_module () \u00a4 Create a Module. Source code in tests/test_objects.py 9 10 11 def test_creating_module (): \"\"\"Create a Module.\"\"\" assert Module ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) test_do_not_add_child_if_parent_is_not_self () \u00a4 Don't add a child the parent is not the right one. Source code in tests/test_objects.py 43 44 45 46 47 48 49 def test_do_not_add_child_if_parent_is_not_self (): \"\"\"Don't add a child the parent is not the right one.\"\"\" parent = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) child = Attribute ( name = \"my_attribute\" , path = \"my.other.path.my_attribute\" , file_path = \"/my/absolute/path.py\" ) parent . add_child ( child ) assert not parent . children assert not parent . attributes test_get_root () \u00a4 Get the root object. Source code in tests/test_objects.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def test_get_root (): \"\"\"Get the root object.\"\"\" root = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"\" ) node1 = Class ( name = \"my_class1\" , path = \"my.dotted.path.my_class1\" , file_path = \"\" ) node2 = Class ( name = \"my_class2\" , path = \"my.dotted.path.my_class2\" , file_path = \"\" ) leaf = Method ( name = \"my_method\" , path = \"my.dotted.path.my_class1.my_method\" , file_path = \"\" ) root . add_children ([ node1 , node2 ]) node1 . add_child ( leaf ) assert root . root is root assert node1 . root is root assert node2 . root is root assert leaf . root is root test_has_contents () \u00a4 Check if an object has contents. Source code in tests/test_objects.py 129 130 131 132 133 134 135 136 137 138 139 140 141 def test_has_contents (): \"\"\"Check if an object has contents.\"\"\" obj = Loader () . get_object_documentation ( \"tests.fixtures.pkg1\" ) assert obj . has_contents () obj = Loader () . get_object_documentation ( \"tests.fixtures.__init__\" ) assert not obj . children assert obj . has_contents () # we specified that the root always 'has contents' obj = Loader () . get_object_documentation ( \"tests.fixtures.no_contents\" ) assert obj . children assert obj . has_contents assert not obj . children [ 0 ] . has_contents () test_has_no_contents () \u00a4 Check that an object has no contents. Source code in tests/test_objects.py 144 145 146 def test_has_no_contents (): \"\"\"Check that an object has no contents.\"\"\" pass # TODO test_no_relative_file_path_for_non_existent_package () \u00a4 Cannot find relative file path. Source code in tests/test_objects.py 83 84 85 86 def test_no_relative_file_path_for_non_existent_package (): \"\"\"Cannot find relative file path.\"\"\" obj = Object ( name = \"o\" , path = \"a.b.o\" , file_path = \"/some/non_existent/path/a/b/o.py\" ) assert not obj . relative_file_path test_no_relative_file_path_for_wrong_file_path () \u00a4 Cannot find relative file path with wrong file path. Source code in tests/test_objects.py 95 96 97 98 def test_no_relative_file_path_for_wrong_file_path (): \"\"\"Cannot find relative file path with wrong file path.\"\"\" obj = Object ( name = \"o\" , path = \"tests.fixtures.nested_class\" , file_path = \"/wrong/module/path.py\" ) assert not obj . relative_file_path test_no_relative_file_path_for_wrong_path () \u00a4 Cannot find relative file path with wrong dotted path. Source code in tests/test_objects.py 89 90 91 92 def test_no_relative_file_path_for_wrong_path (): \"\"\"Cannot find relative file path with wrong dotted path.\"\"\" obj = Object ( name = \"o\" , path = \"wrong.dotted.path\" , file_path = str ( FIXTURES_DIR / \"nested_class.py\" )) assert not obj . relative_file_path test_relative_file_path_for_leaf () \u00a4 Get the relative file path of a deep object. Source code in tests/test_objects.py 76 77 78 79 80 def test_relative_file_path_for_leaf (): \"\"\"Get the relative file path of a deep object.\"\"\" obj = Loader () . get_object_documentation ( \"tests.fixtures.pkg1\" ) leaf = obj . children [ 0 ] . children [ 0 ] . children [ 0 ] . children [ 0 ] assert leaf . relative_file_path == \"tests/fixtures/pkg1/pkg2/pkg3/pkg4/pkg5/__init__.py\" test_relative_file_path_for_root () \u00a4 Get the relative file of a shallow object. Source code in tests/test_objects.py 68 69 70 71 72 73 def test_relative_file_path_for_root (): \"\"\"Get the relative file of a shallow object.\"\"\" obj = Object ( name = \"nested_class\" , path = \"tests.fixtures.nested_class\" , file_path = str ( FIXTURES_DIR / \"nested_class.py\" ) ) assert obj . relative_file_path == \"tests/fixtures/nested_class.py\"","title":"test_objects.py"},{"location":"developers/test_suite/test_objects/#tests.test_objects","text":"Tests for [the objects module][pytkdocs.objects].","title":"tests.test_objects"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_add_child","text":"Add a child. Source code in tests/test_objects.py 34 35 36 37 38 39 40 def test_add_child (): \"\"\"Add a child.\"\"\" parent = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) child = Attribute ( name = \"my_attribute\" , path = \"my.dotted.path.my_attribute\" , file_path = \"/my/absolute/path.py\" ) parent . add_child ( child ) assert parent . children [ 0 ] is child assert parent . attributes [ 0 ] is child","title":"test_add_child()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_add_children","text":"Add multiple children at once. Source code in tests/test_objects.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def test_add_children (): \"\"\"Add multiple children at once.\"\"\" root = Object ( name = \"o\" , path = \"o\" , file_path = \"o.py\" ) class_ = Class ( name = \"c\" , path = \"o.c\" , file_path = \"o.py\" ) attribute = Attribute ( name = \"a\" , path = \"o.c.a\" , file_path = \"o.py\" ) class_ . add_child ( attribute ) root . add_children ( [ # class has wrong path Class ( name = \"w\" , path = \"wrong.path.w\" , file_path = \"/wrong/path/w.py\" ), # class OK class_ , # not a direct child, attribute , # function OK Function ( name = \"f\" , path = \"o.f\" , file_path = \"o.py\" ), # not a direct child, not even a child of known child Method ( name = \"missing_node\" , path = \"o.mn.missing_node\" , file_path = \"o.py\" ), ] ) assert len ( root . children ) == 2 assert root . classes and root . classes [ 0 ] is class_ assert root . functions and root . functions [ 0 ] . name == \"f\"","title":"test_add_children()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_creating_attribute","text":"Create an Attribute. Source code in tests/test_objects.py 29 30 31 def test_creating_attribute (): \"\"\"Create an Attribute.\"\"\" assert Attribute ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" )","title":"test_creating_attribute()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_creating_class","text":"Create a Class. Source code in tests/test_objects.py 14 15 16 def test_creating_class (): \"\"\"Create a Class.\"\"\" assert Class ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" )","title":"test_creating_class()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_creating_function","text":"Create a Function. Source code in tests/test_objects.py 24 25 26 def test_creating_function (): \"\"\"Create a Function.\"\"\" assert Function ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" )","title":"test_creating_function()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_creating_method","text":"Create a Method. Source code in tests/test_objects.py 19 20 21 def test_creating_method (): \"\"\"Create a Method.\"\"\" assert Method ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" )","title":"test_creating_method()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_creating_module","text":"Create a Module. Source code in tests/test_objects.py 9 10 11 def test_creating_module (): \"\"\"Create a Module.\"\"\" assert Module ( name = \"my_object\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" )","title":"test_creating_module()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_do_not_add_child_if_parent_is_not_self","text":"Don't add a child the parent is not the right one. Source code in tests/test_objects.py 43 44 45 46 47 48 49 def test_do_not_add_child_if_parent_is_not_self (): \"\"\"Don't add a child the parent is not the right one.\"\"\" parent = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"/my/absolute/path.py\" ) child = Attribute ( name = \"my_attribute\" , path = \"my.other.path.my_attribute\" , file_path = \"/my/absolute/path.py\" ) parent . add_child ( child ) assert not parent . children assert not parent . attributes","title":"test_do_not_add_child_if_parent_is_not_self()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_get_root","text":"Get the root object. Source code in tests/test_objects.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def test_get_root (): \"\"\"Get the root object.\"\"\" root = Module ( name = \"my_module\" , path = \"my.dotted.path\" , file_path = \"\" ) node1 = Class ( name = \"my_class1\" , path = \"my.dotted.path.my_class1\" , file_path = \"\" ) node2 = Class ( name = \"my_class2\" , path = \"my.dotted.path.my_class2\" , file_path = \"\" ) leaf = Method ( name = \"my_method\" , path = \"my.dotted.path.my_class1.my_method\" , file_path = \"\" ) root . add_children ([ node1 , node2 ]) node1 . add_child ( leaf ) assert root . root is root assert node1 . root is root assert node2 . root is root assert leaf . root is root","title":"test_get_root()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_has_contents","text":"Check if an object has contents. Source code in tests/test_objects.py 129 130 131 132 133 134 135 136 137 138 139 140 141 def test_has_contents (): \"\"\"Check if an object has contents.\"\"\" obj = Loader () . get_object_documentation ( \"tests.fixtures.pkg1\" ) assert obj . has_contents () obj = Loader () . get_object_documentation ( \"tests.fixtures.__init__\" ) assert not obj . children assert obj . has_contents () # we specified that the root always 'has contents' obj = Loader () . get_object_documentation ( \"tests.fixtures.no_contents\" ) assert obj . children assert obj . has_contents assert not obj . children [ 0 ] . has_contents ()","title":"test_has_contents()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_has_no_contents","text":"Check that an object has no contents. Source code in tests/test_objects.py 144 145 146 def test_has_no_contents (): \"\"\"Check that an object has no contents.\"\"\" pass # TODO","title":"test_has_no_contents()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_no_relative_file_path_for_non_existent_package","text":"Cannot find relative file path. Source code in tests/test_objects.py 83 84 85 86 def test_no_relative_file_path_for_non_existent_package (): \"\"\"Cannot find relative file path.\"\"\" obj = Object ( name = \"o\" , path = \"a.b.o\" , file_path = \"/some/non_existent/path/a/b/o.py\" ) assert not obj . relative_file_path","title":"test_no_relative_file_path_for_non_existent_package()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_no_relative_file_path_for_wrong_file_path","text":"Cannot find relative file path with wrong file path. Source code in tests/test_objects.py 95 96 97 98 def test_no_relative_file_path_for_wrong_file_path (): \"\"\"Cannot find relative file path with wrong file path.\"\"\" obj = Object ( name = \"o\" , path = \"tests.fixtures.nested_class\" , file_path = \"/wrong/module/path.py\" ) assert not obj . relative_file_path","title":"test_no_relative_file_path_for_wrong_file_path()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_no_relative_file_path_for_wrong_path","text":"Cannot find relative file path with wrong dotted path. Source code in tests/test_objects.py 89 90 91 92 def test_no_relative_file_path_for_wrong_path (): \"\"\"Cannot find relative file path with wrong dotted path.\"\"\" obj = Object ( name = \"o\" , path = \"wrong.dotted.path\" , file_path = str ( FIXTURES_DIR / \"nested_class.py\" )) assert not obj . relative_file_path","title":"test_no_relative_file_path_for_wrong_path()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_relative_file_path_for_leaf","text":"Get the relative file path of a deep object. Source code in tests/test_objects.py 76 77 78 79 80 def test_relative_file_path_for_leaf (): \"\"\"Get the relative file path of a deep object.\"\"\" obj = Loader () . get_object_documentation ( \"tests.fixtures.pkg1\" ) leaf = obj . children [ 0 ] . children [ 0 ] . children [ 0 ] . children [ 0 ] assert leaf . relative_file_path == \"tests/fixtures/pkg1/pkg2/pkg3/pkg4/pkg5/__init__.py\"","title":"test_relative_file_path_for_leaf()"},{"location":"developers/test_suite/test_objects/#tests.test_objects.test_relative_file_path_for_root","text":"Get the relative file of a shallow object. Source code in tests/test_objects.py 68 69 70 71 72 73 def test_relative_file_path_for_root (): \"\"\"Get the relative file of a shallow object.\"\"\" obj = Object ( name = \"nested_class\" , path = \"tests.fixtures.nested_class\" , file_path = str ( FIXTURES_DIR / \"nested_class.py\" ) ) assert obj . relative_file_path == \"tests/fixtures/nested_class.py\"","title":"test_relative_file_path_for_root()"},{"location":"developers/test_suite/test_properties/","text":"\u00a4 Tests for [the properties module][pytkdocs.properties]. test_name_properties_on_attribute () \u00a4 Check attribute name properties. Source code in tests/test_properties.py 38 39 40 41 42 43 def test_name_properties_on_attribute (): \"\"\"Check attribute name properties.\"\"\" assert not Attribute ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Attribute ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert \"class-private\" in Attribute ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert \"special\" in Attribute ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties test_name_properties_on_class () \u00a4 Check class name properties. Source code in tests/test_properties.py 14 15 16 17 18 19 def test_name_properties_on_class (): \"\"\"Check class name properties.\"\"\" assert not Class ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Class ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert not Class ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert not Class ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties test_name_properties_on_function () \u00a4 Check function name properties. Source code in tests/test_properties.py 30 31 32 33 34 35 def test_name_properties_on_function (): \"\"\"Check function name properties.\"\"\" assert not Function ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Function ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert not Function ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert not Function ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties test_name_properties_on_method () \u00a4 Check method name properties. Source code in tests/test_properties.py 22 23 24 25 26 27 def test_name_properties_on_method (): \"\"\"Check method name properties.\"\"\" assert not Method ( name = \"c\" , path = \"a.b.c\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Method ( name = \"_c\" , path = \"a.b._c\" , file_path = \"a.py\" ) . name_properties assert not Method ( name = \"__c\" , path = \"a.b.__c\" , file_path = \"a.py\" ) . name_properties assert \"special\" in Method ( name = \"__c__\" , path = \"a.b.__c__\" , file_path = \"a.py\" ) . name_properties test_name_properties_on_module () \u00a4 Check module name properties. Source code in tests/test_properties.py 6 7 8 9 10 11 def test_name_properties_on_module (): \"\"\"Check module name properties.\"\"\" assert not Module ( name = \"a\" , path = \"a\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Module ( name = \"_a\" , path = \"a\" , file_path = \"_a.py\" ) . name_properties assert not Module ( name = \"__a\" , path = \"__a\" , file_path = \"__a.py\" ) . name_properties assert \"special\" in Module ( name = \"__a__\" , path = \"a\" , file_path = \"__a__.py\" ) . name_properties","title":"test_properties.py"},{"location":"developers/test_suite/test_properties/#tests.test_properties","text":"Tests for [the properties module][pytkdocs.properties].","title":"tests.test_properties"},{"location":"developers/test_suite/test_properties/#tests.test_properties.test_name_properties_on_attribute","text":"Check attribute name properties. Source code in tests/test_properties.py 38 39 40 41 42 43 def test_name_properties_on_attribute (): \"\"\"Check attribute name properties.\"\"\" assert not Attribute ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Attribute ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert \"class-private\" in Attribute ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert \"special\" in Attribute ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties","title":"test_name_properties_on_attribute()"},{"location":"developers/test_suite/test_properties/#tests.test_properties.test_name_properties_on_class","text":"Check class name properties. Source code in tests/test_properties.py 14 15 16 17 18 19 def test_name_properties_on_class (): \"\"\"Check class name properties.\"\"\" assert not Class ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Class ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert not Class ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert not Class ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties","title":"test_name_properties_on_class()"},{"location":"developers/test_suite/test_properties/#tests.test_properties.test_name_properties_on_function","text":"Check function name properties. Source code in tests/test_properties.py 30 31 32 33 34 35 def test_name_properties_on_function (): \"\"\"Check function name properties.\"\"\" assert not Function ( name = \"b\" , path = \"a.b\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Function ( name = \"_b\" , path = \"a._b\" , file_path = \"a.py\" ) . name_properties assert not Function ( name = \"__b\" , path = \"a.__b\" , file_path = \"a.py\" ) . name_properties assert not Function ( name = \"__b__\" , path = \"a.__b__\" , file_path = \"a.py\" ) . name_properties","title":"test_name_properties_on_function()"},{"location":"developers/test_suite/test_properties/#tests.test_properties.test_name_properties_on_method","text":"Check method name properties. Source code in tests/test_properties.py 22 23 24 25 26 27 def test_name_properties_on_method (): \"\"\"Check method name properties.\"\"\" assert not Method ( name = \"c\" , path = \"a.b.c\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Method ( name = \"_c\" , path = \"a.b._c\" , file_path = \"a.py\" ) . name_properties assert not Method ( name = \"__c\" , path = \"a.b.__c\" , file_path = \"a.py\" ) . name_properties assert \"special\" in Method ( name = \"__c__\" , path = \"a.b.__c__\" , file_path = \"a.py\" ) . name_properties","title":"test_name_properties_on_method()"},{"location":"developers/test_suite/test_properties/#tests.test_properties.test_name_properties_on_module","text":"Check module name properties. Source code in tests/test_properties.py 6 7 8 9 10 11 def test_name_properties_on_module (): \"\"\"Check module name properties.\"\"\" assert not Module ( name = \"a\" , path = \"a\" , file_path = \"a.py\" ) . name_properties assert \"private\" in Module ( name = \"_a\" , path = \"a\" , file_path = \"_a.py\" ) . name_properties assert not Module ( name = \"__a\" , path = \"__a\" , file_path = \"__a.py\" ) . name_properties assert \"special\" in Module ( name = \"__a__\" , path = \"a\" , file_path = \"__a__.py\" ) . name_properties","title":"test_name_properties_on_module()"},{"location":"developers/test_suite/test_serializer/","text":"\u00a4 Tests for [the serializer module][pytkdocs.serializer].","title":"test_serializer.py"},{"location":"developers/test_suite/test_serializer/#tests.test_serializer","text":"Tests for [the serializer module][pytkdocs.serializer].","title":"tests.test_serializer"},{"location":"developers/test_suite/fixtures/inheriting_enum_Enum/","text":"\u00a4 While recursing on a class inheriting from enum.Enum , the class' __dict__ returns private items whose values are the object builtin for example. The object builtin is a class, so pytkdocs is trying to recurse on it, and tries to get its file path by first getting its module. The object class' module is builtins , which does not have a __file__ attribute, so trying to access it generates an AttributeError error. Instead of failing, we simply catch the error and set file_path = \"\" . References: Test case: [tests.test_loader.test_inheriting_enum_Enum][]. Issue reported on commit 5053f81 . Fixed by commit 48df6bc . See other \"inheriting\" test cases.","title":"inheriting_enum_Enum.py"},{"location":"developers/test_suite/fixtures/inheriting_enum_Enum/#tests.fixtures.inheriting_enum_Enum","text":"While recursing on a class inheriting from enum.Enum , the class' __dict__ returns private items whose values are the object builtin for example. The object builtin is a class, so pytkdocs is trying to recurse on it, and tries to get its file path by first getting its module. The object class' module is builtins , which does not have a __file__ attribute, so trying to access it generates an AttributeError error. Instead of failing, we simply catch the error and set file_path = \"\" . References: Test case: [tests.test_loader.test_inheriting_enum_Enum][]. Issue reported on commit 5053f81 . Fixed by commit 48df6bc . See other \"inheriting\" test cases.","title":"tests.fixtures.inheriting_enum_Enum"},{"location":"developers/test_suite/fixtures/inheriting_typing_NamedTuple/","text":"\u00a4 While recursing on a class inheriting from typing.NamedTuple , the class' __dict__ returns items that are identified as properties. When trying to get the signature of these properties' fget methods, inspect raises a ValueError: callable operator.itemgetter(0) is not supported by signature error. Instead of failing, we simply set the signature to None . References: Test case: [tests.test_loader.test_inheriting_typing_NamedTuple][]. Issue reported at pawamoy/pytkdocs#15 . Fixed by commit 67cee40 . See other \"inheriting\" test cases.","title":"inheriting_typing_NamedTuple.py"},{"location":"developers/test_suite/fixtures/inheriting_typing_NamedTuple/#tests.fixtures.inheriting_typing_NamedTuple","text":"While recursing on a class inheriting from typing.NamedTuple , the class' __dict__ returns items that are identified as properties. When trying to get the signature of these properties' fget methods, inspect raises a ValueError: callable operator.itemgetter(0) is not supported by signature error. Instead of failing, we simply set the signature to None . References: Test case: [tests.test_loader.test_inheriting_typing_NamedTuple][]. Issue reported at pawamoy/pytkdocs#15 . Fixed by commit 67cee40 . See other \"inheriting\" test cases.","title":"tests.fixtures.inheriting_typing_NamedTuple"},{"location":"developers/test_suite/fixtures/nested_class/","text":"\u00a4","title":"nested_class.py"},{"location":"developers/test_suite/fixtures/nested_class/#tests.fixtures.nested_class","text":"","title":"tests.fixtures.nested_class"},{"location":"developers/test_suite/fixtures/no_contents/","text":"\u00a4","title":"no_contents"},{"location":"developers/test_suite/fixtures/no_contents/#tests.fixtures.no_contents","text":"","title":"tests.fixtures.no_contents"},{"location":"developers/test_suite/fixtures/parsing/","text":"\u00a4","title":"parsing"},{"location":"developers/test_suite/fixtures/parsing/#tests.fixtures.parsing","text":"","title":"tests.fixtures.parsing"},{"location":"developers/test_suite/fixtures/pkg1/","text":"\u00a4","title":"pkg1"},{"location":"developers/test_suite/fixtures/pkg1/#tests.fixtures.pkg1","text":"","title":"tests.fixtures.pkg1"},{"location":"developers/test_suite/fixtures/real_path/","text":"\u00a4","title":"real_path"},{"location":"developers/test_suite/fixtures/real_path/#tests.fixtures.real_path","text":"","title":"tests.fixtures.real_path"},{"location":"developers/test_suite/fixtures/the_package/","text":"\u00a4 The package docstring.","title":"the_package"},{"location":"developers/test_suite/fixtures/the_package/#tests.fixtures.the_package","text":"The package docstring.","title":"tests.fixtures.the_package"},{"location":"developers/test_suite/test_parsers/test_attributes/","text":"\u00a4 Tests for [the parsers.attributes module][pytkdocs.parsers.attributes]. TestAttributeParser \u00a4 Test the attributes parser. setup ( self ) \u00a4 Setup reusable attributes. Source code in tests/test_parsers/test_attributes.py 11 12 13 def setup ( self ): \"\"\"Setup reusable attributes.\"\"\" self . attributes = { a . name : a for a in get_attributes ( attr_module )} test_do_not_pick_up_attribute_without_docstring ( self ) \u00a4 Don't pick attributes without docstrings. Source code in tests/test_parsers/test_attributes.py 15 16 17 18 19 def test_do_not_pick_up_attribute_without_docstring ( self ): \"\"\"Don't pick attributes without docstrings.\"\"\" assert \"NO_DOC_NO_TYPE\" not in self . attributes assert \"NO_DOC_NO_VALUE\" not in self . attributes assert \"NO_DOC\" not in self . attributes test_do_not_pick_up_variable_in_function ( self ) \u00a4 Don't pick documented variables in functions. Source code in tests/test_parsers/test_attributes.py 21 22 23 def test_do_not_pick_up_variable_in_function ( self ): \"\"\"Don't pick documented variables in functions.\"\"\" assert \"IN_FUNCTION\" not in self . attributes test_pick_up_attribute_in_class ( self ) \u00a4 Pick up class attribute. Source code in tests/test_parsers/test_attributes.py 45 46 47 48 def test_pick_up_attribute_in_class ( self ): \"\"\"Pick up class attribute.\"\"\" assert \"IN_CLASS\" in self . attributes assert self . attributes [ \"IN_CLASS\" ] . docstring == \"In class.\" test_pick_up_attribute_in_if ( self ) \u00a4 Pick attribute in if and else . Source code in tests/test_parsers/test_attributes.py 55 56 57 58 59 60 61 def test_pick_up_attribute_in_if ( self ): \"\"\"Pick attribute in `if` and `else`.\"\"\" assert \"IN_IF\" in self . attributes assert self . attributes [ \"IN_IF\" ] . docstring == \"In if.\" assert \"IN_ELSE\" in self . attributes assert self . attributes [ \"IN_ELSE\" ] . docstring == \"In else.\" test_pick_up_attribute_in_init_method ( self ) \u00a4 Pick up instance attribute. Source code in tests/test_parsers/test_attributes.py 50 51 52 53 def test_pick_up_attribute_in_init_method ( self ): \"\"\"Pick up instance attribute.\"\"\" assert \"in_init\" in self . attributes assert self . attributes [ \"in_init\" ] . docstring == \"In init.\" test_pick_up_attribute_in_pydantic_model ( self ) \u00a4 Pick up attribute in Pydantic model. Source code in tests/test_parsers/test_attributes.py 77 78 79 80 81 82 83 def test_pick_up_attribute_in_pydantic_model ( self ): \"\"\"Pick up attribute in Pydantic model.\"\"\" assert \"in_pydantic_model\" in self . attributes assert self . attributes [ \"in_pydantic_model\" ] . docstring == \"In Pydantic model.\" assert \"model_field\" in self . attributes assert self . attributes [ \"model_field\" ] . docstring == \"A model field.\" test_pick_up_attribute_in_try_except ( self ) \u00a4 Pick attribute in try , except , else and finally .. Source code in tests/test_parsers/test_attributes.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def test_pick_up_attribute_in_try_except ( self ): \"\"\"Pick attribute in `try`, `except`, `else` and `finally`..\"\"\" assert \"IN_TRY\" in self . attributes assert self . attributes [ \"IN_TRY\" ] . docstring == \"In try.\" assert \"IN_EXCEPT\" in self . attributes assert self . attributes [ \"IN_EXCEPT\" ] . docstring == \"In except.\" assert \"IN_TRY_ELSE\" in self . attributes assert self . attributes [ \"IN_TRY_ELSE\" ] . docstring == \"In try else.\" assert \"IN_FINALLY\" in self . attributes assert self . attributes [ \"IN_FINALLY\" ] . docstring == \"In finally.\" test_pick_up_attribute_with_complex_type ( self ) \u00a4 Pick up attribute with complex type. Source code in tests/test_parsers/test_attributes.py 40 41 42 43 def test_pick_up_attribute_with_complex_type ( self ): \"\"\"Pick up attribute with complex type.\"\"\" assert \"COMPLEX_TYPE\" in self . attributes assert self . attributes [ \"COMPLEX_TYPE\" ] . docstring == \"Complex type.\" test_pick_up_attribute_with_type_and_value ( self ) \u00a4 Pick up attribute with type and value. Source code in tests/test_parsers/test_attributes.py 35 36 37 38 def test_pick_up_attribute_with_type_and_value ( self ): \"\"\"Pick up attribute with type and value.\"\"\" assert \"FULL\" in self . attributes assert self . attributes [ \"FULL\" ] . docstring == \"Full.\" test_pick_up_attribute_without_type ( self ) \u00a4 Pick up attribute without a type. Source code in tests/test_parsers/test_attributes.py 25 26 27 28 def test_pick_up_attribute_without_type ( self ): \"\"\"Pick up attribute without a type.\"\"\" assert \"NO_TYPE\" in self . attributes assert self . attributes [ \"NO_TYPE\" ] . docstring == \"No type.\" test_pick_up_attribute_without_value ( self ) \u00a4 Pick up attribute without a value. Source code in tests/test_parsers/test_attributes.py 30 31 32 33 def test_pick_up_attribute_without_value ( self ): \"\"\"Pick up attribute without a value.\"\"\" assert \"NO_VALUE\" in self . attributes assert self . attributes [ \"NO_VALUE\" ] . docstring == \"No value.\"","title":"test_attributes.py"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes","text":"Tests for [the parsers.attributes module][pytkdocs.parsers.attributes].","title":"tests.test_parsers.test_attributes"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser","text":"Test the attributes parser.","title":"TestAttributeParser"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.setup","text":"Setup reusable attributes. Source code in tests/test_parsers/test_attributes.py 11 12 13 def setup ( self ): \"\"\"Setup reusable attributes.\"\"\" self . attributes = { a . name : a for a in get_attributes ( attr_module )}","title":"setup()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_do_not_pick_up_attribute_without_docstring","text":"Don't pick attributes without docstrings. Source code in tests/test_parsers/test_attributes.py 15 16 17 18 19 def test_do_not_pick_up_attribute_without_docstring ( self ): \"\"\"Don't pick attributes without docstrings.\"\"\" assert \"NO_DOC_NO_TYPE\" not in self . attributes assert \"NO_DOC_NO_VALUE\" not in self . attributes assert \"NO_DOC\" not in self . attributes","title":"test_do_not_pick_up_attribute_without_docstring()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_do_not_pick_up_variable_in_function","text":"Don't pick documented variables in functions. Source code in tests/test_parsers/test_attributes.py 21 22 23 def test_do_not_pick_up_variable_in_function ( self ): \"\"\"Don't pick documented variables in functions.\"\"\" assert \"IN_FUNCTION\" not in self . attributes","title":"test_do_not_pick_up_variable_in_function()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_in_class","text":"Pick up class attribute. Source code in tests/test_parsers/test_attributes.py 45 46 47 48 def test_pick_up_attribute_in_class ( self ): \"\"\"Pick up class attribute.\"\"\" assert \"IN_CLASS\" in self . attributes assert self . attributes [ \"IN_CLASS\" ] . docstring == \"In class.\"","title":"test_pick_up_attribute_in_class()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_in_if","text":"Pick attribute in if and else . Source code in tests/test_parsers/test_attributes.py 55 56 57 58 59 60 61 def test_pick_up_attribute_in_if ( self ): \"\"\"Pick attribute in `if` and `else`.\"\"\" assert \"IN_IF\" in self . attributes assert self . attributes [ \"IN_IF\" ] . docstring == \"In if.\" assert \"IN_ELSE\" in self . attributes assert self . attributes [ \"IN_ELSE\" ] . docstring == \"In else.\"","title":"test_pick_up_attribute_in_if()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_in_init_method","text":"Pick up instance attribute. Source code in tests/test_parsers/test_attributes.py 50 51 52 53 def test_pick_up_attribute_in_init_method ( self ): \"\"\"Pick up instance attribute.\"\"\" assert \"in_init\" in self . attributes assert self . attributes [ \"in_init\" ] . docstring == \"In init.\"","title":"test_pick_up_attribute_in_init_method()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_in_pydantic_model","text":"Pick up attribute in Pydantic model. Source code in tests/test_parsers/test_attributes.py 77 78 79 80 81 82 83 def test_pick_up_attribute_in_pydantic_model ( self ): \"\"\"Pick up attribute in Pydantic model.\"\"\" assert \"in_pydantic_model\" in self . attributes assert self . attributes [ \"in_pydantic_model\" ] . docstring == \"In Pydantic model.\" assert \"model_field\" in self . attributes assert self . attributes [ \"model_field\" ] . docstring == \"A model field.\"","title":"test_pick_up_attribute_in_pydantic_model()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_in_try_except","text":"Pick attribute in try , except , else and finally .. Source code in tests/test_parsers/test_attributes.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def test_pick_up_attribute_in_try_except ( self ): \"\"\"Pick attribute in `try`, `except`, `else` and `finally`..\"\"\" assert \"IN_TRY\" in self . attributes assert self . attributes [ \"IN_TRY\" ] . docstring == \"In try.\" assert \"IN_EXCEPT\" in self . attributes assert self . attributes [ \"IN_EXCEPT\" ] . docstring == \"In except.\" assert \"IN_TRY_ELSE\" in self . attributes assert self . attributes [ \"IN_TRY_ELSE\" ] . docstring == \"In try else.\" assert \"IN_FINALLY\" in self . attributes assert self . attributes [ \"IN_FINALLY\" ] . docstring == \"In finally.\"","title":"test_pick_up_attribute_in_try_except()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_with_complex_type","text":"Pick up attribute with complex type. Source code in tests/test_parsers/test_attributes.py 40 41 42 43 def test_pick_up_attribute_with_complex_type ( self ): \"\"\"Pick up attribute with complex type.\"\"\" assert \"COMPLEX_TYPE\" in self . attributes assert self . attributes [ \"COMPLEX_TYPE\" ] . docstring == \"Complex type.\"","title":"test_pick_up_attribute_with_complex_type()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_with_type_and_value","text":"Pick up attribute with type and value. Source code in tests/test_parsers/test_attributes.py 35 36 37 38 def test_pick_up_attribute_with_type_and_value ( self ): \"\"\"Pick up attribute with type and value.\"\"\" assert \"FULL\" in self . attributes assert self . attributes [ \"FULL\" ] . docstring == \"Full.\"","title":"test_pick_up_attribute_with_type_and_value()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_without_type","text":"Pick up attribute without a type. Source code in tests/test_parsers/test_attributes.py 25 26 27 28 def test_pick_up_attribute_without_type ( self ): \"\"\"Pick up attribute without a type.\"\"\" assert \"NO_TYPE\" in self . attributes assert self . attributes [ \"NO_TYPE\" ] . docstring == \"No type.\"","title":"test_pick_up_attribute_without_type()"},{"location":"developers/test_suite/test_parsers/test_attributes/#tests.test_parsers.test_attributes.TestAttributeParser.test_pick_up_attribute_without_value","text":"Pick up attribute without a value. Source code in tests/test_parsers/test_attributes.py 30 31 32 33 def test_pick_up_attribute_without_value ( self ): \"\"\"Pick up attribute without a value.\"\"\" assert \"NO_VALUE\" in self . attributes assert self . attributes [ \"NO_VALUE\" ] . docstring == \"No value.\"","title":"test_pick_up_attribute_without_value()"},{"location":"developers/test_suite/test_parsers/test_docstrings/","text":"\u00a4 Test the docstrings parsers. test_google \u00a4 Tests for [the parsers.docstrings module][pytkdocs.parsers.docstrings]. parse ( docstring , signature = None , return_type , admonitions = True ) \u00a4 Helper to parse a doctring. Source code in tests/test_parsers/test_docstrings/test_google.py 10 11 12 def parse ( docstring , signature = None , return_type = inspect . Signature . empty , admonitions = True ): \"\"\"Helper to parse a doctring.\"\"\" return Google ( replace_admonitions = admonitions ) . parse ( dedent ( docstring ) . strip (), \"o\" , signature , return_type ) test_admonitions () \u00a4 Parse admonitions. Source code in tests/test_parsers/test_docstrings/test_google.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def test_admonitions (): \"\"\"Parse admonitions.\"\"\" def f (): \"\"\" Note: Hello. Note: With title. Hello again. Something: Something. \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors test_close_sections () \u00a4 Parse sections without blank lines in between. Source code in tests/test_parsers/test_docstrings/test_google.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def test_close_sections (): \"\"\"Parse sections without blank lines in between.\"\"\" def f ( x , y , z ): \"\"\" Parameters: x: X. Parameters: y: Y. Parameters: z: Z. Exceptions: Error2: error. Exceptions: Error1: error. Returns: 1. Returns: 2. \"\"\" return x + y + z sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 7 assert len ( errors ) == 2 # no return type annotations test_code_blocks () \u00a4 Parse code blocks. Source code in tests/test_parsers/test_docstrings/test_google.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def test_code_blocks (): \"\"\"Parse code blocks.\"\"\" def f ( s ): # noqa: D300,D301 (escape sequences) \"\"\" This docstring contains a docstring in a code block o_O! ```python \\\"\\\"\\\" This docstring is contained in another docstring O_o! Parameters: s: A string. \\\"\\\"\\\" ``` \"\"\" return s sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors test_different_indentation () \u00a4 Parse different indentations, warn on confusing indentation. Source code in tests/test_parsers/test_docstrings/test_google.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def test_different_indentation (): \"\"\"Parse different indentations, warn on confusing indentation.\"\"\" def f (): \"\"\" Hello. Raises: StartAt5: this section's items starts with 5 spaces of indentation. Well indented continuation line. Badly indented continuation line (will trigger an error). Empty lines are preserved, as well as extra-indentation (this line is a code block). AnyOtherLine: ...starting with exactly 5 spaces is a new item. AnyLine: ...indented with less than 5 spaces signifies the end of the section. \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert len ( sections [ 1 ] . value ) == 2 assert sections [ 1 ] . value [ 0 ] . description == ( \"this section's items starts with 5 spaces of indentation. \\n \" \"Well indented continuation line. \\n \" \"Badly indented continuation line (will trigger an error). \\n \" \" \\n \" \" Empty lines are preserved, as well as extra-indentation (this line is a code block).\" ) assert sections [ 2 ] . value == \" AnyLine: ...indented with less than 5 spaces signifies the end of the section.\" assert len ( errors ) == 1 assert \"should be 5 * 2 = 10 spaces, not 6\" in errors [ 0 ] test_extra_parameter () \u00a4 Warn on extra parameter in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def test_extra_parameter (): \"\"\"Warn on extra parameter in docstring.\"\"\" def f ( x ): \"\"\" Parameters: x: Integer. y: Integer. \"\"\" return x sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert len ( errors ) == 1 assert \"No type\" in errors [ 0 ] test_function_with_annotations () \u00a4 Parse a function docstring with signature annotations. Source code in tests/test_parsers/test_docstrings/test_google.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def test_function_with_annotations (): \"\"\"Parse a function docstring with signature annotations.\"\"\" def f ( x : int , y : int ) -> int : \"\"\" This function has annotations. Parameters: x: X value. y: Y value. Returns: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors test_function_without_annotations () \u00a4 Parse a function docstring without signature annotations. Source code in tests/test_parsers/test_docstrings/test_google.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def test_function_without_annotations (): \"\"\"Parse a function docstring without signature annotations.\"\"\" def f ( x , y ): \"\"\" This function has no annotations. Parameters: x: X value. y: Y value. Returns: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert len ( errors ) == 1 assert \"No type in return\" in errors [ 0 ] test_indented_code_block () \u00a4 Parse indented code blocks. Source code in tests/test_parsers/test_docstrings/test_google.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def test_indented_code_block (): \"\"\"Parse indented code blocks.\"\"\" def f ( s ): # noqa: D300,D301 (escape sequences) \"\"\" This docstring contains a docstring in a code block o_O! \\\"\\\"\\\" This docstring is contained in another docstring O_o! Parameters: s: A string. \\\"\\\"\\\" \"\"\" return s sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors test_invalid_sections () \u00a4 Warn on invalid (empty) sections. Source code in tests/test_parsers/test_docstrings/test_google.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def test_invalid_sections (): \"\"\"Warn on invalid (empty) sections.\"\"\" def f (): \"\"\" Parameters: Exceptions: Exceptions: Returns: Note: Important: \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 for error in errors [: 3 ]: assert \"Empty\" in error assert \"No return type\" in errors [ 3 ] assert \"Empty\" in errors [ - 1 ] test_missing_parameter () \u00a4 Don't warn on missing parameter in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 298 299 300 301 302 303 304 305 306 307 308 309 310 def test_missing_parameter (): \"\"\"Don't warn on missing parameter in docstring.\"\"\" # FIXME: could warn def f ( x , y ): \"\"\" Parameters: x: Integer. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors test_multi_line_docstring () \u00a4 Parse a multi-line docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 22 23 24 25 26 27 28 29 30 31 32 def test_multi_line_docstring (): \"\"\"Parse a multi-line docstring.\"\"\" sections , errors = parse ( \"\"\" A somewhat longer docstring. Blablablabla. \"\"\" ) assert len ( sections ) == 1 assert not errors test_multiple_lines_in_sections_items () \u00a4 Parse multi-line item description. Source code in tests/test_parsers/test_docstrings/test_google.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def test_multiple_lines_in_sections_items (): \"\"\"Parse multi-line item description.\"\"\" def f ( p : str , q : str ): \"\"\" Hi. Arguments: p: This argument has a description spawning on multiple lines. It even has blank lines in it. Some of these lines are indented for no reason. q: What if the first line is blank? \"\"\" return p + q sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 2 assert len ( sections [ 1 ] . value ) == 2 assert errors for error in errors : assert \"should be 4 * 2 = 8 spaces, not\" in error test_param_line_without_colon () \u00a4 Warn when missing colon. Source code in tests/test_parsers/test_docstrings/test_google.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def test_param_line_without_colon (): \"\"\"Warn when missing colon.\"\"\" def f ( x : int ): \"\"\" Parameters: x is an integer. \"\"\" return x sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert not sections # getting x fails, so the section is empty and discarded assert len ( errors ) == 2 assert \"pair\" in errors [ 0 ] assert \"Empty\" in errors [ 1 ] test_parse_args_kwargs () \u00a4 Parse args and kwargs. Source code in tests/test_parsers/test_docstrings/test_google.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def test_parse_args_kwargs (): \"\"\"Parse args and kwargs.\"\"\" def f ( a , * args , ** kwargs ): \"\"\" Arguments: a: a parameter. *args: args parameters. **kwargs: kwargs parameters. \"\"\" return 1 sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 expected_parameters = { \"a\" : \"a parameter.\" , \"*args\" : \"args parameters.\" , \"**kwargs\" : \"kwargs parameters.\" } for param in sections [ 0 ] . value : assert param . name in expected_parameters assert expected_parameters [ param . name ] == param . description assert not errors test_property_docstring () \u00a4 Parse a property docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 62 63 64 65 66 67 68 def test_property_docstring (): \"\"\"Parse a property docstring.\"\"\" class_ = Loader () . get_object_documentation ( \"tests.fixtures.parsing.docstrings.NotDefinedYet\" ) prop = class_ . attributes [ 0 ] sections , errors = prop . docstring_sections , prop . docstring_errors assert len ( sections ) == 2 assert not errors test_sections_without_signature () \u00a4 Parse a docstring without a signature. Source code in tests/test_parsers/test_docstrings/test_google.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def test_sections_without_signature (): \"\"\"Parse a docstring without a signature.\"\"\" sections , errors = parse ( \"\"\" Sections without signature. Parameters: void: SEGFAULT. niet: SEGFAULT. nada: SEGFAULT. rien: SEGFAULT. Exceptions: GlobalError: when nothing works as expected. Returns: Itself. \"\"\" ) assert len ( sections ) == 4 assert len ( errors ) == 5 # missing annotations for params and return for error in errors [: - 1 ]: assert \"param\" in error assert \"return\" in errors [ - 1 ] test_simple_docstring () \u00a4 Parse a simple docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 15 16 17 18 19 def test_simple_docstring (): \"\"\"Parse a simple docstring.\"\"\" sections , errors = parse ( \"A simple docstring.\" ) assert len ( sections ) == 1 assert not errors test_types_and_optional_in_docstring () \u00a4 Parse optional types in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def test_types_and_optional_in_docstring (): \"\"\"Parse optional types in docstring.\"\"\" def f ( x = 1 , y = None ): \"\"\" The types are written in the docstring. Parameters: x (int): X value. y (int, optional): Y value. Returns: int: Sum X + Y. \"\"\" return x + ( y or 1 ) sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors x , y = sections [ 1 ] . value assert x . name == \"x\" assert x . annotation == \"int\" assert x . description == \"X value.\" assert x . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert x . default == 1 assert y . name == \"y\" assert y . annotation == \"int\" assert y . description == \"Y value.\" assert y . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert y . default is None test_types_in_docstring () \u00a4 Parse types in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def test_types_in_docstring (): \"\"\"Parse types in docstring.\"\"\" def f ( x , y ): \"\"\" The types are written in the docstring. Parameters: x (int): X value. y (int): Y value. Returns: int: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors x , y = sections [ 1 ] . value r = sections [ 2 ] . value assert x . name == \"x\" assert x . annotation == \"int\" assert x . description == \"X value.\" assert x . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert x . default is inspect . Signature . empty assert y . name == \"y\" assert y . annotation == \"int\" assert y . description == \"Y value.\" assert y . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert y . default is inspect . Signature . empty assert r . annotation == \"int\" assert r . description == \"Sum X + Y.\" test_types_in_signature_and_docstring () \u00a4 Parse types in both signature and docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def test_types_in_signature_and_docstring (): \"\"\"Parse types in both signature and docstring.\"\"\" def f ( x : int , y : int ) -> int : \"\"\" The types are written both in the signature and in the docstring. Parameters: x (int): X value. y (int): Y value. Returns: int: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors","title":"test_docstrings.py"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings","text":"Test the docstrings parsers.","title":"tests.test_parsers.test_docstrings"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google","text":"Tests for [the parsers.docstrings module][pytkdocs.parsers.docstrings].","title":"test_google"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.parse","text":"Helper to parse a doctring. Source code in tests/test_parsers/test_docstrings/test_google.py 10 11 12 def parse ( docstring , signature = None , return_type = inspect . Signature . empty , admonitions = True ): \"\"\"Helper to parse a doctring.\"\"\" return Google ( replace_admonitions = admonitions ) . parse ( dedent ( docstring ) . strip (), \"o\" , signature , return_type )","title":"parse()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_admonitions","text":"Parse admonitions. Source code in tests/test_parsers/test_docstrings/test_google.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def test_admonitions (): \"\"\"Parse admonitions.\"\"\" def f (): \"\"\" Note: Hello. Note: With title. Hello again. Something: Something. \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors","title":"test_admonitions()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_close_sections","text":"Parse sections without blank lines in between. Source code in tests/test_parsers/test_docstrings/test_google.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def test_close_sections (): \"\"\"Parse sections without blank lines in between.\"\"\" def f ( x , y , z ): \"\"\" Parameters: x: X. Parameters: y: Y. Parameters: z: Z. Exceptions: Error2: error. Exceptions: Error1: error. Returns: 1. Returns: 2. \"\"\" return x + y + z sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 7 assert len ( errors ) == 2 # no return type annotations","title":"test_close_sections()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_code_blocks","text":"Parse code blocks. Source code in tests/test_parsers/test_docstrings/test_google.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def test_code_blocks (): \"\"\"Parse code blocks.\"\"\" def f ( s ): # noqa: D300,D301 (escape sequences) \"\"\" This docstring contains a docstring in a code block o_O! ```python \\\"\\\"\\\" This docstring is contained in another docstring O_o! Parameters: s: A string. \\\"\\\"\\\" ``` \"\"\" return s sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors","title":"test_code_blocks()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_different_indentation","text":"Parse different indentations, warn on confusing indentation. Source code in tests/test_parsers/test_docstrings/test_google.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def test_different_indentation (): \"\"\"Parse different indentations, warn on confusing indentation.\"\"\" def f (): \"\"\" Hello. Raises: StartAt5: this section's items starts with 5 spaces of indentation. Well indented continuation line. Badly indented continuation line (will trigger an error). Empty lines are preserved, as well as extra-indentation (this line is a code block). AnyOtherLine: ...starting with exactly 5 spaces is a new item. AnyLine: ...indented with less than 5 spaces signifies the end of the section. \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert len ( sections [ 1 ] . value ) == 2 assert sections [ 1 ] . value [ 0 ] . description == ( \"this section's items starts with 5 spaces of indentation. \\n \" \"Well indented continuation line. \\n \" \"Badly indented continuation line (will trigger an error). \\n \" \" \\n \" \" Empty lines are preserved, as well as extra-indentation (this line is a code block).\" ) assert sections [ 2 ] . value == \" AnyLine: ...indented with less than 5 spaces signifies the end of the section.\" assert len ( errors ) == 1 assert \"should be 5 * 2 = 10 spaces, not 6\" in errors [ 0 ]","title":"test_different_indentation()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_extra_parameter","text":"Warn on extra parameter in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def test_extra_parameter (): \"\"\"Warn on extra parameter in docstring.\"\"\" def f ( x ): \"\"\" Parameters: x: Integer. y: Integer. \"\"\" return x sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert len ( errors ) == 1 assert \"No type\" in errors [ 0 ]","title":"test_extra_parameter()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_function_with_annotations","text":"Parse a function docstring with signature annotations. Source code in tests/test_parsers/test_docstrings/test_google.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def test_function_with_annotations (): \"\"\"Parse a function docstring with signature annotations.\"\"\" def f ( x : int , y : int ) -> int : \"\"\" This function has annotations. Parameters: x: X value. y: Y value. Returns: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors","title":"test_function_with_annotations()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_function_without_annotations","text":"Parse a function docstring without signature annotations. Source code in tests/test_parsers/test_docstrings/test_google.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def test_function_without_annotations (): \"\"\"Parse a function docstring without signature annotations.\"\"\" def f ( x , y ): \"\"\" This function has no annotations. Parameters: x: X value. y: Y value. Returns: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert len ( errors ) == 1 assert \"No type in return\" in errors [ 0 ]","title":"test_function_without_annotations()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_indented_code_block","text":"Parse indented code blocks. Source code in tests/test_parsers/test_docstrings/test_google.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def test_indented_code_block (): \"\"\"Parse indented code blocks.\"\"\" def f ( s ): # noqa: D300,D301 (escape sequences) \"\"\" This docstring contains a docstring in a code block o_O! \\\"\\\"\\\" This docstring is contained in another docstring O_o! Parameters: s: A string. \\\"\\\"\\\" \"\"\" return s sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors","title":"test_indented_code_block()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_invalid_sections","text":"Warn on invalid (empty) sections. Source code in tests/test_parsers/test_docstrings/test_google.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def test_invalid_sections (): \"\"\"Warn on invalid (empty) sections.\"\"\" def f (): \"\"\" Parameters: Exceptions: Exceptions: Returns: Note: Important: \"\"\" sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 for error in errors [: 3 ]: assert \"Empty\" in error assert \"No return type\" in errors [ 3 ] assert \"Empty\" in errors [ - 1 ]","title":"test_invalid_sections()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_missing_parameter","text":"Don't warn on missing parameter in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 298 299 300 301 302 303 304 305 306 307 308 309 310 def test_missing_parameter (): \"\"\"Don't warn on missing parameter in docstring.\"\"\" # FIXME: could warn def f ( x , y ): \"\"\" Parameters: x: Integer. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 assert not errors","title":"test_missing_parameter()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_multi_line_docstring","text":"Parse a multi-line docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 22 23 24 25 26 27 28 29 30 31 32 def test_multi_line_docstring (): \"\"\"Parse a multi-line docstring.\"\"\" sections , errors = parse ( \"\"\" A somewhat longer docstring. Blablablabla. \"\"\" ) assert len ( sections ) == 1 assert not errors","title":"test_multi_line_docstring()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_multiple_lines_in_sections_items","text":"Parse multi-line item description. Source code in tests/test_parsers/test_docstrings/test_google.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def test_multiple_lines_in_sections_items (): \"\"\"Parse multi-line item description.\"\"\" def f ( p : str , q : str ): \"\"\" Hi. Arguments: p: This argument has a description spawning on multiple lines. It even has blank lines in it. Some of these lines are indented for no reason. q: What if the first line is blank? \"\"\" return p + q sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 2 assert len ( sections [ 1 ] . value ) == 2 assert errors for error in errors : assert \"should be 4 * 2 = 8 spaces, not\" in error","title":"test_multiple_lines_in_sections_items()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_param_line_without_colon","text":"Warn when missing colon. Source code in tests/test_parsers/test_docstrings/test_google.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def test_param_line_without_colon (): \"\"\"Warn when missing colon.\"\"\" def f ( x : int ): \"\"\" Parameters: x is an integer. \"\"\" return x sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert not sections # getting x fails, so the section is empty and discarded assert len ( errors ) == 2 assert \"pair\" in errors [ 0 ] assert \"Empty\" in errors [ 1 ]","title":"test_param_line_without_colon()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_parse_args_kwargs","text":"Parse args and kwargs. Source code in tests/test_parsers/test_docstrings/test_google.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def test_parse_args_kwargs (): \"\"\"Parse args and kwargs.\"\"\" def f ( a , * args , ** kwargs ): \"\"\" Arguments: a: a parameter. *args: args parameters. **kwargs: kwargs parameters. \"\"\" return 1 sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 1 expected_parameters = { \"a\" : \"a parameter.\" , \"*args\" : \"args parameters.\" , \"**kwargs\" : \"kwargs parameters.\" } for param in sections [ 0 ] . value : assert param . name in expected_parameters assert expected_parameters [ param . name ] == param . description assert not errors","title":"test_parse_args_kwargs()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_property_docstring","text":"Parse a property docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 62 63 64 65 66 67 68 def test_property_docstring (): \"\"\"Parse a property docstring.\"\"\" class_ = Loader () . get_object_documentation ( \"tests.fixtures.parsing.docstrings.NotDefinedYet\" ) prop = class_ . attributes [ 0 ] sections , errors = prop . docstring_sections , prop . docstring_errors assert len ( sections ) == 2 assert not errors","title":"test_property_docstring()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_sections_without_signature","text":"Parse a docstring without a signature. Source code in tests/test_parsers/test_docstrings/test_google.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def test_sections_without_signature (): \"\"\"Parse a docstring without a signature.\"\"\" sections , errors = parse ( \"\"\" Sections without signature. Parameters: void: SEGFAULT. niet: SEGFAULT. nada: SEGFAULT. rien: SEGFAULT. Exceptions: GlobalError: when nothing works as expected. Returns: Itself. \"\"\" ) assert len ( sections ) == 4 assert len ( errors ) == 5 # missing annotations for params and return for error in errors [: - 1 ]: assert \"param\" in error assert \"return\" in errors [ - 1 ]","title":"test_sections_without_signature()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_simple_docstring","text":"Parse a simple docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 15 16 17 18 19 def test_simple_docstring (): \"\"\"Parse a simple docstring.\"\"\" sections , errors = parse ( \"A simple docstring.\" ) assert len ( sections ) == 1 assert not errors","title":"test_simple_docstring()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_types_and_optional_in_docstring","text":"Parse optional types in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def test_types_and_optional_in_docstring (): \"\"\"Parse optional types in docstring.\"\"\" def f ( x = 1 , y = None ): \"\"\" The types are written in the docstring. Parameters: x (int): X value. y (int, optional): Y value. Returns: int: Sum X + Y. \"\"\" return x + ( y or 1 ) sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors x , y = sections [ 1 ] . value assert x . name == \"x\" assert x . annotation == \"int\" assert x . description == \"X value.\" assert x . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert x . default == 1 assert y . name == \"y\" assert y . annotation == \"int\" assert y . description == \"Y value.\" assert y . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert y . default is None","title":"test_types_and_optional_in_docstring()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_types_in_docstring","text":"Parse types in docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def test_types_in_docstring (): \"\"\"Parse types in docstring.\"\"\" def f ( x , y ): \"\"\" The types are written in the docstring. Parameters: x (int): X value. y (int): Y value. Returns: int: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors x , y = sections [ 1 ] . value r = sections [ 2 ] . value assert x . name == \"x\" assert x . annotation == \"int\" assert x . description == \"X value.\" assert x . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert x . default is inspect . Signature . empty assert y . name == \"y\" assert y . annotation == \"int\" assert y . description == \"Y value.\" assert y . kind is inspect . Parameter . POSITIONAL_OR_KEYWORD assert y . default is inspect . Signature . empty assert r . annotation == \"int\" assert r . description == \"Sum X + Y.\"","title":"test_types_in_docstring()"},{"location":"developers/test_suite/test_parsers/test_docstrings/#tests.test_parsers.test_docstrings.test_google.test_types_in_signature_and_docstring","text":"Parse types in both signature and docstring. Source code in tests/test_parsers/test_docstrings/test_google.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def test_types_in_signature_and_docstring (): \"\"\"Parse types in both signature and docstring.\"\"\" def f ( x : int , y : int ) -> int : \"\"\" The types are written both in the signature and in the docstring. Parameters: x (int): X value. y (int): Y value. Returns: int: Sum X + Y. \"\"\" return x + y sections , errors = parse ( inspect . getdoc ( f ), inspect . signature ( f )) assert len ( sections ) == 3 assert not errors","title":"test_types_in_signature_and_docstring()"},{"location":"reference/__init__/","text":"\u00a4 pytkdocs package. Load Python objects documentation.","title":"__init__.py"},{"location":"reference/__init__/#pytkdocs.__init__","text":"pytkdocs package. Load Python objects documentation.","title":"pytkdocs.__init__"},{"location":"reference/__main__/","text":"\u00a4 Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"__main__.py"},{"location":"reference/__main__/#pytkdocs.__main__","text":"Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"pytkdocs.__main__"},{"location":"reference/cli/","text":"\u00a4 Module that contains the command line application. discarded_stdout () \u00a4 A context manager to discard standard output. Source code in pytkdocs/cli.py 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def discarded_stdout (): \"\"\"A context manager to discard standard output.\"\"\" # Discard things printed at import time to avoid corrupting our JSON output # See https://github.com/pawamoy/pytkdocs/issues/24 old_stdout = sys . stdout sys . stdout = StringIO () yield # Flush imported modules' output, and restore true sys.stdout sys . stdout . flush () sys . stdout = old_stdout extract_docstring_parsing_errors ( errors , obj ) \u00a4 Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required obj Object The object. required Source code in pytkdocs/cli.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def extract_docstring_parsing_errors ( errors : dict , obj : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. obj: The object. \"\"\" if hasattr ( obj , \"docstring_errors\" ): errors [ obj . path ] = obj . docstring_errors for child in obj . children : extract_docstring_parsing_errors ( errors , child ) extract_errors ( obj ) \u00a4 Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors get_parser () \u00a4 Return the program argument parser. Source code in pytkdocs/cli.py 148 149 150 151 152 153 154 155 156 157 158 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser main ( args = None ) \u00a4 The main function, which is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[Sequence[str]] The list of arguments. None Returns: Type Description int An exit code between 0 and 255. Source code in pytkdocs/cli.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def main ( args : Optional [ Sequence [ str ]] = None ) -> int : \"\"\" The main function, which is executed when you type `pytkdocs` or `python -m pytkdocs`. Arguments: args: The list of arguments. Returns: An exit code between 0 and 255. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : with discarded_stdout (): try : output = json . dumps ( process_json ( line )) except Exception as error : # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. output = json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()}) print ( output ) else : with discarded_stdout (): output = json . dumps ( process_json ( sys . stdin . read ())) print ( output ) return 0 process_config ( config ) \u00a4 Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) filters = obj_config . get ( \"filters\" , []) members = obj_config . get ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( filters = filters ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return { \"loading_errors\" : loading_errors , \"parsing_errors\" : parsing_errors , \"objects\" : collected } process_json ( json_input ) \u00a4 Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py 102 103 104 105 106 107 108 109 110 111 112 113 114 def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"cli.py"},{"location":"reference/cli/#pytkdocs.cli","text":"Module that contains the command line application.","title":"pytkdocs.cli"},{"location":"reference/cli/#pytkdocs.cli.discarded_stdout","text":"A context manager to discard standard output. Source code in pytkdocs/cli.py 161 162 163 164 165 166 167 168 169 170 171 172 173 @contextmanager def discarded_stdout (): \"\"\"A context manager to discard standard output.\"\"\" # Discard things printed at import time to avoid corrupting our JSON output # See https://github.com/pawamoy/pytkdocs/issues/24 old_stdout = sys . stdout sys . stdout = StringIO () yield # Flush imported modules' output, and restore true sys.stdout sys . stdout . flush () sys . stdout = old_stdout","title":"discarded_stdout()"},{"location":"reference/cli/#pytkdocs.cli.extract_docstring_parsing_errors","text":"Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required obj Object The object. required Source code in pytkdocs/cli.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def extract_docstring_parsing_errors ( errors : dict , obj : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. obj: The object. \"\"\" if hasattr ( obj , \"docstring_errors\" ): errors [ obj . path ] = obj . docstring_errors for child in obj . children : extract_docstring_parsing_errors ( errors , child )","title":"extract_docstring_parsing_errors()"},{"location":"reference/cli/#pytkdocs.cli.extract_errors","text":"Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py 133 134 135 136 137 138 139 140 141 142 143 144 145 def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors","title":"extract_errors()"},{"location":"reference/cli/#pytkdocs.cli.get_parser","text":"Return the program argument parser. Source code in pytkdocs/cli.py 148 149 150 151 152 153 154 155 156 157 158 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser","title":"get_parser()"},{"location":"reference/cli/#pytkdocs.cli.main","text":"The main function, which is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[Sequence[str]] The list of arguments. None Returns: Type Description int An exit code between 0 and 255. Source code in pytkdocs/cli.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def main ( args : Optional [ Sequence [ str ]] = None ) -> int : \"\"\" The main function, which is executed when you type `pytkdocs` or `python -m pytkdocs`. Arguments: args: The list of arguments. Returns: An exit code between 0 and 255. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : with discarded_stdout (): try : output = json . dumps ( process_json ( line )) except Exception as error : # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. output = json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()}) print ( output ) else : with discarded_stdout (): output = json . dumps ( process_json ( sys . stdin . read ())) print ( output ) return 0","title":"main()"},{"location":"reference/cli/#pytkdocs.cli.process_config","text":"Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) filters = obj_config . get ( \"filters\" , []) members = obj_config . get ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( filters = filters ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return { \"loading_errors\" : loading_errors , \"parsing_errors\" : parsing_errors , \"objects\" : collected }","title":"process_config()"},{"location":"reference/cli/#pytkdocs.cli.process_json","text":"Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py 102 103 104 105 106 107 108 109 110 111 112 113 114 def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"process_json()"},{"location":"reference/loader/","text":"\u00a4 This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc. Loader \u00a4 This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list. __init__ ( self , filters = None , docstring_style = 'google' , docstring_options = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None docstring_style str The style to use when parsing docstrings. 'google' docstring_options Optional[dict] The options to pass to the docstrings parser. None Source code in pytkdocs/loader.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def __init__ ( self , filters : Optional [ List [ str ]] = None , docstring_style : str = \"google\" , docstring_options : Optional [ dict ] = None , ) -> None : \"\"\" Initialization method. Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. docstring_style: The style to use when parsing docstrings. docstring_options: The options to pass to the docstrings parser. \"\"\" if not filters : filters = [] self . filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in filters ] self . docstring_parser = PARSERS [ docstring_style ]( ** ( docstring_options or {})) # type: ignore self . errors : List [ str ] = [] get_annotated_dataclass_field ( self , node ) \u00a4 Get the documentation for an dataclass annotation. Parameters: Name Type Description Default node ObjectNode The node representing the annotation and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def get_annotated_dataclass_field ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an dataclass annotation. Arguments: node: The node representing the annotation and its parents. Return: The documented attribute object. \"\"\" annotation : type = node . obj path = node . dotted_path properties = [ \"field\" ] return Attribute ( name = node . name , path = path , file_path = node . file_path , attr_type = annotation , properties = properties ) get_class_documentation ( self , node , members = None ) \u00a4 Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def get_class_documentation ( self , node : ObjectNode , members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. members: Explicit members to select. Return: The documented class object. \"\"\" class_ = node . obj docstring = textwrap . dedent ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) if members is False : return root_object members = members or set () for member_name , member in class_ . __dict__ . items (): if member is type or member is object : continue if not self . select ( member_name , members ): # type: ignore continue child_node = ObjectNode ( getattr ( class_ , member_name ), member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_classmethod (): root_object . add_child ( self . get_classmethod_documentation ( child_node )) elif child_node . is_staticmethod (): root_object . add_child ( self . get_staticmethod_documentation ( child_node )) elif child_node . is_method (): root_object . add_child ( self . get_regular_method_documentation ( child_node )) elif child_node . is_property (): root_object . add_child ( self . get_property_documentation ( child_node )) # First check if this is Pydantic compatible if \"__fields__\" in class_ . __dict__ : root_object . properties = [ \"pydantic\" ] for field_name , model_field in class_ . __dict__ . get ( \"__fields__\" , {}) . items (): if self . select ( field_name , members ): # type: ignore child_node = ObjectNode ( obj = model_field , name = field_name , parent = node ) root_object . add_child ( self . get_pydantic_field_documentation ( child_node )) # Handle dataclasses elif \"__dataclass_fields__\" in class_ . __dict__ : root_object . properties = [ \"dataclass\" ] for field_name , annotation in class_ . __dict__ . get ( \"__annotations__\" , {}) . items (): if self . select ( field_name , members ): # type: ignore child_node = ObjectNode ( obj = annotation , name = field_name , parent = node ) root_object . add_child ( self . get_annotated_dataclass_field ( child_node )) return root_object get_classmethod_documentation ( self , node ) \u00a4 Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 496 497 498 499 500 501 502 503 504 505 506 def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ]) get_function_documentation ( self , node ) \u00a4 Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Return: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , ) get_method_documentation ( self , node , properties = None ) \u00a4 Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Return: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , ) get_module_documentation ( self , node , members = None ) \u00a4 Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def get_module_documentation ( self , node : ObjectNode , members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. members: Explicit members to select. Return: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : with Path ( node . file_path ) . open () as fd : code = fd . readlines () if code : source = Source ( code , 1 ) else : source = None except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ), source = source ) if members is False : return root_object # type_hints = get_type_hints(module) members = members or set () for member_name , member in inspect . getmembers ( module , lambda m : node . root . obj is inspect . getmodule ( m )): if self . select ( member_name , members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function (): root_object . add_child ( self . get_function_documentation ( child_node )) try : package_path = module . __path__ except AttributeError : pass else : for _ , modname , _ in pkgutil . iter_modules ( package_path ): if self . select ( modname , members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object get_object_documentation ( self , dotted_path , members = None ) \u00a4 Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Optional[Union[Set[str], bool]] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Return: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) attributes = get_attributes ( leaf . root . obj ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : for attribute in attributes : if attribute . path == dotted_path : return attribute raise ValueError ( f \" { dotted_path } : { type ( leaf . obj ) } not yet supported\" ) if members is not False : filtered = [] for attribute in attributes : if attribute . parent_path == root_object . path : if self . select ( attribute . name , members ): # type: ignore filtered . append ( attribute ) elif self . select ( attribute . name , set ()): filtered . append ( attribute ) root_object . dispatch_attributes ( filtered ) root_object . parse_all_docstrings ( self . docstring_parser ) return root_object get_property_documentation ( self , node ) \u00a4 Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , ) get_pydantic_field_documentation ( self , node ) \u00a4 Get the documentation for a Pydantic Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def get_pydantic_field_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Pydantic Field. Arguments: node: The node representing the Field and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"field\" , \"pydantic\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . field_info . description , attr_type = prop . type_ , properties = properties , ) get_regular_method_documentation ( self , node ) \u00a4 Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Return: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method get_staticmethod_documentation ( self , node ) \u00a4 Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 508 509 510 511 512 513 514 515 516 517 518 def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ]) select ( self , name , names ) \u00a4 Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name ) ObjectNode \u00a4 Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. dotted_path: str property readonly \u00a4 The Python dotted path of the object. file_path: str property readonly \u00a4 The object's module file path. name: str \u00a4 The Python object's name. obj: Any \u00a4 The actual Python object. parent: Optional [ ObjectNode ] \u00a4 The parent node. root: ObjectNode property readonly \u00a4 The root of the tree. __init__ ( self , obj , name , parent = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default obj Any A Python object. required name str The object's name. required parent Optional[ObjectNode] The object's parent node. None Source code in pytkdocs/loader.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , obj : Any , name : str , parent : Optional [ \"ObjectNode\" ] = None ) -> None : \"\"\" Initialization method. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" self . obj : Any = obj \"\"\"The actual Python object.\"\"\" self . name : str = name \"\"\"The Python object's name.\"\"\" self . parent : Optional [ ObjectNode ] = parent \"\"\"The parent node.\"\"\" is_class ( self ) \u00a4 Is this node's object a class? Source code in pytkdocs/loader.py 77 78 79 def is_class ( self ) -> bool : \"\"\"Is this node's object a class?\"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) \u00a4 Is this node's object a classmethod? Source code in pytkdocs/loader.py 103 104 105 106 107 def is_classmethod ( self ) -> bool : \"\"\"Is this node's object a classmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod ) is_function ( self ) \u00a4 Is this node's object a function? Source code in pytkdocs/loader.py 81 82 83 def is_function ( self ) -> bool : \"\"\"Is this node's object a function?\"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) \u00a4 Is this node's object a method? Source code in pytkdocs/loader.py 93 94 95 def is_method ( self ) -> bool : \"\"\"Is this node's object a method?\"\"\" return self . parent_is_class () and isinstance ( self . obj , type ( lambda : 0 )) is_module ( self ) \u00a4 Is this node's object a module? Source code in pytkdocs/loader.py 73 74 75 def is_module ( self ) -> bool : \"\"\"Is this node's object a module?\"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) \u00a4 Is this node's object a property? Source code in pytkdocs/loader.py 85 86 87 def is_property ( self ) -> bool : \"\"\"Is this node's object a property?\"\"\" return isinstance ( self . obj , property ) is_staticmethod ( self ) \u00a4 Is this node's object a staticmethod? Source code in pytkdocs/loader.py 97 98 99 100 101 def is_staticmethod ( self ) -> bool : \"\"\"Is this node's object a staticmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod ) parent_is_class ( self ) \u00a4 Is the object of this node's parent a class? Source code in pytkdocs/loader.py 89 90 91 def parent_is_class ( self ) -> bool : \"\"\"Is the object of this node's parent a class?\"\"\" return bool ( self . parent and self . parent . is_class ()) get_object_tree ( path ) \u00a4 Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) current_node . child = ObjectNode ( obj , obj_name , parent = current_node ) # type: ignore current_node = current_node . child # type: ignore leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"loader.py"},{"location":"reference/loader/#pytkdocs.loader","text":"This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc.","title":"pytkdocs.loader"},{"location":"reference/loader/#pytkdocs.loader.Loader","text":"This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list.","title":"Loader"},{"location":"reference/loader/#pytkdocs.loader.Loader.__init__","text":"Initialization method. Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None docstring_style str The style to use when parsing docstrings. 'google' docstring_options Optional[dict] The options to pass to the docstrings parser. None Source code in pytkdocs/loader.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def __init__ ( self , filters : Optional [ List [ str ]] = None , docstring_style : str = \"google\" , docstring_options : Optional [ dict ] = None , ) -> None : \"\"\" Initialization method. Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. docstring_style: The style to use when parsing docstrings. docstring_options: The options to pass to the docstrings parser. \"\"\" if not filters : filters = [] self . filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in filters ] self . docstring_parser = PARSERS [ docstring_style ]( ** ( docstring_options or {})) # type: ignore self . errors : List [ str ] = []","title":"__init__()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_annotated_dataclass_field","text":"Get the documentation for an dataclass annotation. Parameters: Name Type Description Default node ObjectNode The node representing the annotation and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def get_annotated_dataclass_field ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an dataclass annotation. Arguments: node: The node representing the annotation and its parents. Return: The documented attribute object. \"\"\" annotation : type = node . obj path = node . dotted_path properties = [ \"field\" ] return Attribute ( name = node . name , path = path , file_path = node . file_path , attr_type = annotation , properties = properties )","title":"get_annotated_dataclass_field()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_class_documentation","text":"Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def get_class_documentation ( self , node : ObjectNode , members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. members: Explicit members to select. Return: The documented class object. \"\"\" class_ = node . obj docstring = textwrap . dedent ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) if members is False : return root_object members = members or set () for member_name , member in class_ . __dict__ . items (): if member is type or member is object : continue if not self . select ( member_name , members ): # type: ignore continue child_node = ObjectNode ( getattr ( class_ , member_name ), member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_classmethod (): root_object . add_child ( self . get_classmethod_documentation ( child_node )) elif child_node . is_staticmethod (): root_object . add_child ( self . get_staticmethod_documentation ( child_node )) elif child_node . is_method (): root_object . add_child ( self . get_regular_method_documentation ( child_node )) elif child_node . is_property (): root_object . add_child ( self . get_property_documentation ( child_node )) # First check if this is Pydantic compatible if \"__fields__\" in class_ . __dict__ : root_object . properties = [ \"pydantic\" ] for field_name , model_field in class_ . __dict__ . get ( \"__fields__\" , {}) . items (): if self . select ( field_name , members ): # type: ignore child_node = ObjectNode ( obj = model_field , name = field_name , parent = node ) root_object . add_child ( self . get_pydantic_field_documentation ( child_node )) # Handle dataclasses elif \"__dataclass_fields__\" in class_ . __dict__ : root_object . properties = [ \"dataclass\" ] for field_name , annotation in class_ . __dict__ . get ( \"__annotations__\" , {}) . items (): if self . select ( field_name , members ): # type: ignore child_node = ObjectNode ( obj = annotation , name = field_name , parent = node ) root_object . add_child ( self . get_annotated_dataclass_field ( child_node )) return root_object","title":"get_class_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_classmethod_documentation","text":"Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 496 497 498 499 500 501 502 503 504 505 506 def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ])","title":"get_classmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_function_documentation","text":"Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Return: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , )","title":"get_function_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_method_documentation","text":"Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Return: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , )","title":"get_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_module_documentation","text":"Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def get_module_documentation ( self , node : ObjectNode , members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. members: Explicit members to select. Return: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : with Path ( node . file_path ) . open () as fd : code = fd . readlines () if code : source = Source ( code , 1 ) else : source = None except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ), source = source ) if members is False : return root_object # type_hints = get_type_hints(module) members = members or set () for member_name , member in inspect . getmembers ( module , lambda m : node . root . obj is inspect . getmodule ( m )): if self . select ( member_name , members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function (): root_object . add_child ( self . get_function_documentation ( child_node )) try : package_path = module . __path__ except AttributeError : pass else : for _ , modname , _ in pkgutil . iter_modules ( package_path ): if self . select ( modname , members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object","title":"get_module_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_object_documentation","text":"Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Optional[Union[Set[str], bool]] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Return: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) attributes = get_attributes ( leaf . root . obj ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : for attribute in attributes : if attribute . path == dotted_path : return attribute raise ValueError ( f \" { dotted_path } : { type ( leaf . obj ) } not yet supported\" ) if members is not False : filtered = [] for attribute in attributes : if attribute . parent_path == root_object . path : if self . select ( attribute . name , members ): # type: ignore filtered . append ( attribute ) elif self . select ( attribute . name , set ()): filtered . append ( attribute ) root_object . dispatch_attributes ( filtered ) root_object . parse_all_docstrings ( self . docstring_parser ) return root_object","title":"get_object_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_property_documentation","text":"Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , )","title":"get_property_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_pydantic_field_documentation","text":"Get the documentation for a Pydantic Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def get_pydantic_field_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Pydantic Field. Arguments: node: The node representing the Field and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"field\" , \"pydantic\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . field_info . description , attr_type = prop . type_ , properties = properties , )","title":"get_pydantic_field_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_regular_method_documentation","text":"Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Return: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method","title":"get_regular_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_staticmethod_documentation","text":"Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 508 509 510 511 512 513 514 515 516 517 518 def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ])","title":"get_staticmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.select","text":"Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name )","title":"select()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node.","title":"ObjectNode"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.dotted_path","text":"The Python dotted path of the object.","title":"dotted_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.file_path","text":"The object's module file path.","title":"file_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.name","text":"The Python object's name.","title":"name"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.obj","text":"The actual Python object.","title":"obj"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.parent","text":"The parent node.","title":"parent"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.root","text":"The root of the tree.","title":"root"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.__init__","text":"Initialization method. Parameters: Name Type Description Default obj Any A Python object. required name str The object's name. required parent Optional[ObjectNode] The object's parent node. None Source code in pytkdocs/loader.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , obj : Any , name : str , parent : Optional [ \"ObjectNode\" ] = None ) -> None : \"\"\" Initialization method. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" self . obj : Any = obj \"\"\"The actual Python object.\"\"\" self . name : str = name \"\"\"The Python object's name.\"\"\" self . parent : Optional [ ObjectNode ] = parent \"\"\"The parent node.\"\"\"","title":"__init__()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_class","text":"Is this node's object a class? Source code in pytkdocs/loader.py 77 78 79 def is_class ( self ) -> bool : \"\"\"Is this node's object a class?\"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_classmethod","text":"Is this node's object a classmethod? Source code in pytkdocs/loader.py 103 104 105 106 107 def is_classmethod ( self ) -> bool : \"\"\"Is this node's object a classmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod )","title":"is_classmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_function","text":"Is this node's object a function? Source code in pytkdocs/loader.py 81 82 83 def is_function ( self ) -> bool : \"\"\"Is this node's object a function?\"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_method","text":"Is this node's object a method? Source code in pytkdocs/loader.py 93 94 95 def is_method ( self ) -> bool : \"\"\"Is this node's object a method?\"\"\" return self . parent_is_class () and isinstance ( self . obj , type ( lambda : 0 ))","title":"is_method()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_module","text":"Is this node's object a module? Source code in pytkdocs/loader.py 73 74 75 def is_module ( self ) -> bool : \"\"\"Is this node's object a module?\"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_property","text":"Is this node's object a property? Source code in pytkdocs/loader.py 85 86 87 def is_property ( self ) -> bool : \"\"\"Is this node's object a property?\"\"\" return isinstance ( self . obj , property )","title":"is_property()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_staticmethod","text":"Is this node's object a staticmethod? Source code in pytkdocs/loader.py 97 98 99 100 101 def is_staticmethod ( self ) -> bool : \"\"\"Is this node's object a staticmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod )","title":"is_staticmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.parent_is_class","text":"Is the object of this node's parent a class? Source code in pytkdocs/loader.py 89 90 91 def parent_is_class ( self ) -> bool : \"\"\"Is the object of this node's parent a class?\"\"\" return bool ( self . parent and self . parent . is_class ())","title":"parent_is_class()"},{"location":"reference/loader/#pytkdocs.loader.get_object_tree","text":"Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) current_node . child = ObjectNode ( obj , obj_name , parent = current_node ) # type: ignore current_node = current_node . child # type: ignore leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"get_object_tree()"},{"location":"reference/objects/","text":"\u00a4 This module defines the documented objects classes. the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code. Attribute \u00a4 A class to store information about an attribute. It accepts an additional attr_type argument at instantiation. __init__ ( self , * args , * , attr_type = None , ** kwargs ) special \u00a4 Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () attr_type The attribute type. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 400 401 402 403 404 405 406 407 408 409 410 def __init__ ( self , * args , attr_type = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. attr_type: The attribute type. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . type = attr_type Class \u00a4 A class to store information about a class. Function \u00a4 A class to store information about a function. It accepts an additional signature argument at instantiation. __init__ ( self , * args , * , signature = None , ** kwargs ) special \u00a4 Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () signature The function signature. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 356 357 358 359 360 361 362 363 364 365 366 def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. signature: The function signature. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature Method \u00a4 A class to store information about a method. It accepts an additional signature argument at instantiation. __init__ ( self , * args , * , signature = None , ** kwargs ) special \u00a4 Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () signature The function signature. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 378 379 380 381 382 383 384 385 386 387 388 def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. signature: The function signature. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature Module \u00a4 A class to store information about a module. file_name property readonly \u00a4 The base name of the module file, without the extension. Object \u00a4 A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category. attributes: List [ Attribute ] \u00a4 The list of all the object's attributes. category: str property readonly \u00a4 The object's category: module, class, function, method or attribute. children: List [ Object ] \u00a4 The list of all the object's children. classes: List [ Class ] \u00a4 The list of all the object's classes. docstring \u00a4 The object's docstring. docstring_errors: List [ str ] \u00a4 The errors detected while parsing the docstring. docstring_sections: List [ Section ] \u00a4 The object's docstring parsed into sections. file_path \u00a4 The file path of the object's direct parent module. functions: List [ Function ] \u00a4 The list of all the object's functions. is_attribute: bool property readonly \u00a4 Is this object an attribute? is_class: bool property readonly \u00a4 Is this object a class? is_function: bool property readonly \u00a4 Is this object a function? is_method: bool property readonly \u00a4 Is this object a method? is_module: bool property readonly \u00a4 Is this object a module? methods: List [ Method ] \u00a4 The list of all the object's methods. modules: List [ Module ] \u00a4 The list of all the object's submodules. name \u00a4 The object's name. name_properties: List [ str ] property readonly \u00a4 The object's name properties (private, class-private, special). NAME_PROPERTIES: List [ ApplicableNameProperty ] class-attribute \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. name_to_check: str property readonly \u00a4 The attribute to check against name properties regular expressions (private, class-private, special). parent: Optional [ Object ] \u00a4 The object's parent (another instance of a subclass of Object ). parent_path: str property readonly \u00a4 The parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent. path \u00a4 The object's dotted-path. properties \u00a4 The object's properties. relative_file_path: str property readonly \u00a4 The relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string). root: Object property readonly \u00a4 The object's root (top-most parent). source \u00a4 The object's source code. __init__ ( self , name , path , file_path , docstring = '' , properties = None , source = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring Optional[str] The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ str ] = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Initialization method. Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . docstring_sections : List [ Section ] = [] \"\"\"The object's docstring parsed into sections.\"\"\" self . docstring_errors : List [ str ] = [] \"\"\"The errors detected while parsing the docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . _parsed = False self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\" add_child ( self , obj ) \u00a4 Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) # type: ignore elif obj . is_class : self . classes . append ( obj ) # type: ignore elif obj . is_function : self . functions . append ( obj ) # type: ignore elif obj . is_method : self . methods . append ( obj ) # type: ignore elif obj . is_attribute : self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj add_children ( self , children ) \u00a4 Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py 262 263 264 265 266 267 268 269 270 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child ) dispatch_attributes ( self , attributes ) \u00a4 Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Parameters: Name Type Description Default attributes List[Attribute] The list of attributes to dispatch. required Source code in pytkdocs/objects.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def dispatch_attributes ( self , attributes : List [ \"Attribute\" ]) -> None : \"\"\" Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Arguments: attributes: The list of attributes to dispatch. \"\"\" for attribute in attributes : try : attach_to = self . _path_map [ attribute . parent_path ] except KeyError : pass else : attach_to . attributes . append ( attribute ) attach_to . children . append ( attribute ) attribute . parent = attach_to parse_all_docstrings ( self , parser ) \u00a4 Recursively parse the docstring of this object and its children. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required Source code in pytkdocs/objects.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def parse_all_docstrings ( self , parser : Parser ) -> None : \"\"\" Recursively parse the docstring of this object and its children. Arguments: parser: A parser to parse the docstrings. \"\"\" if self . docstring and not self . _parsed : self . docstring_sections , self . docstring_errors = parser . parse ( self . docstring , object_path = self . path , object_signature = getattr ( self , \"signature\" , None ), object_type = getattr ( self , \"type\" , None ), ) self . _parsed = True for child in self . children : child . parse_all_docstrings ( parser ) Source \u00a4 Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines . code \u00a4 The code, as a single string. line_start \u00a4 The first line number. __init__ ( self , lines , line_start ) special \u00a4 Initialization method. Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Initialization method. Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"objects.py"},{"location":"reference/objects/#pytkdocs.objects","text":"This module defines the documented objects classes. the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code.","title":"pytkdocs.objects"},{"location":"reference/objects/#pytkdocs.objects.Attribute","text":"A class to store information about an attribute. It accepts an additional attr_type argument at instantiation.","title":"Attribute"},{"location":"reference/objects/#pytkdocs.objects.Attribute.__init__","text":"Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () attr_type The attribute type. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 400 401 402 403 404 405 406 407 408 409 410 def __init__ ( self , * args , attr_type = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. attr_type: The attribute type. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . type = attr_type","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Class","text":"A class to store information about a class.","title":"Class"},{"location":"reference/objects/#pytkdocs.objects.Function","text":"A class to store information about a function. It accepts an additional signature argument at instantiation.","title":"Function"},{"location":"reference/objects/#pytkdocs.objects.Function.__init__","text":"Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () signature The function signature. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 356 357 358 359 360 361 362 363 364 365 366 def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. signature: The function signature. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Method","text":"A class to store information about a method. It accepts an additional signature argument at instantiation.","title":"Method"},{"location":"reference/objects/#pytkdocs.objects.Method.__init__","text":"Initialization method. Parameters: Name Type Description Default *args Arguments passed to the parent class initialization method. () signature The function signature. None **kwargs Arguments passed to the parent class initialization method. {} Source code in pytkdocs/objects.py 378 379 380 381 382 383 384 385 386 387 388 def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialization method. Arguments: *args: Arguments passed to the parent class initialization method. signature: The function signature. **kwargs: Arguments passed to the parent class initialization method. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Module","text":"A class to store information about a module.","title":"Module"},{"location":"reference/objects/#pytkdocs.objects.Module.file_name","text":"The base name of the module file, without the extension.","title":"file_name"},{"location":"reference/objects/#pytkdocs.objects.Object","text":"A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category.","title":"Object"},{"location":"reference/objects/#pytkdocs.objects.Object.attributes","text":"The list of all the object's attributes.","title":"attributes"},{"location":"reference/objects/#pytkdocs.objects.Object.category","text":"The object's category: module, class, function, method or attribute.","title":"category"},{"location":"reference/objects/#pytkdocs.objects.Object.children","text":"The list of all the object's children.","title":"children"},{"location":"reference/objects/#pytkdocs.objects.Object.classes","text":"The list of all the object's classes.","title":"classes"},{"location":"reference/objects/#pytkdocs.objects.Object.docstring","text":"The object's docstring.","title":"docstring"},{"location":"reference/objects/#pytkdocs.objects.Object.docstring_errors","text":"The errors detected while parsing the docstring.","title":"docstring_errors"},{"location":"reference/objects/#pytkdocs.objects.Object.docstring_sections","text":"The object's docstring parsed into sections.","title":"docstring_sections"},{"location":"reference/objects/#pytkdocs.objects.Object.file_path","text":"The file path of the object's direct parent module.","title":"file_path"},{"location":"reference/objects/#pytkdocs.objects.Object.functions","text":"The list of all the object's functions.","title":"functions"},{"location":"reference/objects/#pytkdocs.objects.Object.is_attribute","text":"Is this object an attribute?","title":"is_attribute"},{"location":"reference/objects/#pytkdocs.objects.Object.is_class","text":"Is this object a class?","title":"is_class"},{"location":"reference/objects/#pytkdocs.objects.Object.is_function","text":"Is this object a function?","title":"is_function"},{"location":"reference/objects/#pytkdocs.objects.Object.is_method","text":"Is this object a method?","title":"is_method"},{"location":"reference/objects/#pytkdocs.objects.Object.is_module","text":"Is this object a module?","title":"is_module"},{"location":"reference/objects/#pytkdocs.objects.Object.methods","text":"The list of all the object's methods.","title":"methods"},{"location":"reference/objects/#pytkdocs.objects.Object.modules","text":"The list of all the object's submodules.","title":"modules"},{"location":"reference/objects/#pytkdocs.objects.Object.name","text":"The object's name.","title":"name"},{"location":"reference/objects/#pytkdocs.objects.Object.name_properties","text":"The object's name properties (private, class-private, special).","title":"name_properties"},{"location":"reference/objects/#pytkdocs.objects.Object.NAME_PROPERTIES","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"NAME_PROPERTIES"},{"location":"reference/objects/#pytkdocs.objects.Object.name_to_check","text":"The attribute to check against name properties regular expressions (private, class-private, special).","title":"name_to_check"},{"location":"reference/objects/#pytkdocs.objects.Object.parent","text":"The object's parent (another instance of a subclass of Object ).","title":"parent"},{"location":"reference/objects/#pytkdocs.objects.Object.parent_path","text":"The parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent.","title":"parent_path"},{"location":"reference/objects/#pytkdocs.objects.Object.path","text":"The object's dotted-path.","title":"path"},{"location":"reference/objects/#pytkdocs.objects.Object.properties","text":"The object's properties.","title":"properties"},{"location":"reference/objects/#pytkdocs.objects.Object.relative_file_path","text":"The relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string).","title":"relative_file_path"},{"location":"reference/objects/#pytkdocs.objects.Object.root","text":"The object's root (top-most parent).","title":"root"},{"location":"reference/objects/#pytkdocs.objects.Object.source","text":"The object's source code.","title":"source"},{"location":"reference/objects/#pytkdocs.objects.Object.__init__","text":"Initialization method. Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring Optional[str] The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ str ] = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Initialization method. Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . docstring_sections : List [ Section ] = [] \"\"\"The object's docstring parsed into sections.\"\"\" self . docstring_errors : List [ str ] = [] \"\"\"The errors detected while parsing the docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . _parsed = False self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\"","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_child","text":"Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) # type: ignore elif obj . is_class : self . classes . append ( obj ) # type: ignore elif obj . is_function : self . functions . append ( obj ) # type: ignore elif obj . is_method : self . methods . append ( obj ) # type: ignore elif obj . is_attribute : self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj","title":"add_child()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_children","text":"Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py 262 263 264 265 266 267 268 269 270 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child )","title":"add_children()"},{"location":"reference/objects/#pytkdocs.objects.Object.dispatch_attributes","text":"Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Parameters: Name Type Description Default attributes List[Attribute] The list of attributes to dispatch. required Source code in pytkdocs/objects.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def dispatch_attributes ( self , attributes : List [ \"Attribute\" ]) -> None : \"\"\" Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Arguments: attributes: The list of attributes to dispatch. \"\"\" for attribute in attributes : try : attach_to = self . _path_map [ attribute . parent_path ] except KeyError : pass else : attach_to . attributes . append ( attribute ) attach_to . children . append ( attribute ) attribute . parent = attach_to","title":"dispatch_attributes()"},{"location":"reference/objects/#pytkdocs.objects.Object.parse_all_docstrings","text":"Recursively parse the docstring of this object and its children. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required Source code in pytkdocs/objects.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def parse_all_docstrings ( self , parser : Parser ) -> None : \"\"\" Recursively parse the docstring of this object and its children. Arguments: parser: A parser to parse the docstrings. \"\"\" if self . docstring and not self . _parsed : self . docstring_sections , self . docstring_errors = parser . parse ( self . docstring , object_path = self . path , object_signature = getattr ( self , \"signature\" , None ), object_type = getattr ( self , \"type\" , None ), ) self . _parsed = True for child in self . children : child . parse_all_docstrings ( parser )","title":"parse_all_docstrings()"},{"location":"reference/objects/#pytkdocs.objects.Source","text":"Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines .","title":"Source"},{"location":"reference/objects/#pytkdocs.objects.Source.code","text":"The code, as a single string.","title":"code"},{"location":"reference/objects/#pytkdocs.objects.Source.line_start","text":"The first line number.","title":"line_start"},{"location":"reference/objects/#pytkdocs.objects.Source.__init__","text":"Initialization method. Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Initialization method. Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"__init__()"},{"location":"reference/properties/","text":"\u00a4 This module simply defines regular expressions and their associated predicates. NAME_CLASS_PRIVATE: ApplicableNameProperty \u00a4 Applicable property: class-private . NAME_PRIVATE: ApplicableNameProperty \u00a4 Applicable property: private . NAME_SPECIAL: ApplicableNameProperty \u00a4 Applicable property: special . RE_CLASS_PRIVATE: Pattern \u00a4 Regular expression to match __class_private names. RE_PRIVATE: Pattern \u00a4 Regular expression to match _private names. RE_SPECIAL: Pattern \u00a4 Regular expression to match __special__ names.","title":"properties.py"},{"location":"reference/properties/#pytkdocs.properties","text":"This module simply defines regular expressions and their associated predicates.","title":"pytkdocs.properties"},{"location":"reference/properties/#pytkdocs.properties.NAME_CLASS_PRIVATE","text":"Applicable property: class-private .","title":"NAME_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_PRIVATE","text":"Applicable property: private .","title":"NAME_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_SPECIAL","text":"Applicable property: special .","title":"NAME_SPECIAL"},{"location":"reference/properties/#pytkdocs.properties.RE_CLASS_PRIVATE","text":"Regular expression to match __class_private names.","title":"RE_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_PRIVATE","text":"Regular expression to match _private names.","title":"RE_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_SPECIAL","text":"Regular expression to match __special__ names.","title":"RE_SPECIAL"},{"location":"reference/serializer/","text":"\u00a4 This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps . RE_FORWARD_REF: Pattern \u00a4 Regular expression to match forward-reference annotations of the form _ForwardRef('T') . RE_OPTIONAL: Pattern \u00a4 Regular expression to match optional annotations of the form Union[T, NoneType] . annotation_to_string ( annotation ) \u00a4 Return an annotation as a string. Parameters: Name Type Description Default annotation Any The annotation to return as a string. required Returns: Type Description str The annotation as a string. Source code in pytkdocs/serializer.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def annotation_to_string ( annotation : Any ) -> str : \"\"\" Return an annotation as a string. Arguments: annotation: The annotation to return as a string. Returns: The annotation as a string. \"\"\" if annotation is inspect . Signature . empty : return \"\" if inspect . isclass ( annotation ) and not isinstance ( annotation , GenericMeta ): string = annotation . __name__ else : string = str ( annotation ) . replace ( \"typing.\" , \"\" ) string = RE_FORWARD_REF . sub ( lambda match : match . group ( 1 ), string ) string = RE_OPTIONAL . sub ( lambda match : f \"Optional[ { rebuild_optional ( match . group ( 1 )) } ]\" , string ) return string rebuild_optional ( matched_group ) \u00a4 Rebuild Union[T, None] as Optional[T] . Parameters: Name Type Description Default matched_group str The matched group when matching against a regular expression (by the parent caller). required Returns: Type Description str The rebuilt type string. Source code in pytkdocs/serializer.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def rebuild_optional ( matched_group : str ) -> str : \"\"\" Rebuild `Union[T, None]` as `Optional[T]`. Arguments: matched_group: The matched group when matching against a regular expression (by the parent caller). Returns: The rebuilt type string. \"\"\" brackets_level = 0 for char in matched_group : if char == \",\" and brackets_level == 0 : return f \"Union[ { matched_group } ]\" elif char == \"[\" : brackets_level += 1 elif char == \"]\" : brackets_level -= 1 return matched_group serialize_annotated_object ( obj ) \u00a4 Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 74 75 76 77 78 79 80 81 82 83 84 def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"description\" : obj . description , \"annotation\" : annotation_to_string ( obj . annotation )} serialize_docstring_section ( section ) \u00a4 Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"type\" : section . type } if section . type == section . Type . MARKDOWN : serialized . update ({ \"value\" : section . value }) # type: ignore elif section . type == section . Type . RETURN : serialized . update ({ \"value\" : serialize_annotated_object ( section . value )}) # type: ignore elif section . type == section . Type . EXCEPTIONS : serialized . update ({ \"value\" : [ serialize_annotated_object ( e ) for e in section . value ]}) # type: ignore elif section . type == section . Type . PARAMETERS : serialized . update ({ \"value\" : [ serialize_parameter ( p ) for p in section . value ]}) # type: ignore return serialized serialize_object ( obj ) \u00a4 Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"name\" : obj . name , \"path\" : obj . path , \"category\" : obj . category , \"file_path\" : obj . file_path , \"relative_file_path\" : obj . relative_file_path , \"properties\" : sorted ( set ( obj . properties + obj . name_properties )), \"parent_path\" : obj . parent_path , \"has_contents\" : obj . has_contents (), \"docstring\" : obj . docstring , \"docstring_sections\" : [ serialize_docstring_section ( s ) for s in obj . docstring_sections ], \"source\" : serialize_source ( obj . source ), \"children\" : { child . path : serialize_object ( child ) for child in obj . children }, \"attributes\" : [ o . path for o in obj . attributes ], \"methods\" : [ o . path for o in obj . methods ], \"functions\" : [ o . path for o in obj . functions ], \"modules\" : [ o . path for o in obj . modules ], \"classes\" : [ o . path for o in obj . classes ], } if hasattr ( obj , \"type\" ): serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized serialize_parameter ( parameter ) \u00a4 Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.base.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.base.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( { \"name\" : parameter . name , \"kind\" : str ( parameter . kind ), \"default\" : parameter . default_string , \"is_optional\" : parameter . is_optional , \"is_required\" : parameter . is_required , \"is_args\" : parameter . is_args , \"is_kwargs\" : parameter . is_kwargs , } ) return serialized serialize_signature ( signature ) \u00a4 Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = { \"parameters\" : [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()] } if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized serialize_signature_parameter ( parameter ) \u00a4 Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"kind\" : str ( parameter . kind ), \"name\" : parameter . name } if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized serialize_source ( source ) \u00a4 Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 172 173 174 175 176 177 178 179 180 181 182 183 184 def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return { \"code\" : source . code , \"line_start\" : source . line_start } return {}","title":"serializer.py"},{"location":"reference/serializer/#pytkdocs.serializer","text":"This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps .","title":"pytkdocs.serializer"},{"location":"reference/serializer/#pytkdocs.serializer.RE_FORWARD_REF","text":"Regular expression to match forward-reference annotations of the form _ForwardRef('T') .","title":"RE_FORWARD_REF"},{"location":"reference/serializer/#pytkdocs.serializer.RE_OPTIONAL","text":"Regular expression to match optional annotations of the form Union[T, NoneType] .","title":"RE_OPTIONAL"},{"location":"reference/serializer/#pytkdocs.serializer.annotation_to_string","text":"Return an annotation as a string. Parameters: Name Type Description Default annotation Any The annotation to return as a string. required Returns: Type Description str The annotation as a string. Source code in pytkdocs/serializer.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def annotation_to_string ( annotation : Any ) -> str : \"\"\" Return an annotation as a string. Arguments: annotation: The annotation to return as a string. Returns: The annotation as a string. \"\"\" if annotation is inspect . Signature . empty : return \"\" if inspect . isclass ( annotation ) and not isinstance ( annotation , GenericMeta ): string = annotation . __name__ else : string = str ( annotation ) . replace ( \"typing.\" , \"\" ) string = RE_FORWARD_REF . sub ( lambda match : match . group ( 1 ), string ) string = RE_OPTIONAL . sub ( lambda match : f \"Optional[ { rebuild_optional ( match . group ( 1 )) } ]\" , string ) return string","title":"annotation_to_string()"},{"location":"reference/serializer/#pytkdocs.serializer.rebuild_optional","text":"Rebuild Union[T, None] as Optional[T] . Parameters: Name Type Description Default matched_group str The matched group when matching against a regular expression (by the parent caller). required Returns: Type Description str The rebuilt type string. Source code in pytkdocs/serializer.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def rebuild_optional ( matched_group : str ) -> str : \"\"\" Rebuild `Union[T, None]` as `Optional[T]`. Arguments: matched_group: The matched group when matching against a regular expression (by the parent caller). Returns: The rebuilt type string. \"\"\" brackets_level = 0 for char in matched_group : if char == \",\" and brackets_level == 0 : return f \"Union[ { matched_group } ]\" elif char == \"[\" : brackets_level += 1 elif char == \"]\" : brackets_level -= 1 return matched_group","title":"rebuild_optional()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_annotated_object","text":"Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 74 75 76 77 78 79 80 81 82 83 84 def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"description\" : obj . description , \"annotation\" : annotation_to_string ( obj . annotation )}","title":"serialize_annotated_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_docstring_section","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"type\" : section . type } if section . type == section . Type . MARKDOWN : serialized . update ({ \"value\" : section . value }) # type: ignore elif section . type == section . Type . RETURN : serialized . update ({ \"value\" : serialize_annotated_object ( section . value )}) # type: ignore elif section . type == section . Type . EXCEPTIONS : serialized . update ({ \"value\" : [ serialize_annotated_object ( e ) for e in section . value ]}) # type: ignore elif section . type == section . Type . PARAMETERS : serialized . update ({ \"value\" : [ serialize_parameter ( p ) for p in section . value ]}) # type: ignore return serialized","title":"serialize_docstring_section()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_object","text":"Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"name\" : obj . name , \"path\" : obj . path , \"category\" : obj . category , \"file_path\" : obj . file_path , \"relative_file_path\" : obj . relative_file_path , \"properties\" : sorted ( set ( obj . properties + obj . name_properties )), \"parent_path\" : obj . parent_path , \"has_contents\" : obj . has_contents (), \"docstring\" : obj . docstring , \"docstring_sections\" : [ serialize_docstring_section ( s ) for s in obj . docstring_sections ], \"source\" : serialize_source ( obj . source ), \"children\" : { child . path : serialize_object ( child ) for child in obj . children }, \"attributes\" : [ o . path for o in obj . attributes ], \"methods\" : [ o . path for o in obj . methods ], \"functions\" : [ o . path for o in obj . functions ], \"modules\" : [ o . path for o in obj . modules ], \"classes\" : [ o . path for o in obj . classes ], } if hasattr ( obj , \"type\" ): serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized","title":"serialize_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_parameter","text":"Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.base.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.base.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( { \"name\" : parameter . name , \"kind\" : str ( parameter . kind ), \"default\" : parameter . default_string , \"is_optional\" : parameter . is_optional , \"is_required\" : parameter . is_required , \"is_args\" : parameter . is_args , \"is_kwargs\" : parameter . is_kwargs , } ) return serialized","title":"serialize_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = { \"parameters\" : [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()] } if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized","title":"serialize_signature()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature_parameter","text":"Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"kind\" : str ( parameter . kind ), \"name\" : parameter . name } if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized","title":"serialize_signature_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_source","text":"Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 172 173 174 175 176 177 178 179 180 181 182 183 184 def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return { \"code\" : source . code , \"line_start\" : source . line_start } return {}","title":"serialize_source()"},{"location":"reference/parsers/__init__/","text":"\u00a4 The docstrings parsers' package.","title":"__init__.py"},{"location":"reference/parsers/__init__/#pytkdocs.parsers.__init__","text":"The docstrings parsers' package.","title":"pytkdocs.parsers.__init__"},{"location":"reference/parsers/attributes/","text":"\u00a4 Module containing functions to parse attributes in the source code.","title":"attributes.py"},{"location":"reference/parsers/attributes/#pytkdocs.parsers.attributes","text":"Module containing functions to parse attributes in the source code.","title":"pytkdocs.parsers.attributes"},{"location":"reference/parsers/docstrings/","text":"\u00a4 The parsers' package. base \u00a4 The base module for docstring parsing. AnnotatedObject \u00a4 A helper class to store information about an annotated object. __init__ ( self , annotation , description ) special \u00a4 Initialization method. Parameters: Name Type Description Default annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , annotation : Any , description : str ) -> None : \"\"\" Initialization method. Arguments: annotation: The object's annotation. description: The object's description. \"\"\" self . annotation = annotation self . description = description Parameter \u00a4 A helper class to store information about a signature parameter. default_string property readonly \u00a4 The default value as a string. is_args property readonly \u00a4 Is this a positional parameter? is_kwargs property readonly \u00a4 Is this a keyword parameter? is_optional property readonly \u00a4 Is this parameter optional? is_required property readonly \u00a4 Is this parameter required? __init__ ( self , name , annotation , description , kind , default ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str The parameter's name. required annotation Any The parameter's annotation. required description str The parameter's description. required kind Any The parameter's kind (positional only, keyword only, etc.). required default Any The parameter's default value. required Source code in pytkdocs/parsers/docstrings/base.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , name : str , annotation : Any , description : str , kind : Any , default : Any = empty ) -> None : \"\"\" Initialization method. Arguments: name: The parameter's name. annotation: The parameter's annotation. description: The parameter's description. kind: The parameter's kind (positional only, keyword only, etc.). default: The parameter's default value. \"\"\" super () . __init__ ( annotation , description ) self . name = name self . kind = kind self . default = default Parser \u00a4 A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. It also return the list of errors that occurred during parsing. __init__ ( self ) special \u00a4 Initialization method. Source code in pytkdocs/parsers/docstrings/base.py 124 125 126 127 128 129 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" self . object_path = \"\" self . object_signature : Optional [ inspect . Signature ] = None self . object_type = None self . errors : List [ str ] = [] error ( self , message ) \u00a4 Record a parsing error. Parameters: Name Type Description Default message A message described the error. required Source code in pytkdocs/parsers/docstrings/base.py 180 181 182 183 184 185 186 187 def error ( self , message ) -> None : \"\"\" Record a parsing error. Arguments: message: A message described the error. \"\"\" self . errors . append ( f \" { self . object_path } : { message } \" ) parse ( self , docstring , object_path , object_signature = None , object_type = None ) \u00a4 Parse a docstring and return a list of sections and parsing errors. Parameters: Name Type Description Default docstring str The docstring to parse. required object_path str The object's dotted path. required object_signature Optional[inspect.Signature] The object's signature. None object_type Optional[Any] The object's type. None Returns: Type Description Tuple[List[pytkdocs.parsers.docstrings.base.Section], List[str]] A tuple containing the list of sections and the parsing errors. Source code in pytkdocs/parsers/docstrings/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def parse ( self , docstring : str , object_path : str , object_signature : Optional [ inspect . Signature ] = None , object_type : Optional [ Any ] = None , ) -> Tuple [ List [ Section ], List [ str ]]: \"\"\" Parse a docstring and return a list of sections and parsing errors. Arguments: docstring: The docstring to parse. object_path: The object's dotted path. object_signature: The object's signature. object_type: The object's type. Returns: A tuple containing the list of sections and the parsing errors. \"\"\" self . set_state ( object_path , object_signature , object_type ) sections = self . parse_sections ( docstring ) errors = self . errors self . reset_state () return sections , errors parse_sections ( self , docstring ) \u00a4 Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/base.py 189 190 191 192 193 194 195 196 197 198 199 200 @abstractmethod def parse_sections ( self , docstring : str ) -> List [ Section ]: \"\"\" Parse a docstring as a list of sections. Arguments: docstring: The docstring to parse. Returns: A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s. \"\"\" raise NotImplementedError reset_state ( self ) \u00a4 Reset the parser state. Source code in pytkdocs/parsers/docstrings/base.py 149 150 151 152 153 def reset_state ( self ) -> None : \"\"\"Reset the parser state.\"\"\" self . object_path = \"\" self . object_signature = None self . object_type = None set_state ( self , object_path , object_signature , object_type ) \u00a4 Set the state of the parser. It is used to make these data available in the parse_sections method when implementing a parser. Parameters: Name Type Description Default object_path str The object's dotted path. required object_signature Optional[inspect.Signature] The object's signature. required object_type Optional[Any] The object's type. required Source code in pytkdocs/parsers/docstrings/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def set_state ( self , object_path : str , object_signature : Optional [ inspect . Signature ], object_type : Optional [ Any ], ) -> None : \"\"\" Set the state of the parser. It is used to make these data available in the `parse_sections` method when implementing a parser. Arguments: object_path: The object's dotted path. object_signature: The object's signature. object_type: The object's type. \"\"\" self . errors = [] self . object_path = object_path self . object_signature = object_signature self . object_type = object_type Section \u00a4 A helper class to store a docstring section. Type \u00a4 The possible section types. __init__ ( self , section_type , value ) special \u00a4 Initialization method. Parameters: Name Type Description Default section_type str The type of the section, from the [ Type ][pytkdocs.parsers.docstrings.base.Section.Type] enum. required value Union[str, List[pytkdocs.parsers.docstrings.base.Parameter], List[pytkdocs.parsers.docstrings.base.AnnotatedObject], pytkdocs.parsers.docstrings.base.AnnotatedObject] The section value. required Source code in pytkdocs/parsers/docstrings/base.py 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , section_type : str , value : Union [ str , List [ Parameter ], List [ AnnotatedObject ], AnnotatedObject ] ) -> None : \"\"\" Initialization method. Arguments: section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum. value: The section value. \"\"\" self . type = section_type self . value = value google \u00a4 This module defines functions and classes to parse docstrings into structured data. Google \u00a4 A Google-style docstrings parser. __init__ ( self , replace_admonitions = True ) special \u00a4 Initialization method. Parameters: Name Type Description Default replace_admonitions bool Whether to replace admonitions by their Markdown equivalent. True Source code in pytkdocs/parsers/docstrings/google.py 24 25 26 27 28 29 30 31 32 def __init__ ( self , replace_admonitions : bool = True ) -> None : \"\"\" Initialization method. Arguments: replace_admonitions: Whether to replace admonitions by their Markdown equivalent. \"\"\" super () . __init__ () self . replace_admonitions = replace_admonitions is_empty_line ( line ) staticmethod \u00a4 Tell if a line is empty. Parameters: Name Type Description Default line The line to check. required Returns: Type Description bool True if the line is empty or composed of blanks only, False otherwise. Source code in pytkdocs/parsers/docstrings/google.py 101 102 103 104 105 106 107 108 109 110 111 112 @staticmethod def is_empty_line ( line ) -> bool : \"\"\" Tell if a line is empty. Arguments: line: The line to check. Returns: True if the line is empty or composed of blanks only, False otherwise. \"\"\" return not line . strip () parse_sections ( self , docstring ) \u00a4 Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/google.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def parse_sections ( self , docstring : str ) -> List [ Section ]: # noqa: D102 sections = [] current_section = [] in_code_block = False lines = docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in TITLES_PARAMETERS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_parameters_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_exceptions_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_RETURN : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if self . replace_admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) return sections read_block ( self , lines , start_index ) \u00a4 Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[str, int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def read_block ( self , lines : List [ str ], start_index : int ) -> Tuple [ str , int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return \"\" , start_index i = start_index block : List [ str ] = [] # skip first empty lines while self . is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , i - 1 # start processing first item block . append ( lines [ i ] . lstrip ()) i += 1 # loop on next lines while i < len ( lines ) and ( lines [ i ] . startswith ( indent * \" \" ) or self . is_empty_line ( lines [ i ])): block . append ( lines [ i ][ indent :]) i += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), i - 1 read_block_items ( self , lines , start_index ) \u00a4 Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def read_block_items ( self , lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return [], start_index i = start_index items : List [ str ] = [] # skip first empty lines while self . is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], i - 1 # start processing first item current_item = [ lines [ i ][ indent :]] i += 1 # loop on next lines while i < len ( lines ): line = lines [ i ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but add error cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) self . error ( f \"Confusing indentation for continuation line { i + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( \" \\n \" . join ( current_item )) current_item = [ line [ indent :]] elif self . is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) else : # indent lower than initial one: end of section break i += 1 if current_item : items . append ( \" \\n \" . join ( current_item ) . rstrip ( \" \\n \" )) return items , i - 1 read_exceptions_section ( self , lines , start_index ) \u00a4 Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . error ( f \"Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . error ( f \"Empty exceptions section at line { start_index } \" ) return None , i read_parameters_section ( self , lines , start_index ) \u00a4 Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { param_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . object_signature . parameters [ name . lstrip ( \"*\" )] # type: ignore except ( AttributeError , KeyError ): self . error ( f \"No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description , default = default , kind = kind ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . error ( f \"Empty parameters section at line { start_index } \" ) return None , i read_return_section ( self , lines , start_index ) \u00a4 Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) if self . object_signature : annotation = self . object_signature . return_annotation else : annotation = self . object_type if annotation is empty : if not text : self . error ( \"No return type annotation\" ) else : try : type_ , text = text . split ( \":\" , 1 ) except ValueError : self . error ( \"No type in return description\" ) else : annotation = type_ . lstrip () text = text . lstrip () if annotation is empty and not text : self . error ( f \"Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , text )), i","title":"docstrings.py"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings","text":"The parsers' package.","title":"pytkdocs.parsers.docstrings"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base","text":"The base module for docstring parsing.","title":"base"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.AnnotatedObject","text":"A helper class to store information about an annotated object.","title":"AnnotatedObject"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.AnnotatedObject.__init__","text":"Initialization method. Parameters: Name Type Description Default annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , annotation : Any , description : str ) -> None : \"\"\" Initialization method. Arguments: annotation: The object's annotation. description: The object's description. \"\"\" self . annotation = annotation self . description = description","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter","text":"A helper class to store information about a signature parameter.","title":"Parameter"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.default_string","text":"The default value as a string.","title":"default_string"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.is_args","text":"Is this a positional parameter?","title":"is_args"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.is_kwargs","text":"Is this a keyword parameter?","title":"is_kwargs"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.is_optional","text":"Is this parameter optional?","title":"is_optional"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.is_required","text":"Is this parameter required?","title":"is_required"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parameter.__init__","text":"Initialization method. Parameters: Name Type Description Default name str The parameter's name. required annotation Any The parameter's annotation. required description str The parameter's description. required kind Any The parameter's kind (positional only, keyword only, etc.). required default Any The parameter's default value. required Source code in pytkdocs/parsers/docstrings/base.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , name : str , annotation : Any , description : str , kind : Any , default : Any = empty ) -> None : \"\"\" Initialization method. Arguments: name: The parameter's name. annotation: The parameter's annotation. description: The parameter's description. kind: The parameter's kind (positional only, keyword only, etc.). default: The parameter's default value. \"\"\" super () . __init__ ( annotation , description ) self . name = name self . kind = kind self . default = default","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser","text":"A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. It also return the list of errors that occurred during parsing.","title":"Parser"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.__init__","text":"Initialization method. Source code in pytkdocs/parsers/docstrings/base.py 124 125 126 127 128 129 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" self . object_path = \"\" self . object_signature : Optional [ inspect . Signature ] = None self . object_type = None self . errors : List [ str ] = []","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.error","text":"Record a parsing error. Parameters: Name Type Description Default message A message described the error. required Source code in pytkdocs/parsers/docstrings/base.py 180 181 182 183 184 185 186 187 def error ( self , message ) -> None : \"\"\" Record a parsing error. Arguments: message: A message described the error. \"\"\" self . errors . append ( f \" { self . object_path } : { message } \" )","title":"error()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.parse","text":"Parse a docstring and return a list of sections and parsing errors. Parameters: Name Type Description Default docstring str The docstring to parse. required object_path str The object's dotted path. required object_signature Optional[inspect.Signature] The object's signature. None object_type Optional[Any] The object's type. None Returns: Type Description Tuple[List[pytkdocs.parsers.docstrings.base.Section], List[str]] A tuple containing the list of sections and the parsing errors. Source code in pytkdocs/parsers/docstrings/base.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def parse ( self , docstring : str , object_path : str , object_signature : Optional [ inspect . Signature ] = None , object_type : Optional [ Any ] = None , ) -> Tuple [ List [ Section ], List [ str ]]: \"\"\" Parse a docstring and return a list of sections and parsing errors. Arguments: docstring: The docstring to parse. object_path: The object's dotted path. object_signature: The object's signature. object_type: The object's type. Returns: A tuple containing the list of sections and the parsing errors. \"\"\" self . set_state ( object_path , object_signature , object_type ) sections = self . parse_sections ( docstring ) errors = self . errors self . reset_state () return sections , errors","title":"parse()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.parse_sections","text":"Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/base.py 189 190 191 192 193 194 195 196 197 198 199 200 @abstractmethod def parse_sections ( self , docstring : str ) -> List [ Section ]: \"\"\" Parse a docstring as a list of sections. Arguments: docstring: The docstring to parse. Returns: A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s. \"\"\" raise NotImplementedError","title":"parse_sections()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.reset_state","text":"Reset the parser state. Source code in pytkdocs/parsers/docstrings/base.py 149 150 151 152 153 def reset_state ( self ) -> None : \"\"\"Reset the parser state.\"\"\" self . object_path = \"\" self . object_signature = None self . object_type = None","title":"reset_state()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Parser.set_state","text":"Set the state of the parser. It is used to make these data available in the parse_sections method when implementing a parser. Parameters: Name Type Description Default object_path str The object's dotted path. required object_signature Optional[inspect.Signature] The object's signature. required object_type Optional[Any] The object's type. required Source code in pytkdocs/parsers/docstrings/base.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def set_state ( self , object_path : str , object_signature : Optional [ inspect . Signature ], object_type : Optional [ Any ], ) -> None : \"\"\" Set the state of the parser. It is used to make these data available in the `parse_sections` method when implementing a parser. Arguments: object_path: The object's dotted path. object_signature: The object's signature. object_type: The object's type. \"\"\" self . errors = [] self . object_path = object_path self . object_signature = object_signature self . object_type = object_type","title":"set_state()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Section","text":"A helper class to store a docstring section.","title":"Section"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Section.Type","text":"The possible section types.","title":"Type"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.base.Section.__init__","text":"Initialization method. Parameters: Name Type Description Default section_type str The type of the section, from the [ Type ][pytkdocs.parsers.docstrings.base.Section.Type] enum. required value Union[str, List[pytkdocs.parsers.docstrings.base.Parameter], List[pytkdocs.parsers.docstrings.base.AnnotatedObject], pytkdocs.parsers.docstrings.base.AnnotatedObject] The section value. required Source code in pytkdocs/parsers/docstrings/base.py 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , section_type : str , value : Union [ str , List [ Parameter ], List [ AnnotatedObject ], AnnotatedObject ] ) -> None : \"\"\" Initialization method. Arguments: section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum. value: The section value. \"\"\" self . type = section_type self . value = value","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google","text":"This module defines functions and classes to parse docstrings into structured data.","title":"google"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google","text":"A Google-style docstrings parser.","title":"Google"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.__init__","text":"Initialization method. Parameters: Name Type Description Default replace_admonitions bool Whether to replace admonitions by their Markdown equivalent. True Source code in pytkdocs/parsers/docstrings/google.py 24 25 26 27 28 29 30 31 32 def __init__ ( self , replace_admonitions : bool = True ) -> None : \"\"\" Initialization method. Arguments: replace_admonitions: Whether to replace admonitions by their Markdown equivalent. \"\"\" super () . __init__ () self . replace_admonitions = replace_admonitions","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.is_empty_line","text":"Tell if a line is empty. Parameters: Name Type Description Default line The line to check. required Returns: Type Description bool True if the line is empty or composed of blanks only, False otherwise. Source code in pytkdocs/parsers/docstrings/google.py 101 102 103 104 105 106 107 108 109 110 111 112 @staticmethod def is_empty_line ( line ) -> bool : \"\"\" Tell if a line is empty. Arguments: line: The line to check. Returns: True if the line is empty or composed of blanks only, False otherwise. \"\"\" return not line . strip ()","title":"is_empty_line()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.parse_sections","text":"Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/google.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def parse_sections ( self , docstring : str ) -> List [ Section ]: # noqa: D102 sections = [] current_section = [] in_code_block = False lines = docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in TITLES_PARAMETERS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_parameters_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_exceptions_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_RETURN : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if self . replace_admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) return sections","title":"parse_sections()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.read_block","text":"Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[str, int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def read_block ( self , lines : List [ str ], start_index : int ) -> Tuple [ str , int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return \"\" , start_index i = start_index block : List [ str ] = [] # skip first empty lines while self . is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , i - 1 # start processing first item block . append ( lines [ i ] . lstrip ()) i += 1 # loop on next lines while i < len ( lines ) and ( lines [ i ] . startswith ( indent * \" \" ) or self . is_empty_line ( lines [ i ])): block . append ( lines [ i ][ indent :]) i += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), i - 1","title":"read_block()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.read_block_items","text":"Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def read_block_items ( self , lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return [], start_index i = start_index items : List [ str ] = [] # skip first empty lines while self . is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], i - 1 # start processing first item current_item = [ lines [ i ][ indent :]] i += 1 # loop on next lines while i < len ( lines ): line = lines [ i ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but add error cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) self . error ( f \"Confusing indentation for continuation line { i + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( \" \\n \" . join ( current_item )) current_item = [ line [ indent :]] elif self . is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) else : # indent lower than initial one: end of section break i += 1 if current_item : items . append ( \" \\n \" . join ( current_item ) . rstrip ( \" \\n \" )) return items , i - 1","title":"read_block_items()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.read_exceptions_section","text":"Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . error ( f \"Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . error ( f \"Empty exceptions section at line { start_index } \" ) return None , i","title":"read_exceptions_section()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.read_parameters_section","text":"Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { param_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . object_signature . parameters [ name . lstrip ( \"*\" )] # type: ignore except ( AttributeError , KeyError ): self . error ( f \"No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description , default = default , kind = kind ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . error ( f \"Empty parameters section at line { start_index } \" ) return None , i","title":"read_parameters_section()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.google.Google.read_return_section","text":"Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) if self . object_signature : annotation = self . object_signature . return_annotation else : annotation = self . object_type if annotation is empty : if not text : self . error ( \"No return type annotation\" ) else : try : type_ , text = text . split ( \":\" , 1 ) except ValueError : self . error ( \"No type in return description\" ) else : annotation = type_ . lstrip () text = text . lstrip () if annotation is empty and not text : self . error ( f \"Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , text )), i","title":"read_return_section()"}]}