{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytkdocs \u00a4 Load Python objects documentation. Requirements \u00a4 pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 Installation \u00a4 With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs Usage \u00a4 pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"pytkdocs\" , \"members\" : true , \"inherited_members\" : false , \"filters\" : [ \"!^_[^_]\" ], \"docstring_style\" : \"google\" , \"docstring_options\" : { \"replace_admonitions\" : true } } ] } Output format: { \"loading_errors\" : [ \"string (message)\" ], \"parsing_errors\" : { \"string (object)\" : [ \"string (message)\" ] }, \"objects\" : [ { \"name\" : \"pytkdocs\" , \"path\" : \"pytkdocs\" , \"category\" : \"module\" , \"file_path\" : \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\" , \"relative_file_path\" : \"pytkdocs/__init__.py\" , \"properties\" : [ \"special\" ], \"parent_path\" : \"pytkdocs\" , \"has_contents\" : true , \"docstring\" : \"pytkdocs package.\\n\\nLoad Python objects documentation.\" , \"docstring_sections\" : [ { \"type\" : \"markdown\" , \"value\" : \"pytkdocs package.\\n\\nLoad Python objects documentation.\" } ], \"source\" : { \"code\" : \"\\\"\\\"\\\"\\npytkdocs package.\\n\\nLoad Python objects documentation.\\n\\\"\\\"\\\"\\n\\nfrom typing import List\\n\\n__all__: List[str] = []\\n\" , \"line_start\" : 1 }, \"children\" : { \"pytkdocs.__all__\" : { \"name\" : \"__all__\" , \"path\" : \"pytkdocs.__all__\" , \"category\" : \"attribute\" , \"file_path\" : \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\" , \"relative_file_path\" : \"pytkdocs/__init__.py\" , \"properties\" : [ \"special\" ], \"parent_path\" : \"pytkdocs\" , \"has_contents\" : false , \"docstring\" : null , \"docstring_sections\" : [], \"source\" : {}, \"children\" : {}, \"attributes\" : [], \"methods\" : [], \"functions\" : [], \"modules\" : [], \"classes\" : [] } }, \"attributes\" : [ \"pytkdocs.__all__\" ], \"methods\" : [], \"functions\" : [], \"modules\" : [ \"pytkdocs.__main__\" , \"pytkdocs.cli\" , \"pytkdocs.loader\" , \"pytkdocs.objects\" , \"pytkdocs.parsers\" , \"pytkdocs.properties\" , \"pytkdocs.serializer\" ], \"classes\" : [] } ] } Command-line \u00a4 Running pytkdocs without argument will read the whole standard input, and output the result once. Running pytkdocs --line-by-line will enter an infinite loop, where at each iteration one line is read on the standard input, and the result is written back on one line. This allows other programs to use pytkdocs in a subprocess, feeding it single lines of JSON, and reading back single lines of JSON as well. This mode was actually implemented specifically for mkdocstrings . Configuration \u00a4 The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only. docstring_style : the docstring style to use when parsing the docstring. Only one parser available: google . docstring_options : options to pass to the docstring parser. google accepts a replace_admonitions boolean option (default: true). When enabled, this option will replace titles of an indented block by their Markdown admonition equivalent: AdmonitionType: Title will become !!! admonitiontype \"Title\" . inherited_members : true or false (default). When enabled, inherited members will be selected as well.","title":"Overview"},{"location":"#pytkdocs","text":"Load Python objects documentation.","title":"pytkdocs"},{"location":"#requirements","text":"pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs","title":"Installation"},{"location":"#usage","text":"pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"pytkdocs\" , \"members\" : true , \"inherited_members\" : false , \"filters\" : [ \"!^_[^_]\" ], \"docstring_style\" : \"google\" , \"docstring_options\" : { \"replace_admonitions\" : true } } ] } Output format: { \"loading_errors\" : [ \"string (message)\" ], \"parsing_errors\" : { \"string (object)\" : [ \"string (message)\" ] }, \"objects\" : [ { \"name\" : \"pytkdocs\" , \"path\" : \"pytkdocs\" , \"category\" : \"module\" , \"file_path\" : \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\" , \"relative_file_path\" : \"pytkdocs/__init__.py\" , \"properties\" : [ \"special\" ], \"parent_path\" : \"pytkdocs\" , \"has_contents\" : true , \"docstring\" : \"pytkdocs package.\\n\\nLoad Python objects documentation.\" , \"docstring_sections\" : [ { \"type\" : \"markdown\" , \"value\" : \"pytkdocs package.\\n\\nLoad Python objects documentation.\" } ], \"source\" : { \"code\" : \"\\\"\\\"\\\"\\npytkdocs package.\\n\\nLoad Python objects documentation.\\n\\\"\\\"\\\"\\n\\nfrom typing import List\\n\\n__all__: List[str] = []\\n\" , \"line_start\" : 1 }, \"children\" : { \"pytkdocs.__all__\" : { \"name\" : \"__all__\" , \"path\" : \"pytkdocs.__all__\" , \"category\" : \"attribute\" , \"file_path\" : \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\" , \"relative_file_path\" : \"pytkdocs/__init__.py\" , \"properties\" : [ \"special\" ], \"parent_path\" : \"pytkdocs\" , \"has_contents\" : false , \"docstring\" : null , \"docstring_sections\" : [], \"source\" : {}, \"children\" : {}, \"attributes\" : [], \"methods\" : [], \"functions\" : [], \"modules\" : [], \"classes\" : [] } }, \"attributes\" : [ \"pytkdocs.__all__\" ], \"methods\" : [], \"functions\" : [], \"modules\" : [ \"pytkdocs.__main__\" , \"pytkdocs.cli\" , \"pytkdocs.loader\" , \"pytkdocs.objects\" , \"pytkdocs.parsers\" , \"pytkdocs.properties\" , \"pytkdocs.serializer\" ], \"classes\" : [] } ] }","title":"Usage"},{"location":"#command-line","text":"Running pytkdocs without argument will read the whole standard input, and output the result once. Running pytkdocs --line-by-line will enter an infinite loop, where at each iteration one line is read on the standard input, and the result is written back on one line. This allows other programs to use pytkdocs in a subprocess, feeding it single lines of JSON, and reading back single lines of JSON as well. This mode was actually implemented specifically for mkdocstrings .","title":"Command-line"},{"location":"#configuration","text":"The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only. docstring_style : the docstring style to use when parsing the docstring. Only one parser available: google . docstring_options : options to pass to the docstring parser. google accepts a replace_admonitions boolean option (default: true). When enabled, this option will replace titles of an indented block by their Markdown admonition equivalent: AdmonitionType: Title will become !!! admonitiontype \"Title\" . inherited_members : true or false (default). When enabled, inherited members will be selected as well.","title":"Configuration"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.8.0 - 2020-09-25 \u00a4 Compare with 0.7.0 Features \u00a4 Add async property for coroutine functions ( a013c07 by Arthur Pastel). Issue pawamoy/mkdocstrings#151 , PR #65 0.7.0 - 2020-07-24 \u00a4 Compare with 0.6.0 Bug Fixes \u00a4 Fix code detecting dataclass fields ( 4c4a18b by Timoth\u00e9e Mazzucotelli). Prevent crash in case of empty dataclasses ( 835c066 by Jared Khan). PR #56 Use inspect.cleandoc for stripping docstrings whitespace ( 8009940 by Jared Khan). Issue #54 , PR #55 Features \u00a4 Add support for Marshmallow models ( c250466 by Stu Fisher). References: #51 0.6.0 - 2020-06-14 \u00a4 Compare with 0.5.2 Features \u00a4 Support attributes sections for Google-style docstrings ( 02c0042 by Timoth\u00e9e Mazzucotelli). 0.5.2 - 2020-06-11 \u00a4 Compare with 0.5.1 Bug Fixes \u00a4 Ignore exceptions when trying to unwrap ( 02ba876 by Timoth\u00e9e Mazzucotelli). References: #45 0.5.1 - 2020-06-09 \u00a4 Compare with 0.5.0 Bug Fixes \u00a4 Fix parsing tuple unpacking assignment ( 6535fe8 by Timoth\u00e9e Mazzucotelli). References: #43 0.5.0 - 2020-06-08 \u00a4 Compare with 0.4.0 Bug Fixes \u00a4 Fix getting documentation for wrapped objects ( 09f38a5 by Timoth\u00e9e Mazzucotelli). References: #32 Dedent attributes docstrings ( 1a6809c by Timoth\u00e9e Mazzucotelli). References: #42 Code Refactoring \u00a4 Accept any valid loader option in JSON input ( b58f4a9 by Timoth\u00e9e Mazzucotelli). Change Pydantic properties names ( fa8d2e7 by Timoth\u00e9e Mazzucotelli). Refactor parsers ( 3caefba by Timoth\u00e9e Mazzucotelli). Don't serialize empty error lists in the result ( 7bec6c4 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Accept docstring options in JSON input ( 400af0b by Timoth\u00e9e Mazzucotelli). Retrieve dataclass fields docstrings ( 09eb224 by Timoth\u00e9e Mazzucotelli). References: #31 Add support for class inheritance (inherited members) ( 1af9a53 by Timoth\u00e9e Mazzucotelli). References: #18 , #41 Add support for examples section ( 9521c7f by Iago GR). References: #8 As a consequence of the attribute parser refactor: pick attributes without docstrings. References: #11 0.4.0 - 2020-05-17 \u00a4 Compare with 0.3.0 Bug Fixes \u00a4 Never attempt to parse a null docstring ( aa92668 by Timoth\u00e9e Mazzucotelli). References: #37 Restore stdout before printing a traceback ( 20c21e9 by Timoth\u00e9e Mazzucotelli). References: #36 Discard import-time stdout ( 17f71af by Timoth\u00e9e Mazzucotelli). References: #24 Don't allow None for a property's docstring ( b5868f8 by Timoth\u00e9e Mazzucotelli). Fix relative path for native namespace packages ( a74dccf by Shyam Dwaraknath). References: #19 , #22 Code Refactoring \u00a4 Layout a docstring parser base ( d427bcc by Timoth\u00e9e Mazzucotelli). Features \u00a4 Add dataclass and pydantic support ( a172ad8 by Shyam Dwaraknath). References: #9 , #27 0.3.0 - 2020-04-10 \u00a4 Compare with 0.2.1 Bug Fixes \u00a4 Fix parsing of *args and **kwargs ( b81c93e by adrienhenry). Related issues/PRs: #20 , #21 Features \u00a4 Support different indentations and complex markup in docstrings sections ( 2f53082 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #17 0.2.1 - 2020-04-07 \u00a4 Compare with 0.2.0 Bug Fixes \u00a4 Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16 0.2.0 - 2020-03-27 \u00a4 Compare with 0.1.2 Added \u00a4 Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ). Changed \u00a4 The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors , 0.1.2 - 2020-03-23 \u00a4 Compare with 0.1.1 Fixed \u00a4 Catch error when trying to get builtins module file path ( 48df6bc ). 0.1.1 - 2020-03-21 \u00a4 Compare with 0.1.0 Fixed \u00a4 Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ). 0.1.0 - 2020-03-20 \u00a4 Compare with first commit Added \u00a4 Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#080-2020-09-25","text":"Compare with 0.7.0","title":"0.8.0 - 2020-09-25"},{"location":"changelog/#features","text":"Add async property for coroutine functions ( a013c07 by Arthur Pastel). Issue pawamoy/mkdocstrings#151 , PR #65","title":"Features"},{"location":"changelog/#070-2020-07-24","text":"Compare with 0.6.0","title":"0.7.0 - 2020-07-24"},{"location":"changelog/#bug-fixes","text":"Fix code detecting dataclass fields ( 4c4a18b by Timoth\u00e9e Mazzucotelli). Prevent crash in case of empty dataclasses ( 835c066 by Jared Khan). PR #56 Use inspect.cleandoc for stripping docstrings whitespace ( 8009940 by Jared Khan). Issue #54 , PR #55","title":"Bug Fixes"},{"location":"changelog/#features_1","text":"Add support for Marshmallow models ( c250466 by Stu Fisher). References: #51","title":"Features"},{"location":"changelog/#060-2020-06-14","text":"Compare with 0.5.2","title":"0.6.0 - 2020-06-14"},{"location":"changelog/#features_2","text":"Support attributes sections for Google-style docstrings ( 02c0042 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#052-2020-06-11","text":"Compare with 0.5.1","title":"0.5.2 - 2020-06-11"},{"location":"changelog/#bug-fixes_1","text":"Ignore exceptions when trying to unwrap ( 02ba876 by Timoth\u00e9e Mazzucotelli). References: #45","title":"Bug Fixes"},{"location":"changelog/#051-2020-06-09","text":"Compare with 0.5.0","title":"0.5.1 - 2020-06-09"},{"location":"changelog/#bug-fixes_2","text":"Fix parsing tuple unpacking assignment ( 6535fe8 by Timoth\u00e9e Mazzucotelli). References: #43","title":"Bug Fixes"},{"location":"changelog/#050-2020-06-08","text":"Compare with 0.4.0","title":"0.5.0 - 2020-06-08"},{"location":"changelog/#bug-fixes_3","text":"Fix getting documentation for wrapped objects ( 09f38a5 by Timoth\u00e9e Mazzucotelli). References: #32 Dedent attributes docstrings ( 1a6809c by Timoth\u00e9e Mazzucotelli). References: #42","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Accept any valid loader option in JSON input ( b58f4a9 by Timoth\u00e9e Mazzucotelli). Change Pydantic properties names ( fa8d2e7 by Timoth\u00e9e Mazzucotelli). Refactor parsers ( 3caefba by Timoth\u00e9e Mazzucotelli). Don't serialize empty error lists in the result ( 7bec6c4 by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_3","text":"Accept docstring options in JSON input ( 400af0b by Timoth\u00e9e Mazzucotelli). Retrieve dataclass fields docstrings ( 09eb224 by Timoth\u00e9e Mazzucotelli). References: #31 Add support for class inheritance (inherited members) ( 1af9a53 by Timoth\u00e9e Mazzucotelli). References: #18 , #41 Add support for examples section ( 9521c7f by Iago GR). References: #8 As a consequence of the attribute parser refactor: pick attributes without docstrings. References: #11","title":"Features"},{"location":"changelog/#040-2020-05-17","text":"Compare with 0.3.0","title":"0.4.0 - 2020-05-17"},{"location":"changelog/#bug-fixes_4","text":"Never attempt to parse a null docstring ( aa92668 by Timoth\u00e9e Mazzucotelli). References: #37 Restore stdout before printing a traceback ( 20c21e9 by Timoth\u00e9e Mazzucotelli). References: #36 Discard import-time stdout ( 17f71af by Timoth\u00e9e Mazzucotelli). References: #24 Don't allow None for a property's docstring ( b5868f8 by Timoth\u00e9e Mazzucotelli). Fix relative path for native namespace packages ( a74dccf by Shyam Dwaraknath). References: #19 , #22","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Layout a docstring parser base ( d427bcc by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_4","text":"Add dataclass and pydantic support ( a172ad8 by Shyam Dwaraknath). References: #9 , #27","title":"Features"},{"location":"changelog/#030-2020-04-10","text":"Compare with 0.2.1","title":"0.3.0 - 2020-04-10"},{"location":"changelog/#bug-fixes_5","text":"Fix parsing of *args and **kwargs ( b81c93e by adrienhenry). Related issues/PRs: #20 , #21","title":"Bug Fixes"},{"location":"changelog/#features_5","text":"Support different indentations and complex markup in docstrings sections ( 2f53082 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #17","title":"Features"},{"location":"changelog/#021-2020-04-07","text":"Compare with 0.2.0","title":"0.2.1 - 2020-04-07"},{"location":"changelog/#bug-fixes_6","text":"Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16","title":"Bug Fixes"},{"location":"changelog/#020-2020-03-27","text":"Compare with 0.1.2","title":"0.2.0 - 2020-03-27"},{"location":"changelog/#added","text":"Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ).","title":"Added"},{"location":"changelog/#changed","text":"The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors ,","title":"Changed"},{"location":"changelog/#012-2020-03-23","text":"Compare with 0.1.1","title":"0.1.2 - 2020-03-23"},{"location":"changelog/#fixed","text":"Catch error when trying to get builtins module file path ( 48df6bc ).","title":"Fixed"},{"location":"changelog/#011-2020-03-21","text":"Compare with 0.1.0","title":"0.1.1 - 2020-03-21"},{"location":"changelog/#fixed_1","text":"Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ).","title":"Fixed"},{"location":"changelog/#010-2020-03-20","text":"Compare with first commit","title":"0.1.0 - 2020-03-20"},{"location":"changelog/#added_1","text":"Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Added"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd pytkdocs make setup That's it! You now have the dependencies installed. You can run the application with poetry run pytkdocs [ARGS...] . Run make help to see all the available actions! Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd pytkdocs make setup That's it! You now have the dependencies installed. You can run the application with poetry run pytkdocs [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build pytkdocs . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 bandit | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | pydantic | pytest | pytest-cov | pytest-sugar | pytest-xdist | requests | toml Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | beautifulsoup4 | certifi | chardet | click | colorama | dataclasses | decorator | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build pytkdocs . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | pydantic | pytest | pytest-cov | pytest-sugar | pytest-xdist | requests | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | beautifulsoup4 | certifi | chardet | click | colorama | dataclasses | decorator | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Indirect dependencies"},{"location":"reference/__init__/","text":"\u00a4 pytkdocs package. Load Python objects documentation.","title":"__init__.py"},{"location":"reference/__init__/#pytkdocs.__init__","text":"pytkdocs package. Load Python objects documentation.","title":"pytkdocs.__init__"},{"location":"reference/__main__/","text":"\u00a4 Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"__main__.py"},{"location":"reference/__main__/#pytkdocs.__main__","text":"Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"pytkdocs.__main__"},{"location":"reference/cli/","text":"\u00a4 Module that contains the command line application. discarded_stdout () \u00a4 Discard standard output. Yields Nothing: we only yield to act as a context manager. Source code in pytkdocs/cli.py @contextmanager def discarded_stdout (): \"\"\" Discard standard output. Yields: Nothing: we only yield to act as a context manager. \"\"\" # Discard things printed at import time to avoid corrupting our JSON output # See https://github.com/pawamoy/pytkdocs/issues/24 old_stdout = sys . stdout sys . stdout = StringIO () yield # Flush imported modules' output, and restore true sys.stdout sys . stdout . flush () sys . stdout = old_stdout extract_docstring_parsing_errors ( errors , obj ) \u00a4 Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required obj Object The object. required Source code in pytkdocs/cli.py def extract_docstring_parsing_errors ( errors : dict , obj : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. obj: The object. \"\"\" if hasattr ( obj , \"docstring_errors\" ) and obj . docstring_errors : # noqa: WPS421 (hasattr) errors [ obj . path ] = obj . docstring_errors for child in obj . children : extract_docstring_parsing_errors ( errors , child ) extract_errors ( obj ) \u00a4 Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors get_parser () \u00a4 Return the program argument parser. Returns: Type Description ArgumentParser The argument parser for the program. Source code in pytkdocs/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"pytkdocs\" ) parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in pytkdocs/cli.py def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `pytkdocs` or `python -m pytkdocs`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : with discarded_stdout (): try : output = json . dumps ( process_json ( line )) except Exception as error : # noqa: W0703 (we purposely catch everything) # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. output = json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()}) print ( output ) # noqa: WPS421 (we need to print at some point) else : with discarded_stdout (): output = json . dumps ( process_json ( sys . stdin . read ())) print ( output ) # noqa: WPS421 (we need to print at some point) return 0 process_config ( config ) \u00a4 Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) members = obj_config . pop ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( ** obj_config ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return { \"loading_errors\" : loading_errors , \"parsing_errors\" : parsing_errors , \"objects\" : collected } process_json ( json_input ) \u00a4 Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"cli.py"},{"location":"reference/cli/#pytkdocs.cli","text":"Module that contains the command line application.","title":"pytkdocs.cli"},{"location":"reference/cli/#pytkdocs.cli.discarded_stdout","text":"Discard standard output. Yields Nothing: we only yield to act as a context manager. Source code in pytkdocs/cli.py @contextmanager def discarded_stdout (): \"\"\" Discard standard output. Yields: Nothing: we only yield to act as a context manager. \"\"\" # Discard things printed at import time to avoid corrupting our JSON output # See https://github.com/pawamoy/pytkdocs/issues/24 old_stdout = sys . stdout sys . stdout = StringIO () yield # Flush imported modules' output, and restore true sys.stdout sys . stdout . flush () sys . stdout = old_stdout","title":"discarded_stdout()"},{"location":"reference/cli/#pytkdocs.cli.extract_docstring_parsing_errors","text":"Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required obj Object The object. required Source code in pytkdocs/cli.py def extract_docstring_parsing_errors ( errors : dict , obj : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. obj: The object. \"\"\" if hasattr ( obj , \"docstring_errors\" ) and obj . docstring_errors : # noqa: WPS421 (hasattr) errors [ obj . path ] = obj . docstring_errors for child in obj . children : extract_docstring_parsing_errors ( errors , child )","title":"extract_docstring_parsing_errors()"},{"location":"reference/cli/#pytkdocs.cli.extract_errors","text":"Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors","title":"extract_errors()"},{"location":"reference/cli/#pytkdocs.cli.get_parser","text":"Return the program argument parser. Returns: Type Description ArgumentParser The argument parser for the program. Source code in pytkdocs/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the program argument parser. Returns: The argument parser for the program. \"\"\" parser = argparse . ArgumentParser ( prog = \"pytkdocs\" ) parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser","title":"get_parser()"},{"location":"reference/cli/#pytkdocs.cli.main","text":"Run the main program. This function is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in pytkdocs/cli.py def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `pytkdocs` or `python -m pytkdocs`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : with discarded_stdout (): try : output = json . dumps ( process_json ( line )) except Exception as error : # noqa: W0703 (we purposely catch everything) # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. output = json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()}) print ( output ) # noqa: WPS421 (we need to print at some point) else : with discarded_stdout (): output = json . dumps ( process_json ( sys . stdin . read ())) print ( output ) # noqa: WPS421 (we need to print at some point) return 0","title":"main()"},{"location":"reference/cli/#pytkdocs.cli.process_config","text":"Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) members = obj_config . pop ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( ** obj_config ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return { \"loading_errors\" : loading_errors , \"parsing_errors\" : parsing_errors , \"objects\" : collected }","title":"process_config()"},{"location":"reference/cli/#pytkdocs.cli.process_json","text":"Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"process_json()"},{"location":"reference/loader/","text":"\u00a4 This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc. Loader \u00a4 This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list. __init__ ( self , filters = None , docstring_style = 'google' , docstring_options = None , inherited_members = False ) special \u00a4 Initialize the object. Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None docstring_style str The style to use when parsing docstrings. 'google' docstring_options Optional[dict] The options to pass to the docstrings parser. None inherited_members bool Whether to select inherited members for classes. False Source code in pytkdocs/loader.py def __init__ ( self , filters : Optional [ List [ str ]] = None , docstring_style : str = \"google\" , docstring_options : Optional [ dict ] = None , inherited_members : bool = False , ) -> None : \"\"\" Initialize the object. Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. docstring_style: The style to use when parsing docstrings. docstring_options: The options to pass to the docstrings parser. inherited_members: Whether to select inherited members for classes. \"\"\" if not filters : filters = [] self . filters = [( filtr , re . compile ( filtr . lstrip ( \"!\" ))) for filtr in filters ] self . docstring_parser = PARSERS [ docstring_style ]( ** ( docstring_options or {})) # type: ignore self . errors : List [ str ] = [] self . select_inherited_members = inherited_members filter_name_out ( self , name ) \u00a4 Filter a name based on the loader's filters. Parameters: Name Type Description Default name str The name to filter. required Returns: Type Description bool True if the name was filtered out, False otherwise. Source code in pytkdocs/loader.py @lru_cache ( maxsize = None ) def filter_name_out ( self , name : str ) -> bool : \"\"\" Filter a name based on the loader's filters. Arguments: name: The name to filter. Returns: True if the name was filtered out, False otherwise. \"\"\" if not self . filters : return False keep = True for fltr , regex in self . filters : is_matching = bool ( regex . search ( name )) if is_matching : if str ( fltr ) . startswith ( \"!\" ): is_matching = not is_matching keep = is_matching return not keep get_annotated_dataclass_field ( node , attribute_data = None ) staticmethod \u00a4 Get the documentation for a dataclass field. Parameters: Name Type Description Default node ObjectNode The node representing the annotation and its parents. required attribute_data Optional[dict] Docstring and annotation for this attribute. None Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_annotated_dataclass_field ( node : ObjectNode , attribute_data : Optional [ dict ] = None ) -> Attribute : \"\"\" Get the documentation for a dataclass field. Arguments: node: The node representing the annotation and its parents. attribute_data: Docstring and annotation for this attribute. Returns: The documented attribute object. \"\"\" if attribute_data is None : if node . parent_is_class (): attribute_data = get_class_attributes ( node . parent . obj ) . get ( node . name , {}) # type: ignore else : attribute_data = get_module_attributes ( node . root . obj ) . get ( node . name , {}) return Attribute ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = attribute_data [ \"docstring\" ], attr_type = attribute_data [ \"annotation\" ], properties = [ \"dataclass-field\" ], ) get_attribute_documentation ( node , attribute_data = None ) staticmethod \u00a4 Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required attribute_data Optional[dict] Docstring and annotation for this attribute. None Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_attribute_documentation ( node : ObjectNode , attribute_data : Optional [ dict ] = None ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the method and its parents. attribute_data: Docstring and annotation for this attribute. Returns: The documented attribute object. \"\"\" if attribute_data is None : if node . parent_is_class (): attribute_data = get_class_attributes ( node . parent . obj ) . get ( node . name , {}) # type: ignore else : attribute_data = get_module_attributes ( node . root . obj ) . get ( node . name , {}) return Attribute ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = attribute_data . get ( \"docstring\" , \"\" ), attr_type = attribute_data . get ( \"annotation\" , None ), ) get_class_documentation ( self , node , select_members = None ) \u00a4 Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required select_members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py def get_class_documentation ( self , node : ObjectNode , select_members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. select_members: Explicit members to select. Returns: The documented class object. \"\"\" class_ = node . obj docstring = inspect . cleandoc ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) # Even if we don't select members, we want to correctly parse the docstring attributes_data : Dict [ str , Dict [ str , Any ]] = {} for parent_class in reversed ( class_ . __mro__ [: - 1 ]): merge ( attributes_data , get_class_attributes ( parent_class )) context : Dict [ str , Any ] = { \"attributes\" : attributes_data } if \"__init__\" in class_ . __dict__ : attributes_data . update ( get_instance_attributes ( class_ . __init__ )) context [ \"signature\" ] = inspect . signature ( class_ . __init__ ) root_object . parse_docstring ( self . docstring_parser , attributes = attributes_data ) if select_members is False : return root_object select_members = select_members or set () # Build the list of members members = {} inherited = set () direct_members = class_ . __dict__ all_members = dict ( inspect . getmembers ( class_ )) for member_name , member in all_members . items (): if not ( member is type or member is object ) and self . select ( member_name , select_members ): if member_name not in direct_members : if self . select_inherited_members : members [ member_name ] = member inherited . add ( member_name ) else : members [ member_name ] = member # Iterate on the selected members child : Object for member_name , member in members . items (): child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class (): child = self . get_class_documentation ( child_node ) elif child_node . is_classmethod (): child = self . get_classmethod_documentation ( child_node ) elif child_node . is_staticmethod (): child = self . get_staticmethod_documentation ( child_node ) elif child_node . is_method (): child = self . get_regular_method_documentation ( child_node ) elif child_node . is_property (): child = self . get_property_documentation ( child_node ) elif member_name in attributes_data : child = self . get_attribute_documentation ( child_node , attributes_data [ member_name ]) else : continue if member_name in inherited : child . properties . append ( \"inherited\" ) root_object . add_child ( child ) for attr_name , properties , add_method in ( ( \"__fields__\" , [ \"pydantic-model\" ], self . get_pydantic_field_documentation ), ( \"_declared_fields\" , [ \"marshmallow-model\" ], self . get_marshmallow_field_documentation ), ( \"__dataclass_fields__\" , [ \"dataclass\" ], self . get_annotated_dataclass_field ), ): if self . detect_field_model ( attr_name , direct_members , all_members ): root_object . properties . extend ( properties ) self . add_fields ( node , root_object , attr_name , all_members , select_members , class_ , add_method , ) break return root_object get_classmethod_documentation ( self , node ) \u00a4 Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Returns: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ]) get_function_documentation ( self , node ) \u00a4 Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Returns: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None properties : List [ str ] = [] if node . is_coroutine_function (): properties . append ( \"async\" ) return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , properties = properties , ) get_marshmallow_field_documentation ( node ) staticmethod \u00a4 Get the documentation for a Marshmallow Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_marshmallow_field_documentation ( node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Marshmallow Field. Arguments: node: The node representing the Field and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"marshmallow-field\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . metadata . get ( \"description\" ), attr_type = type ( prop ), properties = properties , ) get_method_documentation ( self , node , properties = None ) \u00a4 Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Returns: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None if node . is_coroutine_function (): if properties is None : properties = [ \"async\" ] else : properties . append ( \"async\" ) return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , ) get_module_documentation ( self , node , select_members = None ) \u00a4 Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required select_members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py def get_module_documentation ( self , node : ObjectNode , select_members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. select_members: Explicit members to select. Returns: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : code = Path ( node . file_path ) . read_text () except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None else : source = Source ( code , 1 ) if code else None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ), source = source , ) if select_members is False : return root_object select_members = select_members or set () attributes_data = get_module_attributes ( module ) root_object . parse_docstring ( self . docstring_parser , attributes = attributes_data ) for member_name , member in inspect . getmembers ( module ): if self . select ( member_name , select_members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class () and node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function () and node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_function_documentation ( child_node )) elif member_name in attributes_data : root_object . add_child ( self . get_attribute_documentation ( child_node , attributes_data [ member_name ])) if hasattr ( module , \"__path__\" ): # noqa: WPS421 (hasattr) for _ , modname , _ in pkgutil . iter_modules ( module . __path__ ): if self . select ( modname , select_members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object get_object_documentation ( self , dotted_path , members = None ) \u00a4 Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Union[Set[str], bool] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Returns: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : root_object = self . get_attribute_documentation ( leaf ) root_object . parse_all_docstrings ( self . docstring_parser ) return root_object get_property_documentation ( self , node ) \u00a4 Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , ) get_pydantic_field_documentation ( node ) staticmethod \u00a4 Get the documentation for a Pydantic Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_pydantic_field_documentation ( node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Pydantic Field. Arguments: node: The node representing the Field and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"pydantic-field\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . field_info . description , attr_type = prop . type_ , properties = properties , ) get_regular_method_documentation ( self , node ) \u00a4 Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Returns: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method get_staticmethod_documentation ( self , node ) \u00a4 Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Returns: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ]) select ( self , name , names ) \u00a4 Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name ) ObjectNode \u00a4 Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. dotted_path: str property readonly \u00a4 Return the Python dotted path to the object. Returns: Type Description str The Python dotted path to the object. file_path: str property readonly \u00a4 Return the object's module file path. Returns: Type Description str The object's module file path. root: ObjectNode property readonly \u00a4 Return the root of the tree. Returns: Type Description ObjectNode The root of the tree. __init__ ( self , obj , name , parent = None ) special \u00a4 Initialize the object. Parameters: Name Type Description Default obj Any A Python object. required name str The object's name. required parent Optional[ObjectNode] The object's parent node. None Source code in pytkdocs/loader.py def __init__ ( self , obj : Any , name : str , parent : Optional [ \"ObjectNode\" ] = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj \"\"\"The actual Python object.\"\"\" self . name : str = name \"\"\"The Python object's name.\"\"\" self . parent : Optional [ ObjectNode ] = parent \"\"\"The parent node.\"\"\" is_class ( self ) \u00a4 Tell if this node's object is a class. Returns: Type Description bool If this node's object is a class. Source code in pytkdocs/loader.py def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) \u00a4 Tell if this node's object is a classmethod. Returns: Type Description bool If this node's object is a classmethod. Source code in pytkdocs/loader.py def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod ) is_coroutine_function ( self ) \u00a4 Tell if this node's object is a coroutine. Returns: Type Description bool If this node's object is a coroutine. Source code in pytkdocs/loader.py def is_coroutine_function ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj ) is_function ( self ) \u00a4 Tell if this node's object is a function. Returns: Type Description bool If this node's object is a function. Source code in pytkdocs/loader.py def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) \u00a4 Tell if this node's object is a method. Returns: Type Description bool If this node's object is a method. Source code in pytkdocs/loader.py def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class () and isinstance ( self . obj , function_type ) is_module ( self ) \u00a4 Tell if this node's object is a module. Returns: Type Description bool The root of the tree. Source code in pytkdocs/loader.py def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) \u00a4 Tell if this node's object is a property. Returns: Type Description bool If this node's object is a property. Source code in pytkdocs/loader.py def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property ) is_staticmethod ( self ) \u00a4 Tell if this node's object is a staticmethod. Returns: Type Description bool If this node's object is a staticmethod. Source code in pytkdocs/loader.py def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod ) parent_is_class ( self ) \u00a4 Tell if the object of this node's parent is a class. Returns: Type Description bool If the object of this node's parent is a class. Source code in pytkdocs/loader.py def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ()) field_is_inherited ( field_name , fields_name , base_class ) \u00a4 Check if a field with a certain name was inherited from parent classes. Parameters: Name Type Description Default field_name str The name of the field to check. required fields_name str The name of the attribute in which the fields are stored. required base_class type The base class in which the field appears. required Returns: Type Description bool Whether the field was inherited. Source code in pytkdocs/loader.py def field_is_inherited ( field_name : str , fields_name : str , base_class : type ) -> bool : \"\"\" Check if a field with a certain name was inherited from parent classes. Arguments: field_name: The name of the field to check. fields_name: The name of the attribute in which the fields are stored. base_class: The base class in which the field appears. Returns: Whether the field was inherited. \"\"\" # To tell if a field was inherited, we check if it exists in parent classes __fields__ attributes. # We don't check the current class, nor the top one (object), hence __mro__[1:-1] return field_name in set ( chain ( * ( getattr ( parent_class , fields_name , {}) . keys () for parent_class in base_class . __mro__ [ 1 : - 1 ]), ), ) get_object_tree ( path ) \u00a4 Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError as error : if len ( obj_parent_modules ) == 1 : raise ImportError ( f \"No module named ' { obj_parent_modules [ 0 ] } '\" ) from error objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) child = ObjectNode ( obj , obj_name , parent = current_node ) current_node = child leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"loader.py"},{"location":"reference/loader/#pytkdocs.loader","text":"This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc.","title":"pytkdocs.loader"},{"location":"reference/loader/#pytkdocs.loader.Loader","text":"This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list.","title":"Loader"},{"location":"reference/loader/#pytkdocs.loader.Loader.__init__","text":"Initialize the object. Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None docstring_style str The style to use when parsing docstrings. 'google' docstring_options Optional[dict] The options to pass to the docstrings parser. None inherited_members bool Whether to select inherited members for classes. False Source code in pytkdocs/loader.py def __init__ ( self , filters : Optional [ List [ str ]] = None , docstring_style : str = \"google\" , docstring_options : Optional [ dict ] = None , inherited_members : bool = False , ) -> None : \"\"\" Initialize the object. Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. docstring_style: The style to use when parsing docstrings. docstring_options: The options to pass to the docstrings parser. inherited_members: Whether to select inherited members for classes. \"\"\" if not filters : filters = [] self . filters = [( filtr , re . compile ( filtr . lstrip ( \"!\" ))) for filtr in filters ] self . docstring_parser = PARSERS [ docstring_style ]( ** ( docstring_options or {})) # type: ignore self . errors : List [ str ] = [] self . select_inherited_members = inherited_members","title":"__init__()"},{"location":"reference/loader/#pytkdocs.loader.Loader.filter_name_out","text":"Filter a name based on the loader's filters. Parameters: Name Type Description Default name str The name to filter. required Returns: Type Description bool True if the name was filtered out, False otherwise. Source code in pytkdocs/loader.py @lru_cache ( maxsize = None ) def filter_name_out ( self , name : str ) -> bool : \"\"\" Filter a name based on the loader's filters. Arguments: name: The name to filter. Returns: True if the name was filtered out, False otherwise. \"\"\" if not self . filters : return False keep = True for fltr , regex in self . filters : is_matching = bool ( regex . search ( name )) if is_matching : if str ( fltr ) . startswith ( \"!\" ): is_matching = not is_matching keep = is_matching return not keep","title":"filter_name_out()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_annotated_dataclass_field","text":"Get the documentation for a dataclass field. Parameters: Name Type Description Default node ObjectNode The node representing the annotation and its parents. required attribute_data Optional[dict] Docstring and annotation for this attribute. None Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_annotated_dataclass_field ( node : ObjectNode , attribute_data : Optional [ dict ] = None ) -> Attribute : \"\"\" Get the documentation for a dataclass field. Arguments: node: The node representing the annotation and its parents. attribute_data: Docstring and annotation for this attribute. Returns: The documented attribute object. \"\"\" if attribute_data is None : if node . parent_is_class (): attribute_data = get_class_attributes ( node . parent . obj ) . get ( node . name , {}) # type: ignore else : attribute_data = get_module_attributes ( node . root . obj ) . get ( node . name , {}) return Attribute ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = attribute_data [ \"docstring\" ], attr_type = attribute_data [ \"annotation\" ], properties = [ \"dataclass-field\" ], )","title":"get_annotated_dataclass_field()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_attribute_documentation","text":"Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required attribute_data Optional[dict] Docstring and annotation for this attribute. None Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_attribute_documentation ( node : ObjectNode , attribute_data : Optional [ dict ] = None ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the method and its parents. attribute_data: Docstring and annotation for this attribute. Returns: The documented attribute object. \"\"\" if attribute_data is None : if node . parent_is_class (): attribute_data = get_class_attributes ( node . parent . obj ) . get ( node . name , {}) # type: ignore else : attribute_data = get_module_attributes ( node . root . obj ) . get ( node . name , {}) return Attribute ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = attribute_data . get ( \"docstring\" , \"\" ), attr_type = attribute_data . get ( \"annotation\" , None ), )","title":"get_attribute_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_class_documentation","text":"Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required select_members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py def get_class_documentation ( self , node : ObjectNode , select_members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. select_members: Explicit members to select. Returns: The documented class object. \"\"\" class_ = node . obj docstring = inspect . cleandoc ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) # Even if we don't select members, we want to correctly parse the docstring attributes_data : Dict [ str , Dict [ str , Any ]] = {} for parent_class in reversed ( class_ . __mro__ [: - 1 ]): merge ( attributes_data , get_class_attributes ( parent_class )) context : Dict [ str , Any ] = { \"attributes\" : attributes_data } if \"__init__\" in class_ . __dict__ : attributes_data . update ( get_instance_attributes ( class_ . __init__ )) context [ \"signature\" ] = inspect . signature ( class_ . __init__ ) root_object . parse_docstring ( self . docstring_parser , attributes = attributes_data ) if select_members is False : return root_object select_members = select_members or set () # Build the list of members members = {} inherited = set () direct_members = class_ . __dict__ all_members = dict ( inspect . getmembers ( class_ )) for member_name , member in all_members . items (): if not ( member is type or member is object ) and self . select ( member_name , select_members ): if member_name not in direct_members : if self . select_inherited_members : members [ member_name ] = member inherited . add ( member_name ) else : members [ member_name ] = member # Iterate on the selected members child : Object for member_name , member in members . items (): child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class (): child = self . get_class_documentation ( child_node ) elif child_node . is_classmethod (): child = self . get_classmethod_documentation ( child_node ) elif child_node . is_staticmethod (): child = self . get_staticmethod_documentation ( child_node ) elif child_node . is_method (): child = self . get_regular_method_documentation ( child_node ) elif child_node . is_property (): child = self . get_property_documentation ( child_node ) elif member_name in attributes_data : child = self . get_attribute_documentation ( child_node , attributes_data [ member_name ]) else : continue if member_name in inherited : child . properties . append ( \"inherited\" ) root_object . add_child ( child ) for attr_name , properties , add_method in ( ( \"__fields__\" , [ \"pydantic-model\" ], self . get_pydantic_field_documentation ), ( \"_declared_fields\" , [ \"marshmallow-model\" ], self . get_marshmallow_field_documentation ), ( \"__dataclass_fields__\" , [ \"dataclass\" ], self . get_annotated_dataclass_field ), ): if self . detect_field_model ( attr_name , direct_members , all_members ): root_object . properties . extend ( properties ) self . add_fields ( node , root_object , attr_name , all_members , select_members , class_ , add_method , ) break return root_object","title":"get_class_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_classmethod_documentation","text":"Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Returns: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ])","title":"get_classmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_function_documentation","text":"Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Returns: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None properties : List [ str ] = [] if node . is_coroutine_function (): properties . append ( \"async\" ) return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , properties = properties , )","title":"get_function_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_marshmallow_field_documentation","text":"Get the documentation for a Marshmallow Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_marshmallow_field_documentation ( node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Marshmallow Field. Arguments: node: The node representing the Field and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"marshmallow-field\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . metadata . get ( \"description\" ), attr_type = type ( prop ), properties = properties , )","title":"get_marshmallow_field_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_method_documentation","text":"Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Returns: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None if node . is_coroutine_function (): if properties is None : properties = [ \"async\" ] else : properties . append ( \"async\" ) return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , )","title":"get_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_module_documentation","text":"Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required select_members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py def get_module_documentation ( self , node : ObjectNode , select_members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. select_members: Explicit members to select. Returns: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : code = Path ( node . file_path ) . read_text () except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None else : source = Source ( code , 1 ) if code else None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ), source = source , ) if select_members is False : return root_object select_members = select_members or set () attributes_data = get_module_attributes ( module ) root_object . parse_docstring ( self . docstring_parser , attributes = attributes_data ) for member_name , member in inspect . getmembers ( module ): if self . select ( member_name , select_members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class () and node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function () and node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_function_documentation ( child_node )) elif member_name in attributes_data : root_object . add_child ( self . get_attribute_documentation ( child_node , attributes_data [ member_name ])) if hasattr ( module , \"__path__\" ): # noqa: WPS421 (hasattr) for _ , modname , _ in pkgutil . iter_modules ( module . __path__ ): if self . select ( modname , select_members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object","title":"get_module_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_object_documentation","text":"Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Union[Set[str], bool] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Returns: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : root_object = self . get_attribute_documentation ( leaf ) root_object . parse_all_docstrings ( self . docstring_parser ) return root_object","title":"get_object_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_property_documentation","text":"Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , )","title":"get_property_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_pydantic_field_documentation","text":"Get the documentation for a Pydantic Field. Parameters: Name Type Description Default node ObjectNode The node representing the Field and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py @staticmethod def get_pydantic_field_documentation ( node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for a Pydantic Field. Arguments: node: The node representing the Field and its parents. Returns: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"pydantic-field\" ] if prop . required : properties . append ( \"required\" ) return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = prop . field_info . description , attr_type = prop . type_ , properties = properties , )","title":"get_pydantic_field_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_regular_method_documentation","text":"Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Returns: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method","title":"get_regular_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_staticmethod_documentation","text":"Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Returns: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ])","title":"get_staticmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.select","text":"Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name )","title":"select()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node.","title":"ObjectNode"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.dotted_path","text":"Return the Python dotted path to the object. Returns: Type Description str The Python dotted path to the object.","title":"dotted_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.file_path","text":"Return the object's module file path. Returns: Type Description str The object's module file path.","title":"file_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.root","text":"Return the root of the tree. Returns: Type Description ObjectNode The root of the tree.","title":"root"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.__init__","text":"Initialize the object. Parameters: Name Type Description Default obj Any A Python object. required name str The object's name. required parent Optional[ObjectNode] The object's parent node. None Source code in pytkdocs/loader.py def __init__ ( self , obj : Any , name : str , parent : Optional [ \"ObjectNode\" ] = None ) -> None : \"\"\" Initialize the object. Arguments: obj: A Python object. name: The object's name. parent: The object's parent node. \"\"\" try : obj = inspect . unwrap ( obj ) except Exception : # noqa: S110,W0703 (we purposely catch every possible exception) # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"), # which triggers the __getattr__ method of the object, which in # turn can raise various exceptions. Probably not just __getattr__. # See https://github.com/pawamoy/pytkdocs/issues/45 pass # noqa: WPS420 (no other way than passing) self . obj : Any = obj \"\"\"The actual Python object.\"\"\" self . name : str = name \"\"\"The Python object's name.\"\"\" self . parent : Optional [ ObjectNode ] = parent \"\"\"The parent node.\"\"\"","title":"__init__()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_class","text":"Tell if this node's object is a class. Returns: Type Description bool If this node's object is a class. Source code in pytkdocs/loader.py def is_class ( self ) -> bool : \"\"\" Tell if this node's object is a class. Returns: If this node's object is a class. \"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_classmethod","text":"Tell if this node's object is a classmethod. Returns: Type Description bool If this node's object is a classmethod. Source code in pytkdocs/loader.py def is_classmethod ( self ) -> bool : \"\"\" Tell if this node's object is a classmethod. Returns: If this node's object is a classmethod. \"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod )","title":"is_classmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_coroutine_function","text":"Tell if this node's object is a coroutine. Returns: Type Description bool If this node's object is a coroutine. Source code in pytkdocs/loader.py def is_coroutine_function ( self ) -> bool : \"\"\" Tell if this node's object is a coroutine. Returns: If this node's object is a coroutine. \"\"\" return inspect . iscoroutinefunction ( self . obj )","title":"is_coroutine_function()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_function","text":"Tell if this node's object is a function. Returns: Type Description bool If this node's object is a function. Source code in pytkdocs/loader.py def is_function ( self ) -> bool : \"\"\" Tell if this node's object is a function. Returns: If this node's object is a function. \"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_method","text":"Tell if this node's object is a method. Returns: Type Description bool If this node's object is a method. Source code in pytkdocs/loader.py def is_method ( self ) -> bool : \"\"\" Tell if this node's object is a method. Returns: If this node's object is a method. \"\"\" function_type = type ( lambda : None ) return self . parent_is_class () and isinstance ( self . obj , function_type )","title":"is_method()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_module","text":"Tell if this node's object is a module. Returns: Type Description bool The root of the tree. Source code in pytkdocs/loader.py def is_module ( self ) -> bool : \"\"\" Tell if this node's object is a module. Returns: The root of the tree. \"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_property","text":"Tell if this node's object is a property. Returns: Type Description bool If this node's object is a property. Source code in pytkdocs/loader.py def is_property ( self ) -> bool : \"\"\" Tell if this node's object is a property. Returns: If this node's object is a property. \"\"\" return isinstance ( self . obj , property )","title":"is_property()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_staticmethod","text":"Tell if this node's object is a staticmethod. Returns: Type Description bool If this node's object is a staticmethod. Source code in pytkdocs/loader.py def is_staticmethod ( self ) -> bool : \"\"\" Tell if this node's object is a staticmethod. Returns: If this node's object is a staticmethod. \"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod )","title":"is_staticmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.parent_is_class","text":"Tell if the object of this node's parent is a class. Returns: Type Description bool If the object of this node's parent is a class. Source code in pytkdocs/loader.py def parent_is_class ( self ) -> bool : \"\"\" Tell if the object of this node's parent is a class. Returns: If the object of this node's parent is a class. \"\"\" return bool ( self . parent and self . parent . is_class ())","title":"parent_is_class()"},{"location":"reference/loader/#pytkdocs.loader.field_is_inherited","text":"Check if a field with a certain name was inherited from parent classes. Parameters: Name Type Description Default field_name str The name of the field to check. required fields_name str The name of the attribute in which the fields are stored. required base_class type The base class in which the field appears. required Returns: Type Description bool Whether the field was inherited. Source code in pytkdocs/loader.py def field_is_inherited ( field_name : str , fields_name : str , base_class : type ) -> bool : \"\"\" Check if a field with a certain name was inherited from parent classes. Arguments: field_name: The name of the field to check. fields_name: The name of the attribute in which the fields are stored. base_class: The base class in which the field appears. Returns: Whether the field was inherited. \"\"\" # To tell if a field was inherited, we check if it exists in parent classes __fields__ attributes. # We don't check the current class, nor the top one (object), hence __mro__[1:-1] return field_name in set ( chain ( * ( getattr ( parent_class , fields_name , {}) . keys () for parent_class in base_class . __mro__ [ 1 : - 1 ]), ), )","title":"field_is_inherited()"},{"location":"reference/loader/#pytkdocs.loader.get_object_tree","text":"Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError as error : if len ( obj_parent_modules ) == 1 : raise ImportError ( f \"No module named ' { obj_parent_modules [ 0 ] } '\" ) from error objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) child = ObjectNode ( obj , obj_name , parent = current_node ) current_node = child leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"get_object_tree()"},{"location":"reference/objects/","text":"\u00a4 This module defines the documented objects classes. the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code. Attribute \u00a4 A class to store information about an attribute. It accepts an additional attr_type argument at instantiation. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. __init__ ( self , * args , * , attr_type = None , ** kwargs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () attr_type The attribute type. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , attr_type = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. attr_type: The attribute type. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . type = attr_type Class \u00a4 A class to store information about a class. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. Function \u00a4 A class to store information about a function. It accepts an additional signature argument at instantiation. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. __init__ ( self , * args , * , signature = None , ** kwargs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () signature The function signature. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. signature: The function signature. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature Method \u00a4 A class to store information about a method. It accepts an additional signature argument at instantiation. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. __init__ ( self , * args , * , signature = None , ** kwargs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () signature The function signature. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. signature: The function signature. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature Module \u00a4 A class to store information about a module. file_name: str property readonly \u00a4 Return the base name of the module file, without the extension. Returns: Type Description str The module file's base name. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. Object \u00a4 A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category. category: str property readonly \u00a4 Return the object's category. Returns: Type Description str The object's category (module, class, function, method or attribute). name_properties: List [ str ] property readonly \u00a4 Return the object's name properties. Returns: Type Description List[str] The object's name properties (private, class-private, special). name_to_check: str property readonly \u00a4 Return the attribute to check against name-properties regular expressions (private, class-private, special). Returns: Type Description str The attribute to check (its name). parent_path: str property readonly \u00a4 Return the parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent. Returns: Type Description str The dotted path of the parent object. possible_name_properties: List [ Tuple [ str , Callable [[ str ], bool ]]] \u00a4 The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. relative_file_path: str property readonly \u00a4 Return the relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string). Returns: Type Description str The path relative to the object's package. root: Object property readonly \u00a4 Return the object's root. Returns: Type Description Object The object's root (top-most parent). __init__ ( self , name , path , file_path , docstring = '' , properties = None , source = None ) special \u00a4 Initialize the object. Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring Optional[str] The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ str ] = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Initialize the object. Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . docstring_sections : List [ Section ] = [] \"\"\"The object's docstring parsed into sections.\"\"\" self . docstring_errors : List [ str ] = [] \"\"\"The errors detected while parsing the docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . _parsed = False self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\" add_child ( self , obj ) \u00a4 Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if isinstance ( obj , Module ): self . modules . append ( obj ) # type: ignore elif isinstance ( obj , Class ): self . classes . append ( obj ) # type: ignore elif isinstance ( obj , Function ): self . functions . append ( obj ) # type: ignore elif isinstance ( obj , Method ): self . methods . append ( obj ) # type: ignore elif isinstance ( obj , Attribute ): self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj add_children ( self , children ) \u00a4 Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child ) has_contents ( self ) \u00a4 Tells if the object has \"contents\". An object has contents when: it is the root of the object tree it has a docstring at least one of its children (whatever the depth) has contents The value is cached, so this method should be called last, when the tree doesn't change anymore. Returns: Type Description bool Whether this object has contents or not. Source code in pytkdocs/objects.py @lru_cache () def has_contents ( self ) -> bool : \"\"\" Tells if the object has \"contents\". An object has contents when: - it is the root of the object tree - it has a docstring - at least one of its children (whatever the depth) has contents The value is cached, so this method should be called last, when the tree doesn't change anymore. Returns: Whether this object has contents or not. \"\"\" return bool ( self . docstring or not self . parent or any ( child . has_contents () for child in self . children )) parse_all_docstrings ( self , parser ) \u00a4 Recursively parse the docstring of this object and its children. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required Source code in pytkdocs/objects.py def parse_all_docstrings ( self , parser : Parser ) -> None : \"\"\" Recursively parse the docstring of this object and its children. Arguments: parser: A parser to parse the docstrings. \"\"\" self . parse_docstring ( parser ) for child in self . children : child . parse_all_docstrings ( parser ) parse_docstring ( self , parser , ** context ) \u00a4 Parse the docstring of this object. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required **context Additional context to use when parsing. {} Source code in pytkdocs/objects.py def parse_docstring ( self , parser : Parser , ** context ) -> None : \"\"\" Parse the docstring of this object. Arguments: parser: A parser to parse the docstrings. **context: Additional context to use when parsing. \"\"\" if self . docstring and not self . _parsed : sections , errors = parser . parse ( self . docstring , { \"obj\" : self , ** context }) self . docstring_sections = sections self . docstring_errors = errors self . _parsed = True Source \u00a4 Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines . __init__ ( self , lines , line_start ) special \u00a4 Initialize the object. Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Initialize the object. Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"objects.py"},{"location":"reference/objects/#pytkdocs.objects","text":"This module defines the documented objects classes. the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code.","title":"pytkdocs.objects"},{"location":"reference/objects/#pytkdocs.objects.Attribute","text":"A class to store information about an attribute. It accepts an additional attr_type argument at instantiation.","title":"Attribute"},{"location":"reference/objects/#pytkdocs.objects.Attribute.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Attribute.__init__","text":"Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () attr_type The attribute type. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , attr_type = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. attr_type: The attribute type. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . type = attr_type","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Class","text":"A class to store information about a class.","title":"Class"},{"location":"reference/objects/#pytkdocs.objects.Class.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Function","text":"A class to store information about a function. It accepts an additional signature argument at instantiation.","title":"Function"},{"location":"reference/objects/#pytkdocs.objects.Function.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Function.__init__","text":"Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () signature The function signature. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. signature: The function signature. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Method","text":"A class to store information about a method. It accepts an additional signature argument at instantiation.","title":"Method"},{"location":"reference/objects/#pytkdocs.objects.Method.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Method.__init__","text":"Initialize the object. Parameters: Name Type Description Default *args Arguments passed to the parent class Initialize the object. () signature The function signature. None **kwargs Arguments passed to the parent class Initialize the object. {} Source code in pytkdocs/objects.py def __init__ ( self , * args , signature = None , ** kwargs ): \"\"\" Initialize the object. Arguments: *args: Arguments passed to the parent class Initialize the object. signature: The function signature. **kwargs: Arguments passed to the parent class Initialize the object. \"\"\" super () . __init__ ( * args , ** kwargs ) self . signature = signature","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Module","text":"A class to store information about a module.","title":"Module"},{"location":"reference/objects/#pytkdocs.objects.Module.file_name","text":"Return the base name of the module file, without the extension. Returns: Type Description str The module file's base name.","title":"file_name"},{"location":"reference/objects/#pytkdocs.objects.Module.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Object","text":"A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category.","title":"Object"},{"location":"reference/objects/#pytkdocs.objects.Object.category","text":"Return the object's category. Returns: Type Description str The object's category (module, class, function, method or attribute).","title":"category"},{"location":"reference/objects/#pytkdocs.objects.Object.name_properties","text":"Return the object's name properties. Returns: Type Description List[str] The object's name properties (private, class-private, special).","title":"name_properties"},{"location":"reference/objects/#pytkdocs.objects.Object.name_to_check","text":"Return the attribute to check against name-properties regular expressions (private, class-private, special). Returns: Type Description str The attribute to check (its name).","title":"name_to_check"},{"location":"reference/objects/#pytkdocs.objects.Object.parent_path","text":"Return the parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent. Returns: Type Description str The dotted path of the parent object.","title":"parent_path"},{"location":"reference/objects/#pytkdocs.objects.Object.possible_name_properties","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"possible_name_properties"},{"location":"reference/objects/#pytkdocs.objects.Object.relative_file_path","text":"Return the relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string). Returns: Type Description str The path relative to the object's package.","title":"relative_file_path"},{"location":"reference/objects/#pytkdocs.objects.Object.root","text":"Return the object's root. Returns: Type Description Object The object's root (top-most parent).","title":"root"},{"location":"reference/objects/#pytkdocs.objects.Object.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring Optional[str] The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ str ] = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Initialize the object. Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . docstring_sections : List [ Section ] = [] \"\"\"The object's docstring parsed into sections.\"\"\" self . docstring_errors : List [ str ] = [] \"\"\"The errors detected while parsing the docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . _parsed = False self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\"","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_child","text":"Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if isinstance ( obj , Module ): self . modules . append ( obj ) # type: ignore elif isinstance ( obj , Class ): self . classes . append ( obj ) # type: ignore elif isinstance ( obj , Function ): self . functions . append ( obj ) # type: ignore elif isinstance ( obj , Method ): self . methods . append ( obj ) # type: ignore elif isinstance ( obj , Attribute ): self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj","title":"add_child()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_children","text":"Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child )","title":"add_children()"},{"location":"reference/objects/#pytkdocs.objects.Object.has_contents","text":"Tells if the object has \"contents\". An object has contents when: it is the root of the object tree it has a docstring at least one of its children (whatever the depth) has contents The value is cached, so this method should be called last, when the tree doesn't change anymore. Returns: Type Description bool Whether this object has contents or not. Source code in pytkdocs/objects.py @lru_cache () def has_contents ( self ) -> bool : \"\"\" Tells if the object has \"contents\". An object has contents when: - it is the root of the object tree - it has a docstring - at least one of its children (whatever the depth) has contents The value is cached, so this method should be called last, when the tree doesn't change anymore. Returns: Whether this object has contents or not. \"\"\" return bool ( self . docstring or not self . parent or any ( child . has_contents () for child in self . children ))","title":"has_contents()"},{"location":"reference/objects/#pytkdocs.objects.Object.parse_all_docstrings","text":"Recursively parse the docstring of this object and its children. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required Source code in pytkdocs/objects.py def parse_all_docstrings ( self , parser : Parser ) -> None : \"\"\" Recursively parse the docstring of this object and its children. Arguments: parser: A parser to parse the docstrings. \"\"\" self . parse_docstring ( parser ) for child in self . children : child . parse_all_docstrings ( parser )","title":"parse_all_docstrings()"},{"location":"reference/objects/#pytkdocs.objects.Object.parse_docstring","text":"Parse the docstring of this object. Parameters: Name Type Description Default parser Parser A parser to parse the docstrings. required **context Additional context to use when parsing. {} Source code in pytkdocs/objects.py def parse_docstring ( self , parser : Parser , ** context ) -> None : \"\"\" Parse the docstring of this object. Arguments: parser: A parser to parse the docstrings. **context: Additional context to use when parsing. \"\"\" if self . docstring and not self . _parsed : sections , errors = parser . parse ( self . docstring , { \"obj\" : self , ** context }) self . docstring_sections = sections self . docstring_errors = errors self . _parsed = True","title":"parse_docstring()"},{"location":"reference/objects/#pytkdocs.objects.Source","text":"Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines .","title":"Source"},{"location":"reference/objects/#pytkdocs.objects.Source.__init__","text":"Initialize the object. Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Initialize the object. Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"__init__()"},{"location":"reference/properties/","text":"\u00a4 This module simply defines regular expressions and their associated predicates. NAME_CLASS_PRIVATE: Tuple [ str , Callable [[ str ], bool ]] \u00a4 Applicable property: class-private . NAME_PRIVATE: Tuple [ str , Callable [[ str ], bool ]] \u00a4 Applicable property: private . NAME_SPECIAL: Tuple [ str , Callable [[ str ], bool ]] \u00a4 Applicable property: special . RE_CLASS_PRIVATE: Pattern [ ~ AnyStr ] \u00a4 Regular expression to match __class_private names. RE_PRIVATE: Pattern [ ~ AnyStr ] \u00a4 Regular expression to match _private names. RE_SPECIAL: Pattern [ ~ AnyStr ] \u00a4 Regular expression to match __special__ names.","title":"properties.py"},{"location":"reference/properties/#pytkdocs.properties","text":"This module simply defines regular expressions and their associated predicates.","title":"pytkdocs.properties"},{"location":"reference/properties/#pytkdocs.properties.NAME_CLASS_PRIVATE","text":"Applicable property: class-private .","title":"NAME_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_PRIVATE","text":"Applicable property: private .","title":"NAME_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_SPECIAL","text":"Applicable property: special .","title":"NAME_SPECIAL"},{"location":"reference/properties/#pytkdocs.properties.RE_CLASS_PRIVATE","text":"Regular expression to match __class_private names.","title":"RE_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_PRIVATE","text":"Regular expression to match _private names.","title":"RE_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_SPECIAL","text":"Regular expression to match __special__ names.","title":"RE_SPECIAL"},{"location":"reference/serializer/","text":"\u00a4 This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps . RE_FORWARD_REF: Pattern [ ~ AnyStr ] \u00a4 Regular expression to match forward-reference annotations of the form _ForwardRef('T') . RE_OPTIONAL: Pattern [ ~ AnyStr ] \u00a4 Regular expression to match optional annotations of the form Union[T, NoneType] . annotation_to_string ( annotation ) \u00a4 Return an annotation as a string. Parameters: Name Type Description Default annotation Any The annotation to return as a string. required Returns: Type Description str The annotation as a string. Source code in pytkdocs/serializer.py def annotation_to_string ( annotation : Any ) -> str : \"\"\" Return an annotation as a string. Arguments: annotation: The annotation to return as a string. Returns: The annotation as a string. \"\"\" if annotation is inspect . Signature . empty : return \"\" if inspect . isclass ( annotation ) and not isinstance ( annotation , GenericMeta ): string = annotation . __name__ else : string = str ( annotation ) . replace ( \"typing.\" , \"\" ) string = RE_FORWARD_REF . sub ( lambda match : match . group ( 1 ), string ) string = RE_OPTIONAL . sub ( rebuild_optional , string ) return string # noqa: WPS331 (false-positive, string is not only used for the return) rebuild_optional ( match ) \u00a4 Rebuild Union[T, None] as Optional[T] . Parameters: Name Type Description Default match Match[~AnyStr] The match object when matching against a regular expression (by the parent caller). required Returns: Type Description str The rebuilt type string. Source code in pytkdocs/serializer.py def rebuild_optional ( match : Match ) -> str : \"\"\" Rebuild `Union[T, None]` as `Optional[T]`. Arguments: match: The match object when matching against a regular expression (by the parent caller). Returns: The rebuilt type string. \"\"\" group = match . group ( 1 ) brackets_level = 0 for char in group : if char == \",\" and brackets_level == 0 : return f \"Union[ { group } ]\" if char == \"[\" : brackets_level += 1 elif char == \"]\" : brackets_level -= 1 return f \"Optional[ { group } ]\" serialize_annotated_object ( obj ) \u00a4 Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"description\" : obj . description , \"annotation\" : annotation_to_string ( obj . annotation )} serialize_attribute ( attribute ) \u00a4 Serialize an instance of [ Attribute ][pytkdocs.parsers.docstrings.base.Attribute]. Parameters: Name Type Description Default attribute Attribute The attribute to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_attribute ( attribute : Attribute ) -> dict : \"\"\" Serialize an instance of [`Attribute`][pytkdocs.parsers.docstrings.base.Attribute]. Arguments: attribute: The attribute to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"name\" : attribute . name , \"description\" : attribute . description , \"annotation\" : annotation_to_string ( attribute . annotation ), } serialize_docstring_section ( section ) \u00a4 Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"type\" : section . type } if section . type == section . Type . MARKDOWN : serialized . update ({ \"value\" : section . value }) # type: ignore elif section . type == section . Type . RETURN : serialized . update ({ \"value\" : serialize_annotated_object ( section . value )}) # type: ignore elif section . type == section . Type . EXCEPTIONS : serialized . update ({ \"value\" : [ serialize_annotated_object ( exc ) for exc in section . value ]}) # type: ignore elif section . type == section . Type . PARAMETERS : serialized . update ({ \"value\" : [ serialize_parameter ( param ) for param in section . value ]}) # type: ignore elif section . type == section . Type . ATTRIBUTES : serialized . update ({ \"value\" : [ serialize_attribute ( attr ) for attr in section . value ]}) # type: ignore elif section . type == section . Type . EXAMPLES : serialized . update ({ \"value\" : section . value }) # type: ignore return serialized serialize_object ( obj ) \u00a4 Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"name\" : obj . name , \"path\" : obj . path , \"category\" : obj . category , \"file_path\" : obj . file_path , \"relative_file_path\" : obj . relative_file_path , \"properties\" : sorted ( set ( obj . properties + obj . name_properties )), \"parent_path\" : obj . parent_path , \"has_contents\" : obj . has_contents (), \"docstring\" : obj . docstring , \"docstring_sections\" : [ serialize_docstring_section ( sec ) for sec in obj . docstring_sections ], \"source\" : serialize_source ( obj . source ), \"children\" : { child . path : serialize_object ( child ) for child in obj . children }, \"attributes\" : [ attr . path for attr in obj . attributes ], \"methods\" : [ meth . path for meth in obj . methods ], \"functions\" : [ func . path for func in obj . functions ], \"modules\" : [ mod . path for mod in obj . modules ], \"classes\" : [ clas . path for clas in obj . classes ], } if hasattr ( obj , \"type\" ): # noqa: WPS421 (hasattr) serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): # noqa: WPS421 (hasattr) serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized serialize_parameter ( parameter ) \u00a4 Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.base.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.base.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( { \"name\" : parameter . name , \"kind\" : str ( parameter . kind ), \"default\" : parameter . default_string , \"is_optional\" : parameter . is_optional , \"is_required\" : parameter . is_required , \"is_args\" : parameter . is_args , \"is_kwargs\" : parameter . is_kwargs , }, ) return serialized serialize_signature ( signature ) \u00a4 Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = { \"parameters\" : [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()], } if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized serialize_signature_parameter ( parameter ) \u00a4 Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"kind\" : str ( parameter . kind ), \"name\" : parameter . name } if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized serialize_source ( source ) \u00a4 Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return { \"code\" : source . code , \"line_start\" : source . line_start } return {}","title":"serializer.py"},{"location":"reference/serializer/#pytkdocs.serializer","text":"This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps .","title":"pytkdocs.serializer"},{"location":"reference/serializer/#pytkdocs.serializer.RE_FORWARD_REF","text":"Regular expression to match forward-reference annotations of the form _ForwardRef('T') .","title":"RE_FORWARD_REF"},{"location":"reference/serializer/#pytkdocs.serializer.RE_OPTIONAL","text":"Regular expression to match optional annotations of the form Union[T, NoneType] .","title":"RE_OPTIONAL"},{"location":"reference/serializer/#pytkdocs.serializer.annotation_to_string","text":"Return an annotation as a string. Parameters: Name Type Description Default annotation Any The annotation to return as a string. required Returns: Type Description str The annotation as a string. Source code in pytkdocs/serializer.py def annotation_to_string ( annotation : Any ) -> str : \"\"\" Return an annotation as a string. Arguments: annotation: The annotation to return as a string. Returns: The annotation as a string. \"\"\" if annotation is inspect . Signature . empty : return \"\" if inspect . isclass ( annotation ) and not isinstance ( annotation , GenericMeta ): string = annotation . __name__ else : string = str ( annotation ) . replace ( \"typing.\" , \"\" ) string = RE_FORWARD_REF . sub ( lambda match : match . group ( 1 ), string ) string = RE_OPTIONAL . sub ( rebuild_optional , string ) return string # noqa: WPS331 (false-positive, string is not only used for the return)","title":"annotation_to_string()"},{"location":"reference/serializer/#pytkdocs.serializer.rebuild_optional","text":"Rebuild Union[T, None] as Optional[T] . Parameters: Name Type Description Default match Match[~AnyStr] The match object when matching against a regular expression (by the parent caller). required Returns: Type Description str The rebuilt type string. Source code in pytkdocs/serializer.py def rebuild_optional ( match : Match ) -> str : \"\"\" Rebuild `Union[T, None]` as `Optional[T]`. Arguments: match: The match object when matching against a regular expression (by the parent caller). Returns: The rebuilt type string. \"\"\" group = match . group ( 1 ) brackets_level = 0 for char in group : if char == \",\" and brackets_level == 0 : return f \"Union[ { group } ]\" if char == \"[\" : brackets_level += 1 elif char == \"]\" : brackets_level -= 1 return f \"Optional[ { group } ]\"","title":"rebuild_optional()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_annotated_object","text":"Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.base.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"description\" : obj . description , \"annotation\" : annotation_to_string ( obj . annotation )}","title":"serialize_annotated_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_attribute","text":"Serialize an instance of [ Attribute ][pytkdocs.parsers.docstrings.base.Attribute]. Parameters: Name Type Description Default attribute Attribute The attribute to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_attribute ( attribute : Attribute ) -> dict : \"\"\" Serialize an instance of [`Attribute`][pytkdocs.parsers.docstrings.base.Attribute]. Arguments: attribute: The attribute to serialize. Returns: A JSON-serializable dictionary. \"\"\" return { \"name\" : attribute . name , \"description\" : attribute . description , \"annotation\" : annotation_to_string ( attribute . annotation ), }","title":"serialize_attribute()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_docstring_section","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"type\" : section . type } if section . type == section . Type . MARKDOWN : serialized . update ({ \"value\" : section . value }) # type: ignore elif section . type == section . Type . RETURN : serialized . update ({ \"value\" : serialize_annotated_object ( section . value )}) # type: ignore elif section . type == section . Type . EXCEPTIONS : serialized . update ({ \"value\" : [ serialize_annotated_object ( exc ) for exc in section . value ]}) # type: ignore elif section . type == section . Type . PARAMETERS : serialized . update ({ \"value\" : [ serialize_parameter ( param ) for param in section . value ]}) # type: ignore elif section . type == section . Type . ATTRIBUTES : serialized . update ({ \"value\" : [ serialize_attribute ( attr ) for attr in section . value ]}) # type: ignore elif section . type == section . Type . EXAMPLES : serialized . update ({ \"value\" : section . value }) # type: ignore return serialized","title":"serialize_docstring_section()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_object","text":"Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"name\" : obj . name , \"path\" : obj . path , \"category\" : obj . category , \"file_path\" : obj . file_path , \"relative_file_path\" : obj . relative_file_path , \"properties\" : sorted ( set ( obj . properties + obj . name_properties )), \"parent_path\" : obj . parent_path , \"has_contents\" : obj . has_contents (), \"docstring\" : obj . docstring , \"docstring_sections\" : [ serialize_docstring_section ( sec ) for sec in obj . docstring_sections ], \"source\" : serialize_source ( obj . source ), \"children\" : { child . path : serialize_object ( child ) for child in obj . children }, \"attributes\" : [ attr . path for attr in obj . attributes ], \"methods\" : [ meth . path for meth in obj . methods ], \"functions\" : [ func . path for func in obj . functions ], \"modules\" : [ mod . path for mod in obj . modules ], \"classes\" : [ clas . path for clas in obj . classes ], } if hasattr ( obj , \"type\" ): # noqa: WPS421 (hasattr) serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): # noqa: WPS421 (hasattr) serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized","title":"serialize_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_parameter","text":"Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.base.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.base.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( { \"name\" : parameter . name , \"kind\" : str ( parameter . kind ), \"default\" : parameter . default_string , \"is_optional\" : parameter . is_optional , \"is_required\" : parameter . is_required , \"is_args\" : parameter . is_args , \"is_kwargs\" : parameter . is_kwargs , }, ) return serialized","title":"serialize_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = { \"parameters\" : [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()], } if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized","title":"serialize_signature()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature_parameter","text":"Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = { \"kind\" : str ( parameter . kind ), \"name\" : parameter . name } if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized","title":"serialize_signature_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_source","text":"Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return { \"code\" : source . code , \"line_start\" : source . line_start } return {}","title":"serialize_source()"},{"location":"reference/parsers/__init__/","text":"\u00a4 The docstrings parsers' package.","title":"__init__.py"},{"location":"reference/parsers/__init__/#pytkdocs.parsers.__init__","text":"The docstrings parsers' package.","title":"pytkdocs.parsers.__init__"},{"location":"reference/parsers/attributes/","text":"\u00a4 Module containing functions to parse attributes in the source code.","title":"attributes.py"},{"location":"reference/parsers/attributes/#pytkdocs.parsers.attributes","text":"Module containing functions to parse attributes in the source code.","title":"pytkdocs.parsers.attributes"},{"location":"reference/parsers/docstrings/__init__/","text":"\u00a4 The parsers' package.","title":"__init__.py"},{"location":"reference/parsers/docstrings/__init__/#pytkdocs.parsers.docstrings.__init__","text":"The parsers' package.","title":"pytkdocs.parsers.docstrings.__init__"},{"location":"reference/parsers/docstrings/base/","text":"\u00a4 The base module for docstring parsing. AnnotatedObject \u00a4 A helper class to store information about an annotated object. __init__ ( self , annotation , description ) special \u00a4 Initialize the object. Parameters: Name Type Description Default annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , annotation : Any , description : str ) -> None : \"\"\" Initialize the object. Arguments: annotation: The object's annotation. description: The object's description. \"\"\" self . annotation = annotation self . description = description Attribute \u00a4 A helper class to store information about a documented attribute. __init__ ( self , name , annotation , description ) special \u00a4 Initialize the object. Parameters: Name Type Description Default name str The attribute's name. required annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , name : str , annotation : Any , description : str ) -> None : \"\"\" Initialize the object. Arguments: name: The attribute's name. annotation: The object's annotation. description: The object's description. \"\"\" super () . __init__ ( annotation , description ) self . name = name Parameter \u00a4 A helper class to store information about a signature parameter. default_string property readonly \u00a4 Return the default value as a string. is_args property readonly \u00a4 Tell if this parameter is positional. is_kwargs property readonly \u00a4 Tell if this parameter is a keyword. is_optional property readonly \u00a4 Tell if this parameter is optional. is_required property readonly \u00a4 Tell if this parameter is required. __init__ ( self , name , annotation , description , kind , default ) special \u00a4 Initialize the object. Parameters: Name Type Description Default name str The parameter's name. required annotation Any The parameter's annotation. required description str The parameter's description. required kind Any The parameter's kind (positional only, keyword only, etc.). required default Any The parameter's default value. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , name : str , annotation : Any , description : str , kind : Any , default : Any = empty ) -> None : \"\"\" Initialize the object. Arguments: name: The parameter's name. annotation: The parameter's annotation. description: The parameter's description. kind: The parameter's kind (positional only, keyword only, etc.). default: The parameter's default value. \"\"\" super () . __init__ ( annotation , description ) self . name = name self . kind = kind self . default = default Parser \u00a4 A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. It also return the list of errors that occurred during parsing. __init__ ( self ) special \u00a4 Initialize the object. Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" self . context : dict = {} self . errors : List [ str ] = [] error ( self , message ) \u00a4 Record a parsing error. Parameters: Name Type Description Default message A message described the error. required Source code in pytkdocs/parsers/docstrings/base.py def error ( self , message ) -> None : \"\"\" Record a parsing error. Arguments: message: A message described the error. \"\"\" if self . context [ \"obj\" ]: message = f \" { self . context [ 'obj' ] . path } : { message } \" self . errors . append ( message ) parse ( self , docstring , context = None ) \u00a4 Parse a docstring and return a list of sections and parsing errors. Parameters: Name Type Description Default docstring str The docstring to parse. required context Optional[dict] Some context helping to parse the docstring. None Returns: Type Description Tuple[List[pytkdocs.parsers.docstrings.base.Section], List[str]] A tuple containing the list of sections and the parsing errors. Source code in pytkdocs/parsers/docstrings/base.py def parse ( self , docstring : str , context : Optional [ dict ] = None ) -> Tuple [ List [ Section ], List [ str ]]: \"\"\" Parse a docstring and return a list of sections and parsing errors. Arguments: docstring: The docstring to parse. context: Some context helping to parse the docstring. Returns: A tuple containing the list of sections and the parsing errors. \"\"\" self . context = context or {} self . errors = [] sections = self . parse_sections ( docstring ) errors = self . errors return sections , errors parse_sections ( self , docstring ) \u00a4 Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/base.py @abstractmethod def parse_sections ( self , docstring : str ) -> List [ Section ]: \"\"\" Parse a docstring as a list of sections. Arguments: docstring: The docstring to parse. Returns: A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s. \"\"\" raise NotImplementedError Section \u00a4 A helper class to store a docstring section. Type \u00a4 The possible section types. __init__ ( self , section_type , value ) special \u00a4 Initialize the object. Parameters: Name Type Description Default section_type str The type of the section, from the [ Type ][pytkdocs.parsers.docstrings.base.Section.Type] enum. required value Any The section value. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , section_type : str , value : Any ) -> None : \"\"\" Initialize the object. Arguments: section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum. value: The section value. \"\"\" self . type = section_type self . value = value","title":"base.py"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base","text":"The base module for docstring parsing.","title":"pytkdocs.parsers.docstrings.base"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.AnnotatedObject","text":"A helper class to store information about an annotated object.","title":"AnnotatedObject"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.AnnotatedObject.__init__","text":"Initialize the object. Parameters: Name Type Description Default annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , annotation : Any , description : str ) -> None : \"\"\" Initialize the object. Arguments: annotation: The object's annotation. description: The object's description. \"\"\" self . annotation = annotation self . description = description","title":"__init__()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Attribute","text":"A helper class to store information about a documented attribute.","title":"Attribute"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Attribute.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The attribute's name. required annotation Any The object's annotation. required description str The object's description. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , name : str , annotation : Any , description : str ) -> None : \"\"\" Initialize the object. Arguments: name: The attribute's name. annotation: The object's annotation. description: The object's description. \"\"\" super () . __init__ ( annotation , description ) self . name = name","title":"__init__()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter","text":"A helper class to store information about a signature parameter.","title":"Parameter"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.default_string","text":"Return the default value as a string.","title":"default_string"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_args","text":"Tell if this parameter is positional.","title":"is_args"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_kwargs","text":"Tell if this parameter is a keyword.","title":"is_kwargs"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_optional","text":"Tell if this parameter is optional.","title":"is_optional"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_required","text":"Tell if this parameter is required.","title":"is_required"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The parameter's name. required annotation Any The parameter's annotation. required description str The parameter's description. required kind Any The parameter's kind (positional only, keyword only, etc.). required default Any The parameter's default value. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , name : str , annotation : Any , description : str , kind : Any , default : Any = empty ) -> None : \"\"\" Initialize the object. Arguments: name: The parameter's name. annotation: The parameter's annotation. description: The parameter's description. kind: The parameter's kind (positional only, keyword only, etc.). default: The parameter's default value. \"\"\" super () . __init__ ( annotation , description ) self . name = name self . kind = kind self . default = default","title":"__init__()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser","text":"A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. It also return the list of errors that occurred during parsing.","title":"Parser"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.__init__","text":"Initialize the object. Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" self . context : dict = {} self . errors : List [ str ] = []","title":"__init__()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.error","text":"Record a parsing error. Parameters: Name Type Description Default message A message described the error. required Source code in pytkdocs/parsers/docstrings/base.py def error ( self , message ) -> None : \"\"\" Record a parsing error. Arguments: message: A message described the error. \"\"\" if self . context [ \"obj\" ]: message = f \" { self . context [ 'obj' ] . path } : { message } \" self . errors . append ( message )","title":"error()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.parse","text":"Parse a docstring and return a list of sections and parsing errors. Parameters: Name Type Description Default docstring str The docstring to parse. required context Optional[dict] Some context helping to parse the docstring. None Returns: Type Description Tuple[List[pytkdocs.parsers.docstrings.base.Section], List[str]] A tuple containing the list of sections and the parsing errors. Source code in pytkdocs/parsers/docstrings/base.py def parse ( self , docstring : str , context : Optional [ dict ] = None ) -> Tuple [ List [ Section ], List [ str ]]: \"\"\" Parse a docstring and return a list of sections and parsing errors. Arguments: docstring: The docstring to parse. context: Some context helping to parse the docstring. Returns: A tuple containing the list of sections and the parsing errors. \"\"\" self . context = context or {} self . errors = [] sections = self . parse_sections ( docstring ) errors = self . errors return sections , errors","title":"parse()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.parse_sections","text":"Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/base.py @abstractmethod def parse_sections ( self , docstring : str ) -> List [ Section ]: \"\"\" Parse a docstring as a list of sections. Arguments: docstring: The docstring to parse. Returns: A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s. \"\"\" raise NotImplementedError","title":"parse_sections()"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section","text":"A helper class to store a docstring section.","title":"Section"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section.Type","text":"The possible section types.","title":"Type"},{"location":"reference/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section.__init__","text":"Initialize the object. Parameters: Name Type Description Default section_type str The type of the section, from the [ Type ][pytkdocs.parsers.docstrings.base.Section.Type] enum. required value Any The section value. required Source code in pytkdocs/parsers/docstrings/base.py def __init__ ( self , section_type : str , value : Any ) -> None : \"\"\" Initialize the object. Arguments: section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum. value: The section value. \"\"\" self . type = section_type self . value = value","title":"__init__()"},{"location":"reference/parsers/docstrings/google/","text":"\u00a4 This module defines functions and classes to parse docstrings into structured data. RE_GOOGLE_STYLE_ADMONITION: Pattern [ ~ AnyStr ] \u00a4 Regular expressions to match lines starting admonitions, of the form TYPE: [TITLE] . Google \u00a4 A Google-style docstrings parser. __init__ ( self , replace_admonitions = True ) special \u00a4 Initialize the object. Parameters: Name Type Description Default replace_admonitions bool Whether to replace admonitions by their Markdown equivalent. True Source code in pytkdocs/parsers/docstrings/google.py def __init__ ( self , replace_admonitions : bool = True ) -> None : \"\"\" Initialize the object. Arguments: replace_admonitions: Whether to replace admonitions by their Markdown equivalent. \"\"\" super () . __init__ () self . replace_admonitions = replace_admonitions self . section_reader = { Section . Type . PARAMETERS : self . read_parameters_section , Section . Type . EXCEPTIONS : self . read_exceptions_section , Section . Type . EXAMPLES : self . read_examples_section , Section . Type . ATTRIBUTES : self . read_attributes_section , Section . Type . RETURN : self . read_return_section , } parse_sections ( self , docstring ) \u00a4 Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/google.py def parse_sections ( self , docstring : str ) -> List [ Section ]: # noqa: D102 if \"signature\" not in self . context : self . context [ \"signature\" ] = getattr ( self . context [ \"obj\" ], \"signature\" , None ) if \"annotation\" not in self . context : self . context [ \"annotation\" ] = getattr ( self . context [ \"obj\" ], \"type\" , empty ) if \"attributes\" not in self . context : self . context [ \"attributes\" ] = {} sections = [] current_section = [] in_code_block = False lines = docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in SECTIONS_TITLES : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section_reader = self . section_reader [ SECTIONS_TITLES [ line_lower ]] section , i = section_reader ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if self . replace_admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) return sections read_attributes_section ( self , lines , start_index ) \u00a4 Parse an \"attributes\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_attributes_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"attributes\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" attributes = [] block , i = self . read_block_items ( lines , start_index ) for attr_line in block : try : name_with_type , description = attr_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { attr_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] else : name = name_with_type annotation = self . context [ \"attributes\" ] . get ( name , {}) . get ( \"annotation\" , empty ) attributes . append ( Attribute ( name = name , annotation = annotation , description = description )) if attributes : return Section ( Section . Type . ATTRIBUTES , attributes ), i self . error ( f \"Empty attributes section at line { start_index } \" ) return None , i read_block ( self , lines , start_index ) \u00a4 Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[str, int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_block ( self , lines : List [ str ], start_index : int ) -> Tuple [ str , int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return \"\" , start_index i = start_index block : List [ str ] = [] # skip first empty lines while is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , i - 1 # start processing first item block . append ( lines [ i ] . lstrip ()) i += 1 # loop on next lines while i < len ( lines ) and ( lines [ i ] . startswith ( indent * \" \" ) or is_empty_line ( lines [ i ])): block . append ( lines [ i ][ indent :]) i += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), i - 1 read_block_items ( self , lines , start_index ) \u00a4 Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_block_items ( self , lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return [], start_index i = start_index items : List [ str ] = [] # skip first empty lines while is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], i - 1 # start processing first item current_item = [ lines [ i ][ indent :]] i += 1 # loop on next lines while i < len ( lines ): line = lines [ i ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but add error cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) self . error ( f \"Confusing indentation for continuation line { i + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( \" \\n \" . join ( current_item )) current_item = [ line [ indent :]] elif is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) else : # indent lower than initial one: end of section break i += 1 if current_item : items . append ( \" \\n \" . join ( current_item ) . rstrip ( \" \\n \" )) return items , i - 1 read_examples_section ( self , lines , start_index ) \u00a4 Parse an \"examples\" section. Parameters: Name Type Description Default lines List[str] The examples block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_examples_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"examples\" section. Arguments: lines: The examples block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) sub_sections = [] in_code_example = False in_code_block = False current_text : List [ str ] = [] current_example : List [ str ] = [] for line in text . split ( \" \\n \" ): if is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( Section . Type . EXAMPLES , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( Section . Type . MARKDOWN , \" \\n \" . join ( current_text ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( Section . Type . MARKDOWN , \" \\n \" . join ( current_text ))) elif current_example : sub_sections . append (( Section . Type . EXAMPLES , \" \\n \" . join ( current_example ))) return Section ( Section . Type . EXAMPLES , sub_sections ), i read_exceptions_section ( self , lines , start_index ) \u00a4 Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . error ( f \"Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . error ( f \"Empty exceptions section at line { start_index } \" ) return None , i read_parameters_section ( self , lines , start_index ) \u00a4 Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { param_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . context [ \"signature\" ] . parameters [ name . lstrip ( \"*\" )] # type: ignore except ( AttributeError , KeyError ): self . error ( f \"No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description , default = default , kind = kind ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . error ( f \"Empty parameters section at line { start_index } \" ) return None , i read_return_section ( self , lines , start_index ) \u00a4 Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) if self . context [ \"signature\" ]: annotation = self . context [ \"signature\" ] . return_annotation else : annotation = self . context [ \"annotation\" ] if annotation is empty : if text : try : type_ , text = text . split ( \":\" , 1 ) except ValueError : self . error ( \"No type in return description\" ) else : annotation = type_ . lstrip () text = text . lstrip () else : self . error ( \"No return type annotation\" ) if annotation is empty and not text : self . error ( f \"Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , text )), i is_empty_line ( line ) \u00a4 Tell if a line is empty. Parameters: Name Type Description Default line The line to check. required Returns: Type Description bool True if the line is empty or composed of blanks only, False otherwise. Source code in pytkdocs/parsers/docstrings/google.py def is_empty_line ( line ) -> bool : \"\"\" Tell if a line is empty. Arguments: line: The line to check. Returns: True if the line is empty or composed of blanks only, False otherwise. \"\"\" return not line . strip ()","title":"google.py"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google","text":"This module defines functions and classes to parse docstrings into structured data.","title":"pytkdocs.parsers.docstrings.google"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.RE_GOOGLE_STYLE_ADMONITION","text":"Regular expressions to match lines starting admonitions, of the form TYPE: [TITLE] .","title":"RE_GOOGLE_STYLE_ADMONITION"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google","text":"A Google-style docstrings parser.","title":"Google"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.__init__","text":"Initialize the object. Parameters: Name Type Description Default replace_admonitions bool Whether to replace admonitions by their Markdown equivalent. True Source code in pytkdocs/parsers/docstrings/google.py def __init__ ( self , replace_admonitions : bool = True ) -> None : \"\"\" Initialize the object. Arguments: replace_admonitions: Whether to replace admonitions by their Markdown equivalent. \"\"\" super () . __init__ () self . replace_admonitions = replace_admonitions self . section_reader = { Section . Type . PARAMETERS : self . read_parameters_section , Section . Type . EXCEPTIONS : self . read_exceptions_section , Section . Type . EXAMPLES : self . read_examples_section , Section . Type . ATTRIBUTES : self . read_attributes_section , Section . Type . RETURN : self . read_return_section , }","title":"__init__()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.parse_sections","text":"Parse a docstring as a list of sections. Parameters: Name Type Description Default docstring str The docstring to parse. required Returns: Type Description List[pytkdocs.parsers.docstrings.base.Section] A list of [ Section ][pytkdocs.parsers.docstrings.base.Section]s. Source code in pytkdocs/parsers/docstrings/google.py def parse_sections ( self , docstring : str ) -> List [ Section ]: # noqa: D102 if \"signature\" not in self . context : self . context [ \"signature\" ] = getattr ( self . context [ \"obj\" ], \"signature\" , None ) if \"annotation\" not in self . context : self . context [ \"annotation\" ] = getattr ( self . context [ \"obj\" ], \"type\" , empty ) if \"attributes\" not in self . context : self . context [ \"attributes\" ] = {} sections = [] current_section = [] in_code_block = False lines = docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in SECTIONS_TITLES : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) current_section = [] section_reader = self . section_reader [ SECTIONS_TITLES [ line_lower ]] section , i = section_reader ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if self . replace_admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , \" \\n \" . join ( current_section ))) return sections","title":"parse_sections()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_attributes_section","text":"Parse an \"attributes\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_attributes_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"attributes\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" attributes = [] block , i = self . read_block_items ( lines , start_index ) for attr_line in block : try : name_with_type , description = attr_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { attr_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , annotation = name_with_type . split ( \" \" , 1 ) annotation = annotation . strip ( \"()\" ) if annotation . endswith ( \", optional\" ): annotation = annotation [: - 10 ] else : name = name_with_type annotation = self . context [ \"attributes\" ] . get ( name , {}) . get ( \"annotation\" , empty ) attributes . append ( Attribute ( name = name , annotation = annotation , description = description )) if attributes : return Section ( Section . Type . ATTRIBUTES , attributes ), i self . error ( f \"Empty attributes section at line { start_index } \" ) return None , i","title":"read_attributes_section()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_block","text":"Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[str, int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_block ( self , lines : List [ str ], start_index : int ) -> Tuple [ str , int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return \"\" , start_index i = start_index block : List [ str ] = [] # skip first empty lines while is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return \"\" , i - 1 # start processing first item block . append ( lines [ i ] . lstrip ()) i += 1 # loop on next lines while i < len ( lines ) and ( lines [ i ] . startswith ( indent * \" \" ) or is_empty_line ( lines [ i ])): block . append ( lines [ i ][ indent :]) i += 1 return \" \\n \" . join ( block ) . rstrip ( \" \\n \" ), i - 1","title":"read_block()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_block_items","text":"Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_block_items ( self , lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. The first indentation level is used as a reference to determine if the next lines are new items or continuation lines. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" if start_index >= len ( lines ): return [], start_index i = start_index items : List [ str ] = [] # skip first empty lines while is_empty_line ( lines [ i ]): i += 1 # get initial indent indent = len ( lines [ i ]) - len ( lines [ i ] . lstrip ()) if indent == 0 : # first non-empty line was not indented, abort return [], i - 1 # start processing first item current_item = [ lines [ i ][ indent :]] i += 1 # loop on next lines while i < len ( lines ): line = lines [ i ] if line . startswith ( indent * 2 * \" \" ): # continuation line current_item . append ( line [ indent * 2 :]) elif line . startswith (( indent + 1 ) * \" \" ): # indent between initial and continuation: append but add error cont_indent = len ( line ) - len ( line . lstrip ()) current_item . append ( line [ cont_indent :]) self . error ( f \"Confusing indentation for continuation line { i + 1 } in docstring, \" f \"should be { indent } * 2 = { indent * 2 } spaces, not { cont_indent } \" ) elif line . startswith ( indent * \" \" ): # indent equal to initial one: new item items . append ( \" \\n \" . join ( current_item )) current_item = [ line [ indent :]] elif is_empty_line ( line ): # empty line: preserve it in the current item current_item . append ( \"\" ) else : # indent lower than initial one: end of section break i += 1 if current_item : items . append ( \" \\n \" . join ( current_item ) . rstrip ( \" \\n \" )) return items , i - 1","title":"read_block_items()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_examples_section","text":"Parse an \"examples\" section. Parameters: Name Type Description Default lines List[str] The examples block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_examples_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"examples\" section. Arguments: lines: The examples block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) sub_sections = [] in_code_example = False in_code_block = False current_text : List [ str ] = [] current_example : List [ str ] = [] for line in text . split ( \" \\n \" ): if is_empty_line ( line ): if in_code_example : if current_example : sub_sections . append (( Section . Type . EXAMPLES , \" \\n \" . join ( current_example ))) current_example = [] in_code_example = False else : current_text . append ( line ) elif in_code_example : current_example . append ( line ) elif line . startswith ( \"```\" ): in_code_block = not in_code_block current_text . append ( line ) elif in_code_block : current_text . append ( line ) elif line . startswith ( \">>>\" ): if current_text : sub_sections . append (( Section . Type . MARKDOWN , \" \\n \" . join ( current_text ))) current_text = [] in_code_example = True current_example . append ( line ) else : current_text . append ( line ) if current_text : sub_sections . append (( Section . Type . MARKDOWN , \" \\n \" . join ( current_text ))) elif current_example : sub_sections . append (( Section . Type . EXAMPLES , \" \\n \" . join ( current_example ))) return Section ( Section . Type . EXAMPLES , sub_sections ), i","title":"read_examples_section()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_exceptions_section","text":"Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . error ( f \"Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . error ( f \"Empty exceptions section at line { start_index } \" ) return None , i","title":"read_exceptions_section()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_parameters_section","text":"Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . split ( \":\" , 1 ) except ValueError : self . error ( f \"Failed to get 'name: description' pair from ' { param_line } '\" ) continue description = description . lstrip () if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . context [ \"signature\" ] . parameters [ name . lstrip ( \"*\" )] # type: ignore except ( AttributeError , KeyError ): self . error ( f \"No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description , default = default , kind = kind ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . error ( f \"Empty parameters section at line { start_index } \" ) return None , i","title":"read_parameters_section()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_return_section","text":"Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.base.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings/google.py def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" text , i = self . read_block ( lines , start_index ) if self . context [ \"signature\" ]: annotation = self . context [ \"signature\" ] . return_annotation else : annotation = self . context [ \"annotation\" ] if annotation is empty : if text : try : type_ , text = text . split ( \":\" , 1 ) except ValueError : self . error ( \"No type in return description\" ) else : annotation = type_ . lstrip () text = text . lstrip () else : self . error ( \"No return type annotation\" ) if annotation is empty and not text : self . error ( f \"Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , text )), i","title":"read_return_section()"},{"location":"reference/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.is_empty_line","text":"Tell if a line is empty. Parameters: Name Type Description Default line The line to check. required Returns: Type Description bool True if the line is empty or composed of blanks only, False otherwise. Source code in pytkdocs/parsers/docstrings/google.py def is_empty_line ( line ) -> bool : \"\"\" Tell if a line is empty. Arguments: line: The line to check. Returns: True if the line is empty or composed of blanks only, False otherwise. \"\"\" return not line . strip ()","title":"is_empty_line()"}]}