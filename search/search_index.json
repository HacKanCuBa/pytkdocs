{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytkdocs Load Python objects documentation. Requirements pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Installation With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs Usage pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"my_module.my_class\" , \"members\" : true , \"filters\" : [ \"!^_[^_]\" ] } ] } Configuration The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only.","title":"Overview"},{"location":"#pytkdocs","text":"Load Python objects documentation.","title":"pytkdocs"},{"location":"#requirements","text":"pytkdocs requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install pytkdocs With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 pytkdocs","title":"Installation"},{"location":"#usage","text":"pytkdocs accepts JSON on standard input and writes JSON on standard output. Input format: { \"objects\" : [ { \"path\" : \"my_module.my_class\" , \"members\" : true , \"filters\" : [ \"!^_[^_]\" ] } ] }","title":"Usage"},{"location":"#configuration","text":"The configuration options available are: filters : filters are regular expressions that allow to select or un-select objects based on their name. They are applied recursively (on every child of every object). If the expression starts with an exclamation mark, it will filter out objects matching it (the exclamation mark is removed before evaluation). If not, objects matching it are selected. Every regular expression is performed against every name. It allows fine-grained filtering. Example: !^_ : filter out every object whose name starts with _ (private/protected) ^__ : but still select those who start with two _ (class-private) !^__.*__$ : except those who also end with two _ (specials) members : this option allows to explicitly select the members of the top-object. If True , select every members that passes filters. If False , select nothing. If it's a list of names, select only those members, and apply filters on their children only.","title":"Configuration"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v0.2.1 - 2020-04-07 Compare with v0.2.0 Bug Fixes Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16 v0.2.0 - 2020-03-27 Compare with v0.1.2 Added Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ). Changed The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors , v0.1.2 - 2020-03-23 Compare with v0.1.1 Fixed Catch error when trying to get builtins module file path ( 48df6bc ). v0.1.1 - 2020-03-21 Compare with v0.1.0 Fixed Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ). v0.1.0 - 2020-03-20 Compare with first commit Added Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v021-2020-04-07","text":"Compare with v0.2.0","title":"v0.2.1 - 2020-04-07"},{"location":"changelog/#bug-fixes","text":"Fix forward refs replacement for python > 3.6 ( 6a90aca by Timoth\u00e9e Mazzucotelli). Handle exception parsing error ( d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16","title":"Bug Fixes"},{"location":"changelog/#v020-2020-03-27","text":"Compare with v0.1.2","title":"v0.2.0 - 2020-03-27"},{"location":"changelog/#added","text":"Add members and filters options ( 7af68cc ). Read type annotations in docstrings. Add modules' source code to the output ( f05290b ).","title":"Added"},{"location":"changelog/#changed","text":"The code was refactored for readability and robustness ( ef9ba9d ). This is a breaking change as some items in the JSON output have changed: the object signature value was moved from obj.docstring.signature to obj.signature , the docstring sections value was moved from obj.docstring.sections to obj.docstring_sections , the docstring parsing_errors value was moved from obj.docstring.parsing_errors to obj.docstring_errors ,","title":"Changed"},{"location":"changelog/#v012-2020-03-23","text":"Compare with v0.1.1","title":"v0.1.2 - 2020-03-23"},{"location":"changelog/#fixed","text":"Catch error when trying to get builtins module file path ( 48df6bc ).","title":"Fixed"},{"location":"changelog/#v011-2020-03-21","text":"Compare with v0.1.0","title":"v0.1.1 - 2020-03-21"},{"location":"changelog/#fixed_1","text":"Fix 'no parsing_errors attribute in Docstring' error ( 0c8a986 ). Handle KeyError when searching for param type annotation in signature ( b87fe78 ).","title":"Fixed"},{"location":"changelog/#v010-2020-03-20","text":"Compare with first commit","title":"v0.1.0 - 2020-03-20"},{"location":"changelog/#added_1","text":"Initial contents, moved from mkdocstrings and tweaked a bit.","title":"Added"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible. Bug fixes, new features and documentation This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . 1. When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) 1. Push; 1. ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible.","title":"Contributing"},{"location":"contributing/#bug-fixes-new-features-and-documentation","text":"This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . 1. When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) 1. Push; 1. ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Bug fixes, new features and documentation"},{"location":"credits/","text":"Credits These projects were used to build pytkdocs . Thank you! python | poetry | cookie-poetry Direct dependencies bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety Indirect dependencies apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | toml | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build pytkdocs . Thank you! python | poetry | cookie-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | toml | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Indirect dependencies"},{"location":"developers/test_suite/__init__/","text":"","title":"__init__.py"},{"location":"developers/test_suite/conftest/","text":"","title":"conftest.py"},{"location":"developers/test_suite/test_cli/","text":"","title":"test_cli.py"},{"location":"developers/test_suite/test_loader/","text":"","title":"test_loader.py"},{"location":"developers/test_suite/test_objects/","text":"","title":"test_objects.py"},{"location":"developers/test_suite/test_properties/","text":"","title":"test_properties.py"},{"location":"developers/test_suite/test_serializer/","text":"","title":"test_serializer.py"},{"location":"developers/test_suite/fixtures/inheriting_enum_Enum/","text":"","title":"inheriting_enum_Enum.py"},{"location":"developers/test_suite/fixtures/inheriting_typing_NamedTuple/","text":"","title":"inheriting_typing_NamedTuple.py"},{"location":"developers/test_suite/fixtures/nested_class/","text":"","title":"nested_class.py"},{"location":"developers/test_suite/fixtures/no_contents/","text":"","title":"no_contents"},{"location":"developers/test_suite/fixtures/parsing/","text":"","title":"parsing"},{"location":"developers/test_suite/fixtures/pkg1/","text":"","title":"pkg1"},{"location":"developers/test_suite/fixtures/real_path/","text":"","title":"real_path"},{"location":"developers/test_suite/fixtures/the_package/","text":"","title":"the_package"},{"location":"developers/test_suite/test_parsers/test_attributes/","text":"","title":"test_attributes.py"},{"location":"developers/test_suite/test_parsers/test_docstrings/","text":"","title":"test_docstrings.py"},{"location":"reference/__init__/","text":"pytkdocs package. Load Python objects documentation.","title":"__init__.py"},{"location":"reference/__init__/#pytkdocs.__init__","text":"pytkdocs package. Load Python objects documentation.","title":"pytkdocs.__init__"},{"location":"reference/__main__/","text":"Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/2/using/cmdline.html#cmdoption-m https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"__main__.py"},{"location":"reference/__main__/#pytkdocs.__main__","text":"Entry-point module, in case you use python -m pytkdocs . Why does this file exist, and why __main__ ? For more info, read: https://www.python.org/dev/peps/pep-0338/ https://docs.python.org/2/using/cmdline.html#cmdoption-m https://docs.python.org/3/using/cmdline.html#cmdoption-m","title":"pytkdocs.__main__"},{"location":"reference/cli/","text":"This module contains the command line application. Why does this file exist, and why not put this in __main__ ? You might be tempted to import things from main later, but that will cause problems; the code will get executed twice: When you run python -m pytkdocs python will execute __main__.py as a script. That means there won't be any pytkdocs.__main__ in sys.modules . When you import main it will get executed again (as a module) because there's no pytkdocs.__main__ in sys.modules . Also see http://click.pocoo.org/5/setuptools/#setuptools-integration. extract_docstring_parsing_errors ( errors , o ) Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required o Object The object. required Source code in pytkdocs/cli.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def extract_docstring_parsing_errors ( errors : dict , o : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. o: The object. \"\"\" if hasattr ( o , \"docstring_errors\" ): errors [ o . path ] = o . docstring_errors for child in o . children : extract_docstring_parsing_errors ( errors , child ) extract_errors ( obj ) Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py 135 136 137 138 139 140 141 142 143 144 145 146 147 def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors get_parser () Return the program argument parser. Source code in pytkdocs/cli.py 150 151 152 153 154 155 156 157 158 159 160 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser main ( args = None ) The main function, which is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[Sequence[str]] The list of arguments. None Returns: Type Description int An exit code between 0 and 255. Source code in pytkdocs/cli.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def main ( args : Optional [ Sequence [ str ]] = None ) -> int : \"\"\" The main function, which is executed when you type `pytkdocs` or `python -m pytkdocs`. Parameters: args: The list of arguments. Returns: An exit code between 0 and 255. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : try : print ( json . dumps ( process_json ( line ))) except Exception as error : # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. print ( json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()})) else : print ( json . dumps ( process_json ( sys . stdin . read ()))) return 0 process_config ( config ) Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) filters = obj_config . get ( \"filters\" , []) members = obj_config . get ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( filters = filters ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return dict ( loading_errors = loading_errors , parsing_errors = parsing_errors , objects = collected ) process_json ( json_input ) Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"cli.py"},{"location":"reference/cli/#pytkdocs.cli","text":"This module contains the command line application. Why does this file exist, and why not put this in __main__ ? You might be tempted to import things from main later, but that will cause problems; the code will get executed twice: When you run python -m pytkdocs python will execute __main__.py as a script. That means there won't be any pytkdocs.__main__ in sys.modules . When you import main it will get executed again (as a module) because there's no pytkdocs.__main__ in sys.modules . Also see http://click.pocoo.org/5/setuptools/#setuptools-integration.","title":"pytkdocs.cli"},{"location":"reference/cli/#pytkdocs.cli.extract_docstring_parsing_errors","text":"Recursion helper. Update the errors dictionary by side-effect. Recurse on the object's children. Parameters: Name Type Description Default errors dict The dictionary to update. required o Object The object. required Source code in pytkdocs/cli.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def extract_docstring_parsing_errors ( errors : dict , o : Object ) -> None : \"\"\" Recursion helper. Update the `errors` dictionary by side-effect. Recurse on the object's children. Arguments: errors: The dictionary to update. o: The object. \"\"\" if hasattr ( o , \"docstring_errors\" ): errors [ o . path ] = o . docstring_errors for child in o . children : extract_docstring_parsing_errors ( errors , child )","title":"extract_docstring_parsing_errors()"},{"location":"reference/cli/#pytkdocs.cli.extract_errors","text":"Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Parameters: Name Type Description Default obj Object An object from pytkdocs.objects . required Returns: Type Description dict A flat dictionary. Keys are the objects' names. Source code in pytkdocs/cli.py 135 136 137 138 139 140 141 142 143 144 145 146 147 def extract_errors ( obj : Object ) -> dict : \"\"\" Extract the docstring parsing errors of each object, recursively, into a flat dictionary. Arguments: obj: An object from `pytkdocs.objects`. Returns: A flat dictionary. Keys are the objects' names. \"\"\" parsing_errors : Dict [ str , List [ str ]] = {} extract_docstring_parsing_errors ( parsing_errors , obj ) return parsing_errors","title":"extract_errors()"},{"location":"reference/cli/#pytkdocs.cli.get_parser","text":"Return the program argument parser. Source code in pytkdocs/cli.py 150 151 152 153 154 155 156 157 158 159 160 def get_parser () -> argparse . ArgumentParser : \"\"\"Return the program argument parser.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-1\" , \"--line-by-line\" , action = \"store_true\" , dest = \"line_by_line\" , help = \"Process each line read on stdin, one by one.\" , ) return parser","title":"get_parser()"},{"location":"reference/cli/#pytkdocs.cli.main","text":"The main function, which is executed when you type pytkdocs or python -m pytkdocs . Parameters: Name Type Description Default args Optional[Sequence[str]] The list of arguments. None Returns: Type Description int An exit code between 0 and 255. Source code in pytkdocs/cli.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def main ( args : Optional [ Sequence [ str ]] = None ) -> int : \"\"\" The main function, which is executed when you type `pytkdocs` or `python -m pytkdocs`. Parameters: args: The list of arguments. Returns: An exit code between 0 and 255. \"\"\" parser = get_parser () parsed_args : argparse . Namespace = parser . parse_args ( args ) # type: ignore if parsed_args . line_by_line : for line in sys . stdin : try : print ( json . dumps ( process_json ( line ))) except Exception as error : # Don't fail on error. We must handle the next inputs. # Instead, print error as JSON. print ( json . dumps ({ \"error\" : str ( error ), \"traceback\" : traceback . format_exc ()})) else : print ( json . dumps ( process_json ( sys . stdin . read ()))) return 0","title":"main()"},{"location":"reference/cli/#pytkdocs.cli.process_config","text":"Process a loading configuration. The config argument is a dictionary looking like this: { \"objects\" : [ { \"path\" : \"python.dotted.path.to.the.object1\" }, { \"path\" : \"python.dotted.path.to.the.object2\" } ] } The result is a dictionary looking like this: { \"loading_errors\" : [ \"message1\" , \"message2\" , ], \"parsing_errors\" : { \"path.to.object1\" : [ \"message1\" , \"message2\" , ], \"path.to.object2\" : [ \"message1\" , \"message2\" , ] }, \"objects\" : [ { \"path\" : \"path.to.object1\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\" : \"path.to.object2\" , # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } Parameters: Name Type Description Default config dict The configuration. required Returns: Type Description dict The collected documentation along with the errors that occurred. Source code in pytkdocs/cli.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def process_config ( config : dict ) -> dict : \"\"\" Process a loading configuration. The `config` argument is a dictionary looking like this: ```python { \"objects\": [ {\"path\": \"python.dotted.path.to.the.object1\"}, {\"path\": \"python.dotted.path.to.the.object2\"} ] } ``` The result is a dictionary looking like this: ```python { \"loading_errors\": [ \"message1\", \"message2\", ], \"parsing_errors\": { \"path.to.object1\": [ \"message1\", \"message2\", ], \"path.to.object2\": [ \"message1\", \"message2\", ] }, \"objects\": [ { \"path\": \"path.to.object1\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, { \"path\": \"path.to.object2\", # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer` }, ] } ``` Arguments: config: The configuration. Returns: The collected documentation along with the errors that occurred. \"\"\" collected = [] loading_errors = [] parsing_errors = {} for obj_config in config [ \"objects\" ]: path = obj_config . pop ( \"path\" ) filters = obj_config . get ( \"filters\" , []) members = obj_config . get ( \"members\" , set ()) if isinstance ( members , list ): members = set ( members ) loader = Loader ( filters = filters ) obj = loader . get_object_documentation ( path , members ) loading_errors . extend ( loader . errors ) parsing_errors . update ( extract_errors ( obj )) serialized_obj = serialize_object ( obj ) collected . append ( serialized_obj ) return dict ( loading_errors = loading_errors , parsing_errors = parsing_errors , objects = collected )","title":"process_config()"},{"location":"reference/cli/#pytkdocs.cli.process_json","text":"Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [ process_config ][pytkdocs.cli.process_config]. Parameters: Name Type Description Default json_input str The JSON to load. required Returns: Type Description dict The result of the call to [ process_config ][pytkdocs.cli.process_config]. Source code in pytkdocs/cli.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def process_json ( json_input : str ) -> dict : \"\"\" Process JSON input. Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config]. Arguments: json_input: The JSON to load. Returns: The result of the call to [`process_config`][pytkdocs.cli.process_config]. \"\"\" return process_config ( json . loads ( json_input ))","title":"process_json()"},{"location":"reference/loader/","text":"This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc. Loader This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list. __init__ ( self , filters = None ) special Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None Source code in pytkdocs/loader.py 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , filters : Optional [ List [ str ]] = None ): \"\"\" Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. \"\"\" if not filters : filters = [] self . filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in filters ] self . errors : List [ str ] = [] get_class_documentation ( self , node , members = None ) Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 def get_class_documentation ( self , node : ObjectNode , members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. members: Explicit members to select. Return: The documented class object. \"\"\" class_ = node . obj docstring = textwrap . dedent ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) if members is False : return root_object members = members or set () for member_name , member in class_ . __dict__ . items (): if member is type or member is object : continue if not self . select ( member_name , members ): # type: ignore continue child_node = ObjectNode ( getattr ( class_ , member_name ), member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_classmethod (): root_object . add_child ( self . get_classmethod_documentation ( child_node )) elif child_node . is_staticmethod (): root_object . add_child ( self . get_staticmethod_documentation ( child_node )) elif child_node . is_method (): root_object . add_child ( self . get_regular_method_documentation ( child_node )) elif child_node . is_property (): root_object . add_child ( self . get_property_documentation ( child_node )) return root_object get_classmethod_documentation ( self , node ) Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 418 419 420 421 422 423 424 425 426 427 428 def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ]) get_function_documentation ( self , node ) Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Return: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , ) get_method_documentation ( self , node , properties = None ) Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Return: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , ) get_module_documentation ( self , node , members = None ) Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_module_documentation ( self , node : ObjectNode , members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. members: Explicit members to select. Return: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : with Path ( node . file_path ) . open () as fd : contents = fd . readlines () if contents : source = Source ( contents , 1 ) else : source = None except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ) or \"\" , source = source , ) if members is False : return root_object members = members or set () for member_name , member in inspect . getmembers ( module ): if self . select ( member_name , members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class () and child_node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function () and child_node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_function_documentation ( child_node )) try : package_path = module . __path__ except AttributeError : pass else : for _ , modname , _ in pkgutil . iter_modules ( package_path ): if self . select ( modname , members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object get_object_documentation ( self , dotted_path , members = None ) Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Optional[Union[Set[str], bool]] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Return: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) attributes = get_attributes ( leaf . root . obj ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : for attribute in attributes : if attribute . path == dotted_path : return attribute raise ValueError ( f \" { dotted_path } : { type ( leaf . obj ) } not yet supported\" ) if members is not False : filtered = [] for attribute in attributes : if attribute . parent_path == root_object . path : if self . select ( attribute . name , members ): # type: ignore filtered . append ( attribute ) elif self . select ( attribute . name , set ()): filtered . append ( attribute ) root_object . dispatch_attributes ( filtered ) root_object . parse_all_docstring () return root_object get_property_documentation ( self , node ) Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , ) get_regular_method_documentation ( self , node ) Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Return: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method get_staticmethod_documentation ( self , node ) Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 430 431 432 433 434 435 436 437 438 439 440 def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ]) select ( self , name , names ) Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name ) ObjectNode Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node. dotted_path: str property readonly The Python dotted path of the object. file_path: str property readonly The object's module file path. name: str The Python object's name. obj: Any The actual Python object. parent: Optional [ ObjectNode ] The parent node. root: ObjectNode property readonly The root of the tree. is_class ( self ) Is this node's object a class? Source code in pytkdocs/loader.py 68 69 70 def is_class ( self ) -> bool : \"\"\"Is this node's object a class?\"\"\" return inspect . isclass ( self . obj ) is_classmethod ( self ) Is this node's object a classmethod? Source code in pytkdocs/loader.py 94 95 96 97 98 def is_classmethod ( self ) -> bool : \"\"\"Is this node's object a classmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod ) is_function ( self ) Is this node's object a function? Source code in pytkdocs/loader.py 72 73 74 def is_function ( self ) -> bool : \"\"\"Is this node's object a function?\"\"\" return inspect . isfunction ( self . obj ) is_method ( self ) Is this node's object a method? Source code in pytkdocs/loader.py 84 85 86 def is_method ( self ) -> bool : \"\"\"Is this node's object a method?\"\"\" return self . parent_is_class () and isinstance ( self . obj , type ( lambda : 0 )) is_module ( self ) Is this node's object a module? Source code in pytkdocs/loader.py 64 65 66 def is_module ( self ) -> bool : \"\"\"Is this node's object a module?\"\"\" return inspect . ismodule ( self . obj ) is_property ( self ) Is this node's object a property? Source code in pytkdocs/loader.py 76 77 78 def is_property ( self ) -> bool : \"\"\"Is this node's object a property?\"\"\" return isinstance ( self . obj , property ) is_staticmethod ( self ) Is this node's object a staticmethod? Source code in pytkdocs/loader.py 88 89 90 91 92 def is_staticmethod ( self ) -> bool : \"\"\"Is this node's object a staticmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod ) parent_is_class ( self ) Is the object of this node's parent a class? Source code in pytkdocs/loader.py 80 81 82 def parent_is_class ( self ) -> bool : \"\"\"Is the object of this node's parent a class?\"\"\" return bool ( self . parent and self . parent . is_class ()) get_object_tree ( path ) Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) current_node . child = ObjectNode ( obj , obj_name , parent = current_node ) # type: ignore current_node = current_node . child # type: ignore leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"loader.py"},{"location":"reference/loader/#pytkdocs.loader","text":"This module is responsible for loading the documentation from Python objects. It uses inspect for introspecting objects, iterating over their members, etc.","title":"pytkdocs.loader"},{"location":"reference/loader/#pytkdocs.loader.Loader","text":"This class contains the object documentation loading mechanisms. Any error that occurred during collection of the objects and their documentation is stored in the errors list.","title":"Loader"},{"location":"reference/loader/#pytkdocs.loader.Loader.__init__","text":"Parameters: Name Type Description Default filters Optional[List[str]] A list of regular expressions to fine-grain select members. It is applied recursively. None Source code in pytkdocs/loader.py 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , filters : Optional [ List [ str ]] = None ): \"\"\" Arguments: filters: A list of regular expressions to fine-grain select members. It is applied recursively. \"\"\" if not filters : filters = [] self . filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in filters ] self . errors : List [ str ] = []","title":"__init__()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_class_documentation","text":"Get the documentation for a class and its children. Parameters: Name Type Description Default node ObjectNode The node representing the class and its parents. required members Explicit members to select. None Returns: Type Description Class The documented class object. Source code in pytkdocs/loader.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 def get_class_documentation ( self , node : ObjectNode , members = None ) -> Class : \"\"\" Get the documentation for a class and its children. Arguments: node: The node representing the class and its parents. members: Explicit members to select. Return: The documented class object. \"\"\" class_ = node . obj docstring = textwrap . dedent ( class_ . __doc__ or \"\" ) root_object = Class ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = docstring ) if members is False : return root_object members = members or set () for member_name , member in class_ . __dict__ . items (): if member is type or member is object : continue if not self . select ( member_name , members ): # type: ignore continue child_node = ObjectNode ( getattr ( class_ , member_name ), member_name , parent = node ) if child_node . is_class (): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_classmethod (): root_object . add_child ( self . get_classmethod_documentation ( child_node )) elif child_node . is_staticmethod (): root_object . add_child ( self . get_staticmethod_documentation ( child_node )) elif child_node . is_method (): root_object . add_child ( self . get_regular_method_documentation ( child_node )) elif child_node . is_property (): root_object . add_child ( self . get_property_documentation ( child_node )) return root_object","title":"get_class_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_classmethod_documentation","text":"Get the documentation for a class-method. Parameters: Name Type Description Default node ObjectNode The node representing the class-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 418 419 420 421 422 423 424 425 426 427 428 def get_classmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a class-method. Arguments: node: The node representing the class-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"classmethod\" ])","title":"get_classmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_function_documentation","text":"Get the documentation for a function. Parameters: Name Type Description Default node ObjectNode The node representing the function and its parents. required Returns: Type Description Function The documented function object. Source code in pytkdocs/loader.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def get_function_documentation ( self , node : ObjectNode ) -> Function : \"\"\" Get the documentation for a function. Arguments: node: The node representing the function and its parents. Return: The documented function object. \"\"\" function = node . obj path = node . dotted_path source : Optional [ Source ] signature : Optional [ inspect . Signature ] try : signature = inspect . signature ( function ) except TypeError as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) signature = None try : source = Source ( * inspect . getsourcelines ( function )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None return Function ( name = node . name , path = node . dotted_path , file_path = node . file_path , docstring = inspect . getdoc ( function ), signature = signature , source = source , )","title":"get_function_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_method_documentation","text":"Get the documentation for a method. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required properties Optional[List[str]] A list of properties to apply to the method. None Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 def get_method_documentation ( self , node : ObjectNode , properties : Optional [ List [ str ]] = None ) -> Method : \"\"\" Get the documentation for a method. Arguments: node: The node representing the method and its parents. properties: A list of properties to apply to the method. Return: The documented method object. \"\"\" method = node . obj path = node . dotted_path source : Optional [ Source ] try : source = Source ( * inspect . getsourcelines ( method )) except OSError as error : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None except TypeError : source = None return Method ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( method ), signature = inspect . signature ( method ), properties = properties or [], source = source , )","title":"get_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_module_documentation","text":"Get the documentation for a module and its children. Parameters: Name Type Description Default node ObjectNode The node representing the module and its parents. required members Explicit members to select. None Returns: Type Description Module The documented module object. Source code in pytkdocs/loader.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_module_documentation ( self , node : ObjectNode , members = None ) -> Module : \"\"\" Get the documentation for a module and its children. Arguments: node: The node representing the module and its parents. members: Explicit members to select. Return: The documented module object. \"\"\" module = node . obj path = node . dotted_path name = path . split ( \".\" )[ - 1 ] source : Optional [ Source ] try : source = Source ( inspect . getsource ( module ), 1 ) except OSError as error : try : with Path ( node . file_path ) . open () as fd : contents = fd . readlines () if contents : source = Source ( contents , 1 ) else : source = None except OSError : self . errors . append ( f \"Couldn't read source for ' { path } ': { error } \" ) source = None root_object = Module ( name = name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( module ) or \"\" , source = source , ) if members is False : return root_object members = members or set () for member_name , member in inspect . getmembers ( module ): if self . select ( member_name , members ): # type: ignore child_node = ObjectNode ( member , member_name , parent = node ) if child_node . is_class () and child_node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_class_documentation ( child_node )) elif child_node . is_function () and child_node . root . obj is inspect . getmodule ( member ): root_object . add_child ( self . get_function_documentation ( child_node )) try : package_path = module . __path__ except AttributeError : pass else : for _ , modname , _ in pkgutil . iter_modules ( package_path ): if self . select ( modname , members ): leaf = get_object_tree ( f \" { path } . { modname } \" ) root_object . add_child ( self . get_module_documentation ( leaf )) return root_object","title":"get_module_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_object_documentation","text":"Get the documentation for an object and its children. Parameters: Name Type Description Default dotted_path str The Python dotted path to the desired object. required members Optional[Union[Set[str], bool]] True to select members and filter them, False to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. None Returns: Type Description Object The documented object. Source code in pytkdocs/loader.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_object_documentation ( self , dotted_path : str , members : Optional [ Union [ Set [ str ], bool ]] = None ) -> Object : \"\"\" Get the documentation for an object and its children. Arguments: dotted_path: The Python dotted path to the desired object. members: `True` to select members and filter them, `False` to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object. Return: The documented object. \"\"\" if members is True : members = set () root_object : Object leaf = get_object_tree ( dotted_path ) attributes = get_attributes ( leaf . root . obj ) if leaf . is_module (): root_object = self . get_module_documentation ( leaf , members ) elif leaf . is_class (): root_object = self . get_class_documentation ( leaf , members ) elif leaf . is_staticmethod (): root_object = self . get_staticmethod_documentation ( leaf ) elif leaf . is_classmethod (): root_object = self . get_classmethod_documentation ( leaf ) elif leaf . is_method (): root_object = self . get_regular_method_documentation ( leaf ) elif leaf . is_function (): root_object = self . get_function_documentation ( leaf ) elif leaf . is_property (): root_object = self . get_property_documentation ( leaf ) else : for attribute in attributes : if attribute . path == dotted_path : return attribute raise ValueError ( f \" { dotted_path } : { type ( leaf . obj ) } not yet supported\" ) if members is not False : filtered = [] for attribute in attributes : if attribute . parent_path == root_object . path : if self . select ( attribute . name , members ): # type: ignore filtered . append ( attribute ) elif self . select ( attribute . name , set ()): filtered . append ( attribute ) root_object . dispatch_attributes ( filtered ) root_object . parse_all_docstring () return root_object","title":"get_object_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_property_documentation","text":"Get the documentation for an attribute. Parameters: Name Type Description Default node ObjectNode The node representing the attribute and its parents. required Returns: Type Description Attribute The documented attribute object. Source code in pytkdocs/loader.py 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def get_property_documentation ( self , node : ObjectNode ) -> Attribute : \"\"\" Get the documentation for an attribute. Arguments: node: The node representing the attribute and its parents. Return: The documented attribute object. \"\"\" prop = node . obj path = node . dotted_path properties = [ \"property\" , \"readonly\" if prop . fset is None else \"writable\" ] source : Optional [ Source ] try : signature = inspect . signature ( prop . fget ) except ( TypeError , ValueError ) as error : self . errors . append ( f \"Couldn't get signature for ' { path } ': { error } \" ) attr_type = None else : attr_type = signature . return_annotation try : source = Source ( * inspect . getsourcelines ( prop . fget )) except ( OSError , TypeError ) as error : self . errors . append ( f \"Couldn't get source for ' { path } ': { error } \" ) source = None return Attribute ( name = node . name , path = path , file_path = node . file_path , docstring = inspect . getdoc ( prop . fget ), attr_type = attr_type , properties = properties , source = source , )","title":"get_property_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_regular_method_documentation","text":"Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of __init__ methods that were inherited from parent classes. Parameters: Name Type Description Default node ObjectNode The node representing the method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def get_regular_method_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a regular method (not class- nor static-method). We do extra processing in this method to discard docstrings of `__init__` methods that were inherited from parent classes. Arguments: node: The node representing the method and its parents. Return: The documented method object. \"\"\" method = self . get_method_documentation ( node ) if node . parent : class_ = node . parent . obj if RE_SPECIAL . match ( node . name ): docstring = method . docstring parent_classes = class_ . __mro__ [ 1 :] for parent_class in parent_classes : try : parent_method = getattr ( parent_class , node . name ) except AttributeError : continue else : if docstring == inspect . getdoc ( parent_method ): method . docstring = \"\" break return method","title":"get_regular_method_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.get_staticmethod_documentation","text":"Get the documentation for a static-method. Parameters: Name Type Description Default node ObjectNode The node representing the static-method and its parents. required Returns: Type Description Method The documented method object. Source code in pytkdocs/loader.py 430 431 432 433 434 435 436 437 438 439 440 def get_staticmethod_documentation ( self , node : ObjectNode ) -> Method : \"\"\" Get the documentation for a static-method. Arguments: node: The node representing the static-method and its parents. Return: The documented method object. \"\"\" return self . get_method_documentation ( node , [ \"staticmethod\" ])","title":"get_staticmethod_documentation()"},{"location":"reference/loader/#pytkdocs.loader.Loader.select","text":"Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Parameters: Name Type Description Default name str The name of the object to select or not. required names Set[str] An explicit list of names to select. required Returns: Type Description bool Yes or no. Source code in pytkdocs/loader.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 def select ( self , name : str , names : Set [ str ]) -> bool : \"\"\" Tells whether we should select an object or not, given its name. If the set of names is not empty, we check against it, otherwise we check against filters. Arguments: name: The name of the object to select or not. names: An explicit list of names to select. Returns: Yes or no. \"\"\" if names : return name in names return not self . filter_name_out ( name )","title":"select()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode","text":"Helper class to represent an object tree. It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs). Each node stores an object, its name, and a reference to its parent node.","title":"ObjectNode"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.dotted_path","text":"The Python dotted path of the object.","title":"dotted_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.file_path","text":"The object's module file path.","title":"file_path"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.name","text":"The Python object's name.","title":"name"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.obj","text":"The actual Python object.","title":"obj"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.parent","text":"The parent node.","title":"parent"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.root","text":"The root of the tree.","title":"root"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_class","text":"Is this node's object a class? Source code in pytkdocs/loader.py 68 69 70 def is_class ( self ) -> bool : \"\"\"Is this node's object a class?\"\"\" return inspect . isclass ( self . obj )","title":"is_class()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_classmethod","text":"Is this node's object a classmethod? Source code in pytkdocs/loader.py 94 95 96 97 98 def is_classmethod ( self ) -> bool : \"\"\"Is this node's object a classmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), classmethod )","title":"is_classmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_function","text":"Is this node's object a function? Source code in pytkdocs/loader.py 72 73 74 def is_function ( self ) -> bool : \"\"\"Is this node's object a function?\"\"\" return inspect . isfunction ( self . obj )","title":"is_function()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_method","text":"Is this node's object a method? Source code in pytkdocs/loader.py 84 85 86 def is_method ( self ) -> bool : \"\"\"Is this node's object a method?\"\"\" return self . parent_is_class () and isinstance ( self . obj , type ( lambda : 0 ))","title":"is_method()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_module","text":"Is this node's object a module? Source code in pytkdocs/loader.py 64 65 66 def is_module ( self ) -> bool : \"\"\"Is this node's object a module?\"\"\" return inspect . ismodule ( self . obj )","title":"is_module()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_property","text":"Is this node's object a property? Source code in pytkdocs/loader.py 76 77 78 def is_property ( self ) -> bool : \"\"\"Is this node's object a property?\"\"\" return isinstance ( self . obj , property )","title":"is_property()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.is_staticmethod","text":"Is this node's object a staticmethod? Source code in pytkdocs/loader.py 88 89 90 91 92 def is_staticmethod ( self ) -> bool : \"\"\"Is this node's object a staticmethod?\"\"\" if not self . parent : return False return self . parent_is_class () and isinstance ( self . parent . obj . __dict__ . get ( self . name , None ), staticmethod )","title":"is_staticmethod()"},{"location":"reference/loader/#pytkdocs.loader.ObjectNode.parent_is_class","text":"Is the object of this node's parent a class? Source code in pytkdocs/loader.py 80 81 82 def parent_is_class ( self ) -> bool : \"\"\"Is the object of this node's parent a class?\"\"\" return bool ( self . parent and self . parent . is_class ())","title":"parent_is_class()"},{"location":"reference/loader/#pytkdocs.loader.get_object_tree","text":"Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. It is not possible to load local objects. Parameters: Name Type Description Default path str the dot-separated path of the object. required Exceptions: Type Description ValueError when the path is not valid (evaluates to False ). ImportError when the object or its parent module could not be imported. Returns: Type Description ObjectNode The leaf node representing the object and its parents. Source code in pytkdocs/loader.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_object_tree ( path : str ) -> ObjectNode : \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through `importlib.import_module` and each object is obtainable through the `getattr` method. It is not possible to load local objects. Args: path: the dot-separated path of the object. Raises: ValueError: when the path is not valid (evaluates to `False`). ImportError: when the object or its parent module could not be imported. Returns: The leaf node representing the object and its parents. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not { path } \" ) # We will try to import the longest dotted-path first. # If it fails, we remove the right-most part and put it in a list of \"objects\", used later. # We loop until we find the deepest importable submodule. obj_parent_modules = path . split ( \".\" ) objects : List [ str ] = [] while True : parent_module_path = \".\" . join ( obj_parent_modules ) try : parent_module = importlib . import_module ( parent_module_path ) except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) else : break # We now have the module containing the desired object. # We will build the object tree by iterating over the previously stored objects names # and trying to get them as attributes. current_node = ObjectNode ( parent_module , parent_module . __name__ ) for obj_name in objects : obj = getattr ( current_node . obj , obj_name ) current_node . child = ObjectNode ( obj , obj_name , parent = current_node ) # type: ignore current_node = current_node . child # type: ignore leaf = current_node # We now try to get the \"real\" parent module, not the one the object was imported into. # This is important if we want to be able to retrieve the docstring of an attribute for example. # Once we find an object for which we could get the module, we stop trying to get the module. # Once we reach the node before the root, we apply the module if found, and break. real_module = None while current_node . parent is not None : if real_module is None : real_module = inspect . getmodule ( current_node . obj ) if inspect . ismodule ( current_node . parent . obj ): if real_module is not None and real_module is not current_node . parent . obj : current_node . parent = ObjectNode ( real_module , real_module . __name__ ) break current_node = current_node . parent return leaf","title":"get_object_tree()"},{"location":"reference/objects/","text":"This module defines the documented objects classes: the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code. Attribute A class to store information about an attribute. It accepts an additional attr_type argument at instantiation. Class A class to store information about a class. Function A class to store information about a function. It accepts an additional signature argument at instantiation. Method A class to store information about a method. It accepts an additional signature argument at instantiation. Module A class to store information about a module. file_name property readonly The base name of the module file, without the extension. Object A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category. attributes: List [ Attribute ] The list of all the object's attributes. category: str property readonly The object's category: module, class, function, method or attribute. children: List [ Object ] The list of all the object's children. classes: List [ Class ] The list of all the object's classes. docstring The object's docstring. file_path The file path of the object's direct parent module. functions: List [ Function ] The list of all the object's functions. is_attribute: bool property readonly Is this object an attribute? is_class: bool property readonly Is this object a class? is_function: bool property readonly Is this object a function? is_method: bool property readonly Is this object a method? is_module: bool property readonly Is this object a module? methods: List [ Method ] The list of all the object's methods. modules: List [ Module ] The list of all the object's submodules. name The object's name. name_properties: List [ str ] property readonly The object's name properties (private, class-private, special). NAME_PROPERTIES: List [ ApplicableNameProperty ] class-attribute The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another. name_to_check: str property readonly The attribute to check against name properties regular expressions (private, class-private, special). parent: Optional [ Object ] The object's parent (another instance of a subclass of Object ). parent_path: str property readonly The parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent. path The object's dotted-path. properties The object's properties. relative_file_path: str property readonly The relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string). root: Object property readonly The object's root (top-most parent). source The object's source code. __init__ ( self , name , path , file_path , docstring = '' , properties = None , source = None ) special Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring str The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , name : str , path : str , file_path : str , docstring : str = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\" add_child ( self , obj ) Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) # type: ignore elif obj . is_class : self . classes . append ( obj ) # type: ignore elif obj . is_function : self . functions . append ( obj ) # type: ignore elif obj . is_method : self . methods . append ( obj ) # type: ignore elif obj . is_attribute : self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj add_children ( self , children ) Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py 244 245 246 247 248 249 250 251 252 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child ) dispatch_attributes ( self , attributes ) Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Parameters: Name Type Description Default attributes List[Attribute] The list of attributes to dispatch. required Source code in pytkdocs/objects.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def dispatch_attributes ( self , attributes : List [ \"Attribute\" ]) -> None : \"\"\" Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Arguments: attributes: The list of attributes to dispatch. \"\"\" for attribute in attributes : try : attach_to = self . _path_map [ attribute . parent_path ] except KeyError : pass else : attach_to . attributes . append ( attribute ) attach_to . children . append ( attribute ) attribute . parent = attach_to parse_all_docstring ( self ) Recursively parse the docstring of this object and its children. I hope we can get rid of this code at some point as parsing docstring is not really our purpose. Source code in pytkdocs/objects.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def parse_all_docstring ( self ) -> None : \"\"\" Recursively parse the docstring of this object and its children. I hope we can get rid of this code at some point as parsing docstring is not really our purpose. \"\"\" signature = None if hasattr ( self , \"signature\" ): signature = self . signature # type: ignore attr_type = None if hasattr ( self , \"type\" ): attr_type = self . type # type: ignore sections , errors = parse ( self . path , self . docstring , signature , attr_type ) self . docstring_sections = sections self . docstring_errors = errors for child in self . children : child . parse_all_docstring () Source Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines . code The code, as a single string. line_start The first line number. __init__ ( self , lines , line_start ) special Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"objects.py"},{"location":"reference/objects/#pytkdocs.objects","text":"This module defines the documented objects classes: the generic [ Object ][pytkdocs.objects.Object] class the [ Module ][pytkdocs.objects.Module] class the [ Class ][pytkdocs.objects.Class] class the [ Method ][pytkdocs.objects.Method] class the [ Function ][pytkdocs.objects.Function] class the [ Attribute ][pytkdocs.objects.Attribute] class Note that properties are considered attributes, because they are used like such. It also defines a convenient [ Source ][pytkdocs.objects.Source] class to represent source code.","title":"pytkdocs.objects"},{"location":"reference/objects/#pytkdocs.objects.Attribute","text":"A class to store information about an attribute. It accepts an additional attr_type argument at instantiation.","title":"Attribute"},{"location":"reference/objects/#pytkdocs.objects.Class","text":"A class to store information about a class.","title":"Class"},{"location":"reference/objects/#pytkdocs.objects.Function","text":"A class to store information about a function. It accepts an additional signature argument at instantiation.","title":"Function"},{"location":"reference/objects/#pytkdocs.objects.Method","text":"A class to store information about a method. It accepts an additional signature argument at instantiation.","title":"Method"},{"location":"reference/objects/#pytkdocs.objects.Module","text":"A class to store information about a module.","title":"Module"},{"location":"reference/objects/#pytkdocs.objects.Module.file_name","text":"The base name of the module file, without the extension.","title":"file_name"},{"location":"reference/objects/#pytkdocs.objects.Object","text":"A base class to store information about a Python object. Each instance additionally stores references to its children, grouped by category.","title":"Object"},{"location":"reference/objects/#pytkdocs.objects.Object.attributes","text":"The list of all the object's attributes.","title":"attributes"},{"location":"reference/objects/#pytkdocs.objects.Object.category","text":"The object's category: module, class, function, method or attribute.","title":"category"},{"location":"reference/objects/#pytkdocs.objects.Object.children","text":"The list of all the object's children.","title":"children"},{"location":"reference/objects/#pytkdocs.objects.Object.classes","text":"The list of all the object's classes.","title":"classes"},{"location":"reference/objects/#pytkdocs.objects.Object.docstring","text":"The object's docstring.","title":"docstring"},{"location":"reference/objects/#pytkdocs.objects.Object.file_path","text":"The file path of the object's direct parent module.","title":"file_path"},{"location":"reference/objects/#pytkdocs.objects.Object.functions","text":"The list of all the object's functions.","title":"functions"},{"location":"reference/objects/#pytkdocs.objects.Object.is_attribute","text":"Is this object an attribute?","title":"is_attribute"},{"location":"reference/objects/#pytkdocs.objects.Object.is_class","text":"Is this object a class?","title":"is_class"},{"location":"reference/objects/#pytkdocs.objects.Object.is_function","text":"Is this object a function?","title":"is_function"},{"location":"reference/objects/#pytkdocs.objects.Object.is_method","text":"Is this object a method?","title":"is_method"},{"location":"reference/objects/#pytkdocs.objects.Object.is_module","text":"Is this object a module?","title":"is_module"},{"location":"reference/objects/#pytkdocs.objects.Object.methods","text":"The list of all the object's methods.","title":"methods"},{"location":"reference/objects/#pytkdocs.objects.Object.modules","text":"The list of all the object's submodules.","title":"modules"},{"location":"reference/objects/#pytkdocs.objects.Object.name","text":"The object's name.","title":"name"},{"location":"reference/objects/#pytkdocs.objects.Object.name_properties","text":"The object's name properties (private, class-private, special).","title":"name_properties"},{"location":"reference/objects/#pytkdocs.objects.Object.NAME_PROPERTIES","text":"The properties that we can apply to the object based on its name. The applicable properties vary from one subclass of Object to another.","title":"NAME_PROPERTIES"},{"location":"reference/objects/#pytkdocs.objects.Object.name_to_check","text":"The attribute to check against name properties regular expressions (private, class-private, special).","title":"name_to_check"},{"location":"reference/objects/#pytkdocs.objects.Object.parent","text":"The object's parent (another instance of a subclass of Object ).","title":"parent"},{"location":"reference/objects/#pytkdocs.objects.Object.parent_path","text":"The parent's path, computed from the current path. The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent.","title":"parent_path"},{"location":"reference/objects/#pytkdocs.objects.Object.path","text":"The object's dotted-path.","title":"path"},{"location":"reference/objects/#pytkdocs.objects.Object.properties","text":"The object's properties.","title":"properties"},{"location":"reference/objects/#pytkdocs.objects.Object.relative_file_path","text":"The relative file path of the object. It is the relative path to the object's module, starting at the path of the top-most package it is contained in. For example: package is a package absolute path is /abs/path/to/a module is a.b.c object is c or anything defined in c relative file path is a/b/c.py If the relative file path cannot be determined, the value returned is \"\" (empty string).","title":"relative_file_path"},{"location":"reference/objects/#pytkdocs.objects.Object.root","text":"The object's root (top-most parent).","title":"root"},{"location":"reference/objects/#pytkdocs.objects.Object.source","text":"The object's source code.","title":"source"},{"location":"reference/objects/#pytkdocs.objects.Object.__init__","text":"Parameters: Name Type Description Default name str The object's name. required path str The object's dotted-path. required file_path str The file path of the object's direct parent module. required docstring str The object's docstring. '' properties Optional[List[str]] The object's properties. None source Optional[pytkdocs.objects.Source] The object's source code. None Source code in pytkdocs/objects.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , name : str , path : str , file_path : str , docstring : str = \"\" , properties : Optional [ List [ str ]] = None , source : Optional [ Source ] = None , ) -> None : \"\"\" Arguments: name: The object's name. path: The object's dotted-path. file_path: The file path of the object's direct parent module. docstring: The object's docstring. properties: The object's properties. source: The object's source code. \"\"\" self . name = name \"\"\"The object's name.\"\"\" self . path = path \"\"\"The object's dotted-path.\"\"\" self . file_path = file_path \"\"\"The file path of the object's direct parent module.\"\"\" self . docstring = docstring \"\"\"The object's docstring.\"\"\" self . properties = properties or [] \"\"\"The object's properties.\"\"\" self . parent : Optional [ Object ] = None \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\" self . source = source \"\"\"The object's source code.\"\"\" self . _path_map = { self . path : self } self . attributes : List [ Attribute ] = [] \"\"\"The list of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"The list of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"The list of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"The list of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"The list of all the object's classes.\"\"\" self . children : List [ Object ] = [] \"\"\"The list of all the object's children.\"\"\"","title":"__init__()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_child","text":"Add an object as a child of this object. If the child computed parent_path is not equal to this object's path, abort. Append the child to the children list, and to the right category list. Parameters: Name Type Description Default obj Object An instance of documented object. required Source code in pytkdocs/objects.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def add_child ( self , obj : \"Object\" ) -> None : \"\"\" Add an object as a child of this object. If the child computed `parent_path` is not equal to this object's path, abort. Append the child to the `children` list, and to the right category list. Arguments: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) # type: ignore elif obj . is_class : self . classes . append ( obj ) # type: ignore elif obj . is_function : self . functions . append ( obj ) # type: ignore elif obj . is_method : self . methods . append ( obj ) # type: ignore elif obj . is_attribute : self . attributes . append ( obj ) # type: ignore obj . parent = self self . _path_map [ obj . path ] = obj","title":"add_child()"},{"location":"reference/objects/#pytkdocs.objects.Object.add_children","text":"Add a list of objects as children of this object. Parameters: Name Type Description Default children List[Object] The list of children to add. required Source code in pytkdocs/objects.py 244 245 246 247 248 249 250 251 252 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\" Add a list of objects as children of this object. Arguments: children: The list of children to add. \"\"\" for child in children : self . add_child ( child )","title":"add_children()"},{"location":"reference/objects/#pytkdocs.objects.Object.dispatch_attributes","text":"Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Parameters: Name Type Description Default attributes List[Attribute] The list of attributes to dispatch. required Source code in pytkdocs/objects.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def dispatch_attributes ( self , attributes : List [ \"Attribute\" ]) -> None : \"\"\" Dispatch attributes as children of an object and its children given their path. If an attribute's path does not correspond to the object or any of its children, the attribute is not attached. Arguments: attributes: The list of attributes to dispatch. \"\"\" for attribute in attributes : try : attach_to = self . _path_map [ attribute . parent_path ] except KeyError : pass else : attach_to . attributes . append ( attribute ) attach_to . children . append ( attribute ) attribute . parent = attach_to","title":"dispatch_attributes()"},{"location":"reference/objects/#pytkdocs.objects.Object.parse_all_docstring","text":"Recursively parse the docstring of this object and its children. I hope we can get rid of this code at some point as parsing docstring is not really our purpose. Source code in pytkdocs/objects.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def parse_all_docstring ( self ) -> None : \"\"\" Recursively parse the docstring of this object and its children. I hope we can get rid of this code at some point as parsing docstring is not really our purpose. \"\"\" signature = None if hasattr ( self , \"signature\" ): signature = self . signature # type: ignore attr_type = None if hasattr ( self , \"type\" ): attr_type = self . type # type: ignore sections , errors = parse ( self . path , self . docstring , signature , attr_type ) self . docstring_sections = sections self . docstring_errors = errors for child in self . children : child . parse_all_docstring ()","title":"parse_all_docstring()"},{"location":"reference/objects/#pytkdocs.objects.Source","text":"Helper class to represent source code. It is simply used to wrap the result of inspect.getsourceslines .","title":"Source"},{"location":"reference/objects/#pytkdocs.objects.Source.code","text":"The code, as a single string.","title":"code"},{"location":"reference/objects/#pytkdocs.objects.Source.line_start","text":"The first line number.","title":"line_start"},{"location":"reference/objects/#pytkdocs.objects.Source.__init__","text":"Parameters: Name Type Description Default lines Union[str, List[str]] A list of strings. The strings should have trailing newlines. required line_start int The line number of where the code starts in the file. required Source code in pytkdocs/objects.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , lines : Union [ str , List [ str ]], line_start : int ) -> None : \"\"\" Arguments: lines: A list of strings. The strings should have trailing newlines. line_start: The line number of where the code starts in the file. \"\"\" if isinstance ( lines , list ): code = \"\" . join ( lines ) else : code = lines self . code = code \"\"\"The code, as a single string.\"\"\" self . line_start = line_start \"\"\"The first line number.\"\"\"","title":"__init__()"},{"location":"reference/properties/","text":"This module simply defines regular expressions and their associated predicates. NAME_CLASS_PRIVATE: ApplicableNameProperty Applicable property: class-private . NAME_PRIVATE: ApplicableNameProperty Applicable property: private . NAME_SPECIAL: ApplicableNameProperty Applicable property: special . RE_CLASS_PRIVATE: Pattern Regular expression to match __class_private names. RE_PRIVATE: Pattern Regular expression to match _private names. RE_SPECIAL: Pattern Regular expression to match __special__ names.","title":"properties.py"},{"location":"reference/properties/#pytkdocs.properties","text":"This module simply defines regular expressions and their associated predicates.","title":"pytkdocs.properties"},{"location":"reference/properties/#pytkdocs.properties.NAME_CLASS_PRIVATE","text":"Applicable property: class-private .","title":"NAME_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_PRIVATE","text":"Applicable property: private .","title":"NAME_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.NAME_SPECIAL","text":"Applicable property: special .","title":"NAME_SPECIAL"},{"location":"reference/properties/#pytkdocs.properties.RE_CLASS_PRIVATE","text":"Regular expression to match __class_private names.","title":"RE_CLASS_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_PRIVATE","text":"Regular expression to match _private names.","title":"RE_PRIVATE"},{"location":"reference/properties/#pytkdocs.properties.RE_SPECIAL","text":"Regular expression to match __special__ names.","title":"RE_SPECIAL"},{"location":"reference/serializer/","text":"This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps . serialize_annotated_object ( obj ) Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 15 16 17 18 19 20 21 22 23 24 25 def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return dict ( description = obj . description , annotation = obj . annotation_string ) serialize_docstring_section ( section ) Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( type = section . type ) if section . type == section . Type . MARKDOWN : serialized . update ( dict ( value = \" \\n \" . join ( section . value ))) elif section . type == section . Type . RETURN : serialized . update ( dict ( value = serialize_annotated_object ( section . value ))) elif section . type == section . Type . EXCEPTIONS : serialized . update ( dict ( value = [ serialize_annotated_object ( e ) for e in section . value ])) elif section . type == section . Type . PARAMETERS : serialized . update ( dict ( value = [ serialize_parameter ( p ) for p in section . value ])) return serialized serialize_object ( obj ) Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( name = obj . name , path = obj . path , category = obj . category , file_path = obj . file_path , relative_file_path = obj . relative_file_path , properties = sorted ( set ( obj . properties + obj . name_properties )), parent_path = obj . parent_path , has_contents = obj . has_contents (), docstring = obj . docstring , docstring_sections = [ serialize_docstring_section ( s ) for s in obj . docstring_sections ], source = serialize_source ( obj . source ), children = { child . path : serialize_object ( child ) for child in obj . children }, attributes = [ o . path for o in obj . attributes ], methods = [ o . path for o in obj . methods ], functions = [ o . path for o in obj . functions ], modules = [ o . path for o in obj . modules ], classes = [ o . path for o in obj . classes ], ) if hasattr ( obj , \"type\" ): serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized serialize_parameter ( parameter ) Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( dict ( name = parameter . name , kind = str ( parameter . kind ), default = parameter . default_string , is_optional = parameter . is_optional , is_required = parameter . is_required , is_args = parameter . is_args , is_kwargs = parameter . is_kwargs , ) ) return serialized serialize_signature ( signature ) Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = dict ( parameters = [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()] ) if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized serialize_signature_parameter ( parameter ) Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( kind = str ( parameter . kind ), name = parameter . name ) if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized serialize_source ( source ) Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 113 114 115 116 117 118 119 120 121 122 123 124 125 def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return dict ( code = source . code , line_start = source . line_start ) return {}","title":"serializer.py"},{"location":"reference/serializer/#pytkdocs.serializer","text":"This module defines function to serialize objects. These functions simply take objects as parameters and return dictionaries that can be dumped by json.dumps .","title":"pytkdocs.serializer"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_annotated_object","text":"Serialize an instance of [ AnnotatedObject ][pytkdocs.parsers.docstrings.AnnotatedObject]. Parameters: Name Type Description Default obj AnnotatedObject The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 15 16 17 18 19 20 21 22 23 24 25 def serialize_annotated_object ( obj : AnnotatedObject ) -> dict : \"\"\" Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.AnnotatedObject]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" return dict ( description = obj . description , annotation = obj . annotation_string )","title":"serialize_annotated_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_docstring_section","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default section Section The section to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def serialize_docstring_section ( section : Section ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: section: The section to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( type = section . type ) if section . type == section . Type . MARKDOWN : serialized . update ( dict ( value = \" \\n \" . join ( section . value ))) elif section . type == section . Type . RETURN : serialized . update ( dict ( value = serialize_annotated_object ( section . value ))) elif section . type == section . Type . EXCEPTIONS : serialized . update ( dict ( value = [ serialize_annotated_object ( e ) for e in section . value ])) elif section . type == section . Type . PARAMETERS : serialized . update ( dict ( value = [ serialize_parameter ( p ) for p in section . value ])) return serialized","title":"serialize_docstring_section()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_object","text":"Serialize an instance of a subclass of [ Object ][pytkdocs.objects.Object]. Parameters: Name Type Description Default obj Object The object to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def serialize_object ( obj : Object ) -> dict : \"\"\" Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object]. Arguments: obj: The object to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( name = obj . name , path = obj . path , category = obj . category , file_path = obj . file_path , relative_file_path = obj . relative_file_path , properties = sorted ( set ( obj . properties + obj . name_properties )), parent_path = obj . parent_path , has_contents = obj . has_contents (), docstring = obj . docstring , docstring_sections = [ serialize_docstring_section ( s ) for s in obj . docstring_sections ], source = serialize_source ( obj . source ), children = { child . path : serialize_object ( child ) for child in obj . children }, attributes = [ o . path for o in obj . attributes ], methods = [ o . path for o in obj . methods ], functions = [ o . path for o in obj . functions ], modules = [ o . path for o in obj . modules ], classes = [ o . path for o in obj . classes ], ) if hasattr ( obj , \"type\" ): serialized [ \"type\" ] = annotation_to_string ( obj . type ) # type: ignore if hasattr ( obj , \"signature\" ): serialized [ \"signature\" ] = serialize_signature ( obj . signature ) # type: ignore return serialized","title":"serialize_object()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_parameter","text":"Serialize an instance of [ Parameter ][pytkdocs.parsers.docstrings.Parameter]. Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def serialize_parameter ( parameter : Parameter ) -> dict : \"\"\" Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.Parameter]. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = serialize_annotated_object ( parameter ) serialized . update ( dict ( name = parameter . name , kind = str ( parameter . kind ), default = parameter . default_string , is_optional = parameter . is_optional , is_required = parameter . is_required , is_args = parameter . is_args , is_kwargs = parameter . is_kwargs , ) ) return serialized","title":"serialize_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature","text":"Serialize an instance of inspect.Signature . Parameters: Name Type Description Default signature Signature The signature to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def serialize_signature ( signature : inspect . Signature ) -> dict : \"\"\" Serialize an instance of `inspect.Signature`. Arguments: signature: The signature to serialize. Returns: A JSON-serializable dictionary. \"\"\" if signature is None : return {} serialized : dict = dict ( parameters = [ serialize_signature_parameter ( value ) for name , value in signature . parameters . items ()] ) if signature . return_annotation is not inspect . Signature . empty : serialized [ \"return_annotation\" ] = annotation_to_string ( signature . return_annotation ) return serialized","title":"serialize_signature()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_signature_parameter","text":"Serialize an instance of inspect.Parameter . Parameters: Name Type Description Default parameter Parameter The parameter to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def serialize_signature_parameter ( parameter : inspect . Parameter ) -> dict : \"\"\" Serialize an instance of `inspect.Parameter`. Arguments: parameter: The parameter to serialize. Returns: A JSON-serializable dictionary. \"\"\" serialized = dict ( kind = str ( parameter . kind ), name = parameter . name ) if parameter . annotation is not parameter . empty : serialized [ \"annotation\" ] = annotation_to_string ( parameter . annotation ) if parameter . default is not parameter . empty : serialized [ \"default\" ] = repr ( parameter . default ) return serialized","title":"serialize_signature_parameter()"},{"location":"reference/serializer/#pytkdocs.serializer.serialize_source","text":"Serialize an instance of [ Source ][pytkdocs.objects.Source]. Parameters: Name Type Description Default source Optional[pytkdocs.objects.Source] The source to serialize. required Returns: Type Description dict A JSON-serializable dictionary. Source code in pytkdocs/serializer.py 113 114 115 116 117 118 119 120 121 122 123 124 125 def serialize_source ( source : Optional [ Source ]) -> dict : \"\"\" Serialize an instance of [`Source`][pytkdocs.objects.Source]. Arguments: source: The source to serialize. Returns: A JSON-serializable dictionary. \"\"\" if source : return dict ( code = source . code , line_start = source . line_start ) return {}","title":"serialize_source()"},{"location":"reference/parsers/__init__/","text":"","title":"__init__.py"},{"location":"reference/parsers/__init__/#pytkdocs.parsers.__init__","text":"","title":"pytkdocs.parsers.__init__"},{"location":"reference/parsers/attributes/","text":"","title":"attributes.py"},{"location":"reference/parsers/attributes/#pytkdocs.parsers.attributes","text":"","title":"pytkdocs.parsers.attributes"},{"location":"reference/parsers/docstrings/","text":"This module defines functions and classes to parse docstrings into structured data. RE_FORWARD_REF: Pattern Regular expression to match forward-reference annotations of the form _ForwardRef('T') . RE_GOOGLE_STYLE_ADMONITION: Pattern Regular expressions to match lines starting admonitions, of the form TYPE: [TITLE] . RE_OPTIONAL: Pattern Regular expression to match optional annotations of the form Union[T, NoneType] . TITLES_EXCEPTIONS: Sequence [ str ] Titles to match for \"exceptions\" sections. TITLES_PARAMETERS: Sequence [ str ] Titles to match for \"parameters\" sections. TITLES_RETURN: Sequence [ str ] Titles to match for \"returns\" sections. AnnotatedObject A helper class to store information about an annotated object. DocstringParser A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.Section]s. It also return the list of errors that occurred during parsing. __init__ ( self , path , docstring , signature = None , return_type ) special Parameters: Name Type Description Default path str An object's dotted-path, used to improve error messages. required docstring str An object's docstring: the docstring to parse. required signature Optional[inspect.Signature] An object's signature if any. None return_type Optional[Any] An object's return type if any. Can be a string or a type. required Source code in pytkdocs/parsers/docstrings.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __init__ ( self , path : str , docstring : str , signature : Optional [ inspect . Signature ] = None , return_type : Optional [ Any ] = empty , ) -> None : \"\"\" Arguments: path: An object's dotted-path, used to improve error messages. docstring: An object's docstring: the docstring to parse. signature: An object's signature if any. return_type: An object's return type if any. Can be a string or a type. \"\"\" self . path = path self . docstring = docstring or \"\" self . signature = signature self . return_type = return_type self . parsing_errors : List [ str ] = [] parse ( self , admonitions = True ) Parse a docstring. Parameters: Name Type Description Default admonitions bool Whether to transform \"Google-Style admonitions\" to \"Markdown admonitions\" by transforming Type: [Title] to !!! type: [\"Title\"] . True Returns: Type Description List[pytkdocs.parsers.docstrings.Section] A tuple containing the list of parsed sections and the errors that occurred during parsing. Source code in pytkdocs/parsers/docstrings.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def parse ( self , admonitions : bool = True ) -> List [ Section ]: \"\"\" Parse a docstring. Arguments: admonitions: Whether to transform \"Google-Style admonitions\" to \"Markdown admonitions\" by transforming `Type: [Title]` to `!!! type: [\"Title\"]`. Returns: A tuple containing the list of parsed sections and the errors that occurred during parsing. \"\"\" sections = [] current_section = [] in_code_block = False lines = self . docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in TITLES_PARAMETERS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_parameters_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_exceptions_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_RETURN : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , current_section )) return sections read_block ( lines , start_index ) staticmethod Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def read_block ( lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" i = start_index block = [] while i < len ( lines ) and ( lines [ i ] . startswith ( \" \" ) or not lines [ i ] . strip ()): block . append ( lines [ i ]) i += 1 return block , i - 1 read_block_items ( lines , start_index ) staticmethod Parse an indented block as a list of items. Each item is indented by four spaces. Every line indented with more than five spaces are concatenated back into the previous line. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 @staticmethod def read_block_items ( lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. Each item is indented by four spaces. Every line indented with more than five spaces are concatenated back into the previous line. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" i = start_index block : List [ str ] = [] prefix = \" \" while i < len ( lines ) and ( lines [ i ] . startswith ( \" \" ) or not lines [ i ] . strip ()): if block and lines [ i ] . startswith ( \" \" ): block [ - 1 ] += prefix + lines [ i ] . lstrip ( \" \" ) prefix = \" \" elif block and not lines [ i ] . strip (): block [ - 1 ] += \" \\n\\n \" prefix = \"\" else : block . append ( lines [ i ]) i += 1 cleaned_up_block = [] for line in block : stripped = line . strip () if stripped : cleaned_up_block . append ( stripped ) return cleaned_up_block , i - 1 read_exceptions_section ( self , lines , start_index ) Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . parsing_errors . append ( f \" { self . path } : Empty exceptions section at line { start_index } \" ) return None , i read_parameters_section ( self , lines , start_index ) Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . lstrip ( \" \" ) . split ( \":\" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : Failed to get 'name: description' pair from ' { param_line } '\" ) continue if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . signature . parameters [ name ] # type: ignore except ( AttributeError , KeyError ): self . parsing_errors . append ( f \" { self . path } : No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description . lstrip ( \" \" ), default = default , kind = kind , ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . parsing_errors . append ( f \" { self . path } : Empty parameters section at line { start_index } \" ) return None , i read_return_section ( self , lines , start_index ) Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" block , i = self . read_block ( lines , start_index ) if self . signature : annotation = self . signature . return_annotation else : annotation = self . return_type if annotation is empty : if not block : self . parsing_errors . append ( f \" { self . path } : No return type annotation\" ) else : try : type_ , first_line = block [ 0 ] . split ( \":\" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : No type in return description\" ) else : annotation = type_ . lstrip ( \" \" ) block [ 0 ] = first_line . lstrip ( \" \" ) description = dedent ( \" \\n \" . join ( block )) if annotation is empty and not description : self . parsing_errors . append ( f \" { self . path } : Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , description )), i Parameter A helper class to store information about a signature parameter. Section A helper class to store a docstring section.","title":"docstrings.py"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings","text":"This module defines functions and classes to parse docstrings into structured data.","title":"pytkdocs.parsers.docstrings"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.RE_FORWARD_REF","text":"Regular expression to match forward-reference annotations of the form _ForwardRef('T') .","title":"RE_FORWARD_REF"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.RE_GOOGLE_STYLE_ADMONITION","text":"Regular expressions to match lines starting admonitions, of the form TYPE: [TITLE] .","title":"RE_GOOGLE_STYLE_ADMONITION"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.RE_OPTIONAL","text":"Regular expression to match optional annotations of the form Union[T, NoneType] .","title":"RE_OPTIONAL"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.TITLES_EXCEPTIONS","text":"Titles to match for \"exceptions\" sections.","title":"TITLES_EXCEPTIONS"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.TITLES_PARAMETERS","text":"Titles to match for \"parameters\" sections.","title":"TITLES_PARAMETERS"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.TITLES_RETURN","text":"Titles to match for \"returns\" sections.","title":"TITLES_RETURN"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.AnnotatedObject","text":"A helper class to store information about an annotated object.","title":"AnnotatedObject"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser","text":"A class to parse docstrings. It is instantiated with an object's path, docstring, signature and return type. The parse method then returns structured data, in the form of a list of [ Section ][pytkdocs.parsers.docstrings.Section]s. It also return the list of errors that occurred during parsing.","title":"DocstringParser"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.__init__","text":"Parameters: Name Type Description Default path str An object's dotted-path, used to improve error messages. required docstring str An object's docstring: the docstring to parse. required signature Optional[inspect.Signature] An object's signature if any. None return_type Optional[Any] An object's return type if any. Can be a string or a type. required Source code in pytkdocs/parsers/docstrings.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __init__ ( self , path : str , docstring : str , signature : Optional [ inspect . Signature ] = None , return_type : Optional [ Any ] = empty , ) -> None : \"\"\" Arguments: path: An object's dotted-path, used to improve error messages. docstring: An object's docstring: the docstring to parse. signature: An object's signature if any. return_type: An object's return type if any. Can be a string or a type. \"\"\" self . path = path self . docstring = docstring or \"\" self . signature = signature self . return_type = return_type self . parsing_errors : List [ str ] = []","title":"__init__()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.parse","text":"Parse a docstring. Parameters: Name Type Description Default admonitions bool Whether to transform \"Google-Style admonitions\" to \"Markdown admonitions\" by transforming Type: [Title] to !!! type: [\"Title\"] . True Returns: Type Description List[pytkdocs.parsers.docstrings.Section] A tuple containing the list of parsed sections and the errors that occurred during parsing. Source code in pytkdocs/parsers/docstrings.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def parse ( self , admonitions : bool = True ) -> List [ Section ]: \"\"\" Parse a docstring. Arguments: admonitions: Whether to transform \"Google-Style admonitions\" to \"Markdown admonitions\" by transforming `Type: [Title]` to `!!! type: [\"Title\"]`. Returns: A tuple containing the list of parsed sections and the errors that occurred during parsing. \"\"\" sections = [] current_section = [] in_code_block = False lines = self . docstring . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if in_code_block : if line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = False current_section . append ( lines [ i ]) elif line_lower in TITLES_PARAMETERS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_parameters_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_exceptions_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower in TITLES_RETURN : if current_section : if any ( current_section ): sections . append ( Section ( Section . Type . MARKDOWN , current_section )) current_section = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = True current_section . append ( lines [ i ]) else : if admonitions and not in_code_block and i + 1 < len ( lines ): match = RE_GOOGLE_STYLE_ADMONITION . match ( lines [ i ]) if match : groups = match . groupdict () indent = groups [ \"indent\" ] if lines [ i + 1 ] . startswith ( indent + \" \" * 4 ): lines [ i ] = f \" { indent } !!! { groups [ 'type' ] . lower () } \" if groups [ \"title\" ]: lines [ i ] += f ' \" { groups [ \"title\" ] } \"' current_section . append ( lines [ i ]) i += 1 if current_section : sections . append ( Section ( Section . Type . MARKDOWN , current_section )) return sections","title":"parse()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.read_block","text":"Parse an indented block. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def read_block ( lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of lines and the index at which to continue parsing. \"\"\" i = start_index block = [] while i < len ( lines ) and ( lines [ i ] . startswith ( \" \" ) or not lines [ i ] . strip ()): block . append ( lines [ i ]) i += 1 return block , i - 1","title":"read_block()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.read_block_items","text":"Parse an indented block as a list of items. Each item is indented by four spaces. Every line indented with more than five spaces are concatenated back into the previous line. Parameters: Name Type Description Default lines List[str] The block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[List[str], int] A tuple containing the list of concatenated lines and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 @staticmethod def read_block_items ( lines : List [ str ], start_index : int ) -> Tuple [ List [ str ], int ]: \"\"\" Parse an indented block as a list of items. Each item is indented by four spaces. Every line indented with more than five spaces are concatenated back into the previous line. Arguments: lines: The block lines. start_index: The line number to start at. Returns: A tuple containing the list of concatenated lines and the index at which to continue parsing. \"\"\" i = start_index block : List [ str ] = [] prefix = \" \" while i < len ( lines ) and ( lines [ i ] . startswith ( \" \" ) or not lines [ i ] . strip ()): if block and lines [ i ] . startswith ( \" \" ): block [ - 1 ] += prefix + lines [ i ] . lstrip ( \" \" ) prefix = \" \" elif block and not lines [ i ] . strip (): block [ - 1 ] += \" \\n\\n \" prefix = \"\" else : block . append ( lines [ i ]) i += 1 cleaned_up_block = [] for line in block : stripped = line . strip () if stripped : cleaned_up_block . append ( stripped ) return cleaned_up_block , i - 1","title":"read_block_items()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.read_exceptions_section","text":"Parse an \"exceptions\" section. Parameters: Name Type Description Default lines List[str] The exceptions block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def read_exceptions_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"exceptions\" section. Arguments: lines: The exceptions block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" exceptions = [] block , i = self . read_block_items ( lines , start_index ) for exception_line in block : try : annotation , description = exception_line . split ( \": \" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : Failed to get 'exception: description' pair from ' { exception_line } '\" ) else : exceptions . append ( AnnotatedObject ( annotation , description . lstrip ( \" \" ))) if exceptions : return Section ( Section . Type . EXCEPTIONS , exceptions ), i self . parsing_errors . append ( f \" { self . path } : Empty exceptions section at line { start_index } \" ) return None , i","title":"read_exceptions_section()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.read_parameters_section","text":"Parse a \"parameters\" section. Parameters: Name Type Description Default lines List[str] The parameters block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def read_parameters_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse a \"parameters\" section. Arguments: lines: The parameters block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" parameters = [] type_ : Any block , i = self . read_block_items ( lines , start_index ) for param_line in block : try : name_with_type , description = param_line . lstrip ( \" \" ) . split ( \":\" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : Failed to get 'name: description' pair from ' { param_line } '\" ) continue if \" \" in name_with_type : name , type_ = name_with_type . split ( \" \" , 1 ) type_ = type_ . strip ( \"()\" ) if type_ . endswith ( \", optional\" ): type_ = type_ [: - 10 ] else : name = name_with_type type_ = empty default = empty annotation = type_ kind = None try : signature_param = self . signature . parameters [ name ] # type: ignore except ( AttributeError , KeyError ): self . parsing_errors . append ( f \" { self . path } : No type annotation for parameter ' { name } '\" ) else : if signature_param . annotation is not empty : annotation = signature_param . annotation if signature_param . default is not empty : default = signature_param . default kind = signature_param . kind parameters . append ( Parameter ( name = name , annotation = annotation , description = description . lstrip ( \" \" ), default = default , kind = kind , ) ) if parameters : return Section ( Section . Type . PARAMETERS , parameters ), i self . parsing_errors . append ( f \" { self . path } : Empty parameters section at line { start_index } \" ) return None , i","title":"read_parameters_section()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.DocstringParser.read_return_section","text":"Parse an \"returns\" section. Parameters: Name Type Description Default lines List[str] The return block lines. required start_index int The line number to start at. required Returns: Type Description Tuple[Optional[pytkdocs.parsers.docstrings.Section], int] A tuple containing a Section (or None ) and the index at which to continue parsing. Source code in pytkdocs/parsers/docstrings.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def read_return_section ( self , lines : List [ str ], start_index : int ) -> Tuple [ Optional [ Section ], int ]: \"\"\" Parse an \"returns\" section. Arguments: lines: The return block lines. start_index: The line number to start at. Returns: A tuple containing a `Section` (or `None`) and the index at which to continue parsing. \"\"\" block , i = self . read_block ( lines , start_index ) if self . signature : annotation = self . signature . return_annotation else : annotation = self . return_type if annotation is empty : if not block : self . parsing_errors . append ( f \" { self . path } : No return type annotation\" ) else : try : type_ , first_line = block [ 0 ] . split ( \":\" , 1 ) except ValueError : self . parsing_errors . append ( f \" { self . path } : No type in return description\" ) else : annotation = type_ . lstrip ( \" \" ) block [ 0 ] = first_line . lstrip ( \" \" ) description = dedent ( \" \\n \" . join ( block )) if annotation is empty and not description : self . parsing_errors . append ( f \" { self . path } : Empty return section at line { start_index } \" ) return None , i return Section ( Section . Type . RETURN , AnnotatedObject ( annotation , description )), i","title":"read_return_section()"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.Parameter","text":"A helper class to store information about a signature parameter.","title":"Parameter"},{"location":"reference/parsers/docstrings/#pytkdocs.parsers.docstrings.Section","text":"A helper class to store a docstring section.","title":"Section"}]}